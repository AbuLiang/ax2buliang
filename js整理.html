<!-- 测试  gir diff -->
<!-- 当前 dev -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

</body>
</html>

<Q&A 1>fixd布局
 
    只有定位元素才能用 z-index
    一个盒子如果没有上补白(padding-top)和上边框(border-top)，那么这个盒子的上边距会和其内部文档流中的第一个子元素的上边距重叠。
    如果你什么都没有进行操作的话，子元素文本节点会对上级“找麻烦”；所以，对父元素增加代码overflow：hidden。
    overflow: hidden 可以防止父元素被撑开';

<Q&A 2>call和apply区别 

    什么情况下用apply,什么情况下用call

    在给对象参数的情况下,如果参数的形式是数组的时候,比如apply示例里面传递了参数arguments,这个参数是数组类型,
    并且在调用Person的时候参数的列表是对应一致的(也就是Person和Student的参数列表前两位是一致的) 就可以采用 apply , 
    如果我的Person的参数列表是这样的(age,name),而Student的参数列表是(name,age,grade),这样就可以用call来实现了,
    也就是直接指定参数列表对应值的位置(Person.call(this,age,name,grade));

    apply的一个巧妙的用处,可以将一个数组默认的转换为一个参数列表([param1,param2,param3] 转换为 param1,param2,param3) 
    var max=Math.max.apply(null,array),这样轻易的可以得到一个数组中最大的一项

    Array.prototype.push 可以实现两个数组合并
    vararr1=new Array("1","2","3"); 
    vararr2=new Array("4","5","6"); 
    Array.prototype.push.apply(arr1,arr2);

<Q&A 3>call的存在意义


<Q&A 4>[ ].push.apply()和Array.prototype.push.apply()有区别吗？

    let arr1 = [1, 2, 3, 4, 5];
    let arr2 = [6, 7, 8, 9, 10];

    Array.prototype.push.apply(arr1, arr2);

    let arr1 = [1, 2, 3, 4, 5];
    let arr2 = [6, 7, 8, 9, 10];

    [].push.apply(arr1, arr2)

    理论上Array.prototype.push比[].push要快. 因为[].push这种方式需要在原型链上查找两次才能捕获到push方法.
    Array.prototype.push要稍稍快一点点, 大概10%的样子.

    const count = 1000000
    const a = [1, 2, 3]
    console.time('[]')
    for (let i = 0; i < count; i++) {
        [].push.apply([], a)
    }
    console.timeEnd('[]')
    console.time('Array')
    for (let i = 0; i < count; i++) {
        Array.prototype.push.apply([], a)
    }
    console.timeEnd('Array')

    没什么太大的不同，第二种写法本质上也是调用[].__proto__也就是Array.prototype上的push函数，
    除了会创建一个数组对象以外没有不同，不过浏览器对这个应该有优化，加上又少写很多字符，很多库中都是用的第二种写法。


<Q&A 5>客户端向服务端发送一个http，经过了什么



    在浏览器中输入url：

        1.在浏览器中输入url。 
        2.浏览器先查看浏览器缓存--系统缓存--路由器缓存，如果缓存中存在页面内容，就会直接在屏幕中显示。 
        3.在发送http请求前，浏览器开启一个线程来解析域名(DNS解析)，获取相应的IP地址。 
        4.浏览器向服务器发起TCP连接，与浏览器通过TCP三次握手建立连接； 
        5.握手成功后，浏览器向服务器发送HTTP请求，请求数据包。 
        6.服务器处理收到的请求，将数据返回给浏览器。 
        7.浏览器收到HTTP响应。 
        8.接下来就是页面渲染的内容了。


    一个 Chrome 浏览器
    一台 Linux 服务器
    发起 HTML 请求
    不考虑任何缓存和优化机制
    采用 HTTP/1.1 + TLS/1.2 + TCP 协议

        
        


<Q&A 6>tcp三次握手  拥塞控制

        1） Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，
        seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复

        2） Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，
        同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。
        这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。
        
        3） Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），
        Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。

        *     第一次握手：客户端向服务器发送请求报文段，其中同步位SYN=1，序号SEQ=x（表明传送数据时的第一个数据字节的序号是x），等待服务器确认；
        *     第二次握手：服务器收到客户端发来的请求，如果同意建立连接，就发回一个确认报文段，该报文段中同步位SYN=1，确认号ACK=x+1，序号SEQ=y；
        *     第三次握手：客户端收到服务器的确认报文段后，还需要向服务器给出确认，向其发送确认包ACK(ack=y+1)，进而完成三次握手。
        通过这样的三次握手，客户端与服务端建立起可靠的双工的连接，开始传送数据。
        为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。

    TCP与UDP的不同

        1. 是否需要建立连接。
            UDP在传送数据之前不需要先建立连接；TCP则提供面向连接的服务；
        2. 是否需要给出确认
          对方的传输层在收到UDP报文后，不需要给出任何确认，而 TCP需要给出确认报文，要提供可靠的、面向连接的传输服务。
        3.虽然UDP不提供可靠交付，但在某些情况下UDP是一种最有效的工作方式；【UDP取代TCP】

        和IP层的联系： IP层只负责把数据送到节点，而不能区分上面的不同应用，所以TCP和UDP协议在其基础上加入了端口的信息，每个端口标识的是一个节点上的一个应用。 
        除了增加端口信息，UPD协议基本就没有对IP层的数据进行任何的处理了。而TCP协议还加入了更加复杂的传输控制，比如滑动的数据发送窗口，以及接收确认和重发机制，以达到数据的可靠传送。
        不管应用层看到的是怎样一个稳定的TCP数据流，下面传送的都是一个个的IP数据包，需要由TCP协议来进行数据重组。
    
    TLS 传输层安全协定  前身 安全套接层 SSL 为互联网通信提供安全及数据完整性保障

<Q&A 7>URL URI区别
    URI 统一资源标识符  标识互联网资源
    URL 统一资源定位符  表示资源位置

<Q&A 8>JS 垃圾回收


<Q&A 9>SVG


<Q&A 10>Token和Session区别


<Q&A 11>new调用构造函数之后发生了什么

    1. 构建对象
    2. 将构造函数作用域赋给对象（将this指向对象）
    3. 执行构造函数的代码（为对象赋值）
    4. 返回对象


<Q&A 12>jshint js规范

    遇到这问题是因为jslint建议将use strict包装在函数中,防止js在压缩合并过程中造成歧义。
    (function() {
        "use strict";
    })();

    js里没有字典概念，以下为对象，最好采用 dot方式创建
    var dic = {
        key: '',
        age: 17,
    };
    dic.key = 'abuliang';



<Q&A 13>SEO

    一、内部优化
    　　（1）META标签优化：例如：TITLE，KEYWORDS，DESCRIPTION等的优化；
    　　（2）内部链接的优化，包括相关性链接（Tag标签），锚文本链接，各导航链接，及图片链接；
    　　（3）网站内容更新：每天保持站内的更新(主要是文章的更新等)。
    二、外部优化
    　　（1）外部链接类别：友情链接、博客、论坛、B2B、新闻、分类信息、贴吧、知道、百科、站群、相关信息网等尽量保持链接的多样性；
    　　（2）外链运营：每天添加一定数量的外部链接，使关键词排名稳定提升；
    　　（3）外链选择：与一些和你网站相关性比较高,整体质量比较好的网站交换友情链接,巩固稳定关键词排名。





<Q&A 14>语义化

    HTML + CSS + JS : 结构-表现-行为

    语义化就是让标签和其所包裹的内容的意思想吻合
    <!-- 语义化 -->
    <header>
        <h1></h1>
    </header>
    <section></section>
    <footer></footer>

    <!-- 非语义化 -->
    <div>
        <span style="font-size:16px;font-weight:bold;"></span>
    </div>
    <div></div>
    <div></div>

    好处：
    1.方便机器理解代码,利于SEO,搜索爬虫也能很好解析
    2.代码更简洁，复用性更高。使用合适的标签，可以少些很多css或者js。
    <!-- 语义化的form -->
    <form>
        <input type="submit" />
    </form>

    <!-- 非语义化的form -->
    <form>
        <a href="javascript:document.forms[0].submit()" >submit</a>
    </form>
    3.访问性更好
    这个主要就是针对读屏器或者其他一些对CSS理解不好的浏览器。语义化的HTML可以做到脱离CSS还能看，而非语义化的就难了。



<Q&A 15>数据类型

    undefined、null、boolean、number和string。还有1中复杂的数据类型————Object，Object本质上是由一组无序的名值对组成的。

    其中undefined、null、boolean、number都属于基本类型。Object、Array和Function则属于引用类型。

    string有些特殊，string类型用于表示由零或多个16位Unicode字符组成的字符序列
    string类型有些特殊，因为字符串具有可变的大小，所以显然它不能被直接存储在具有固定大小的变量中。由于效率的原因，JS只复制对字符串的引用，而不是字符串的内容。
    但是另一方面，字符串在许多方面都和基本类型的表现相似，而字符串是不可变的这一事实（即没法改变一个字符串值的内容），因此可以将字符串看成行为与基本类型相似的不可变引用类型

    Boolean、Number、String 这三个是Javascript中的基本包装类型，也就是这三个其实是一个构造函数，他们是Function的实例，是引用类型，



<Q&A 16>webpack 原理

<Q&A 17>双向绑定

<Q&A 18>浏览器多页面间通信

    利用localstorage 和cookies等本地存储方式

<Q&A 19> JS 实现继承的方式
    1.原型链继承；
        function Super () {
            this.name = 'hhh';
            this.arr = ['nb'];
        }
        function Sub () {}
        Sub.prototype = new Super();
        let sub1 = new Sub();
        let sub2 = new Sub();
        
        sub1.name = 'yyy';
        sub1.arr.push('hehe');
        console.log(sub1.name, sub1.arr); // 'yyy', ['nb', 'hehe']
        console.log(sub2.name, sub2.arr); // 'hhh', ['nb', 'hehe']

        实现的本质是重写原型对象，代之以一个新类型的实例。Sub.prototype=new Super()；从而使子类得以继承父类的属性和方法。

        注意这里sub1.constructor === Super为 true。(Sub.prototype.__proto__ === Super.prototype实例属性的查找自下往上进行查找的原则)

        优点：简单，易于实现。
        缺点：
            包含引用类型的原型属性会被所有实例共享；（这也是为什么要在构造函数中定义属性，而不是在原型对象中定义属性的原因）。
            从例子中可以看出实例 sub1 修改 arr 后，也会改变 实例 sub2.arr 的值。
            创建子类实例时，无法向父类构造函数传参。实际上，应该说无法在不影响所有实例对象的情况下，给父类的构造函数传递参数。

    2.构造函数继承；
        function Super(name) {
            this.name = name;
            this.arr = ['nb'];
            this.fun = function() {
                // ...
            }
        }
        function Sub(name) {
            this.hobby = 'hhh';
            Super.call(this, name);
        // Super.call(this); 可传参 可不传
        }
        let sub1 = new Sub('xql');
        let sub2 = new Sub('nnn');
        
        sub1.name = 'xxx';
        sub1.arr.push('hehe')
        console.log(sub1.name, sub1.arr); // xxx, ['nb', 'hehe']
        console.log(sub2.name, sub2.arr); // nnn, ['nb']

        实现的本质：借用父类的构造函数来增强子类实例。等于是把父类的实例属性复制了一份给子类实例装上了（完全没有用到原型）

        优点：

            解决了子类实例共享父类引用属性的问题；
            创建子类实例时，可以向父类构造函数传参；
            可以实现多继承（call多个父类对象）；

        缺点：

            方法都在构造函数中定义，函数复用也就无从谈起了。每个子类都有父类实例属性副本。每个子类实例都持有父类的所有函数方法，太多了就会影响性能，内存爆炸。。
            只能继承父类的实例属性和方法，不能继承父类原型属性和方法。
            实例并不是父类的实例，只是子类的实例。

    3.组合继承（原型链继承 + 构造函数继承）（最常用）；
        function Super(name) {
            // 只在此处声明基本属性和引用属性
            this.name = name;
            this. arr = ['nb'];
        }
        //  在原型处声明函数
        Super.prototype.fun1 = function() {}
        Super.prototype.fun2 = function() {}
        // ...
        function Sub(name) {
            this.hobby = 'hhh';
            Super.call(this, name); // 核心 第二次调用父类构造函数
        }
        Sub.prototype = new Super(); // 核心  第一次调用父类构造函数
        Sub.prototype.constructor = Sub;  // 需要修复构造函数的指向
        Sub.prototype.fun11 = function() {}
        let sub1 = new Sub('xql');
        
        console.log(sub1);

        实现的本质：把实例函数都放在原型对象上，以实现函数复用。同时还要保留借用构造函数方式的优点。
        （使用原型链实现对原型属性和方法的继承（一般不在原型上写引用属性），而通过借用构造函数来实现对实例属性的继承）。
        即在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。

        优点：

            函数可复用；
            可以继承实例属性/方法，也可以继承原型属性/方法；
            既是子类的实例，也是父类的实例；
            不存在引用属性共享问题；
            可传参

            ps: 修复了上述两种方式的缺点。
        缺点：
            子类原型上有一份多余的父类实例属性；因为父类构造函数被调用了两次，生成了两份；
            而子类实例上(来自父类func Super(),call为子类实例复制了一份)的那一份屏蔽了子类原型上(来自父类实例new Super(),Sub.prototype = new Super())的。又是内存浪费。

    4.原型式继承
        function object(obj) {
            function F() {} // 临时的构造函数
            F.prototype = obj;
            return new F();
        }
        实际等同于创建对象副本，返回的副本将对象作为原型
        ES5添加了Object.creat()方法，接受两个参数，第二个可省略，省略后方法同上述代码一样，第二个参数用于覆盖原型对象的属性(类似Object.defineProperties())
        缺点：
            必须要有一个对象，可以作为另一个对象的基础。
            与原型模式一样，没有解决 子实例共享引用类型的属性 问题
            
    5.寄生式继承（原型式+增强语句）
        function object(obj) {
            function F() {} // 临时的构造函数
            F.prototype = obj;
            return new F();
        
        function createAnother(original){
            var clone = object(original);
            clone.sayHi = function() {
                console.log('hi');
            }
            retrun clone;
        }

        var person = {
            name: "abulaign",
            friends: ['sdc','sfg']
        };
        var anotherPerson = createAnother(person);
        anotherPerson.sayHi(); //hi

        缺点： 不能复用函数，与构造函数模式类似。

    6.寄生组合继承 （寄生式+组合式，最佳方式）
        function object(obj) {
            function F() {} // 临时的构造函数
            F.prototype = obj;
            return new F();
        }
        function inherit(SubType, SuperType) {
            let proto = Object.create(SuperType.prototype);
        // let proto = object(SuperType.prototype);
        // object函数见上 原型式继承
            proto.constructor = SubType;
            SubType.prototype = proto;
        }
        function Super(name) {
            this.name = name;
            this.friends = ['nnn'];
        }
        Super.prototype.fun1 = function() {}
        Super.prototype.fun2 = function() {}
        // ...
        function Sub(name) {
            this.hobby = 'hhh';
            Super.call(this, name);
        }
        inherit(Sub, Super); // 核心
        Sub.prototype.fun11 = function() {}
        // ...
        let sub1 = new Sub('xql');
        console.log(sub1);

        优点：同组合继承。但解决了组合继承的缺点，只调用了一次父类构造函数，避免了在子类构造函数的原型上创建不必要的、多余的属性。
        缺点：理论上没有。

        寄生组合式继承本质：
                继承的本质目的是让子类可以获得父类的方法和属性，其中方法存在父类原型super.prototype里，属性存在父类构造函数super.constructor中
                组合式继承是通过：
                        sub.prototype = new super() 来使子类获取父类原型中的方法，但此时，父类实例从其构造函数中获取的属性也会复制一份到子类的原型中，（这份属性是多余的，会被之后获取的覆盖掉，不会传到子类构造和实例中）
                        在sub.constructor里调用父类构造函数super.call(this)，使子类构造函数创建的子类实例都获得一份父类构造函数super.constructor里的属性，（会覆盖之前子类原型获得属性）
                
                寄生组合式就是为了避免多余的属性赋值，利用寄生式改写组合式里获取父类原型方法的方式，利用父类原型的克隆副本替换子类原型，让子类实例可以获取父类原型中的方法，又不会从父类实例中多赋值一份父类构造函数的属性
                利用寄生式原理，先克隆一份父类原型的副本 prototype = object（super.prototype），可以增加增强语句，并改写构造函数指向prototype.constructor = sub.constructor，然后替换子类原型，sub.prototype = prototype
                第二部分依旧在子类构造函数里调用父类构造函数 super.call(this)，以便让子类实例获得父类构造函数里的属性。

        寄生组合式 优点：
                通过父类原型副本替换子类原型，使子类实例可以继承父类原型中的方法。（没有多余属性赋值，克隆父类原型时可以进行增强：即为子类原型添加新共有方法）
                通过子类构造中调用父类构造，使子类实例可以继承父类构造中的属性。（子类构造中，在调用super.call(this)也可以进行增强：即为子类实例添加新共有属性）


    7.es6继承
        class Animals {
            constructor(type, name) {
                this.type = type;
                this.name = name;
            }			
            eat() {
                console.log('这是一只小'+ this.type + '： 它会吃东西');
            }
        }
                
        let animal = new Animals('狗', '旺财');
            
        class Car extends Animals {
            constructor(sex) {
                super('猫', '小花');   
                // 此处是重点在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则
                // 会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例
                this.sex = sex;
            }
        }			
        let car = new Car('公');
        car.eat();

        优点：使用extends关键字实现继承，语法上更加清晰明了
        缺点：子类实例的构建，基于父类实例  子类继承父类后，子类的构造函数，必须执行super方法


<Q&A 20> 跨域

    形成原因：
            为了安全问题，防止CSRF和XSS攻击，现代浏览器都采用了同源访问机制，只允许页面访问请求同一个源内的资源，
            本质上：服务器端会响应一切跨域请求，并返回相应的数据，但浏览器会阻截返回的响应
            所以使用ajax发起的跨域http请求得到的响应都会被浏览器截下，
            而<img/><script/><iframe><link>标签携带 src属性，可以不受同源策略的限制，直接访问跨域资源
            （有人指出原因是：通过src加载的资源，浏览器限制了脚本对其返回的内容无法读写。 所以该访问方式比较安全，浏览器不会限制？）

    解决方案：
            1 cors
                浏览器如果想发起跨域请求，则需要在请求的头部添加Origin字段，指出发起跨域请求的当前页面的url，服务器通过查看origin字段值，后端经过审核后如果同意该跨域请求，
                则会在响应头中添加 access-control-allow-origin 字段，告知浏览器放行此跨域响应，origin页面就可以拿到跨域资源

            2 图像ping
                只能发GET请求；
                无法访问服务器响应文本；
                只能单向 浏览器-->服务器；
                常用来跟踪用户点击或广告曝光次数；

            3 JSONP
                可以访问响应文本；
                双向通信 
                不安全
                无法确定是否失败  为此，H5新增onerror时间处理函数

            4 comet
                推送数据
                实现方式：长轮询和流  HTTP流只建立一个HTTP链接

            5 SSE
                单向
                支持长短轮询 HTTP流
                能确定合适重连
                构造函数接受相对URL
                组合XHR和SSE也能实现双向通信

            6 web sockets
                全双工 双向通信
                开销小 速度快
                只能发送文本
                不支持DOM2监听器
                适合移动端
                构造函数接受绝对URL
                同源策略对web sockets无效
                需要专门服务器，普通http服务器不行
                首先通过http请求，发送到浏览器，建立连接，然后从http协议升级到web socket协议
                适用于聊天室场景(双向通信)

            7

            8

            9

<Q&A 21> 堆栈
<Q&A 22> js底层闭包
<Q&A 23> 触发隐式转换
<Q&A 24> 继承
        原型链继承：Sub.prototype = new Super(); // 子类可以继承父类原型的属性和方法，但多个子类实例共享属性，会互相影响
    
        伪构造函数继承：Super.call(this,args); // 在子类中调用，子类和父类原型之间没关系，不能调用父类原型的属性，但子类实例会复制一份父类构造函数的属性，因此各实例之间互不影响。
    
        组合继承：先Sub.prototype = new Super(); // 但要修复Sub.prototype.constructor的指向，Sub.prototype.constructor = Sub;
                    后Super.call(this, args);
                    // 子类实例可以使用父类原型的属性，同时引用类型属性通过复制到子类实例中，不会互相影响。
                    // 缺点是 子类具有两份复制的属性，子类实例上一份(来自父类构造函数，构造继承)，子类原型上一份(被屏蔽，来自父类原型，原型链继承)

<Q&A 25> 为什么组合继承需要修改 Sub.prototype.constructor = Sub
<Q&A 26> arr.push.apply(arr,[1,2,3,4]);
    有两种说法：1. 在arr的作用域内调用arr.push(),参数为1,2,3,4 // arr.push(1,2,3,4)
               2. 将apply前面的对象的this指向arr，arr调用其方法。
    最好用forEach替代apply，向数组内循环push
        let arr = [];
        arr.push(1);
        let arr2 = [2,3,4,5];
        arr2.forEach(myeach,arr);
        function myeach(item,index){
        this.push(item);
        console.log(this);
        }
    或    
        let arr = [];
        arr.push(1);
        let arr2 = [2,3,4,5];
        arr2.forEach((item,index)=>{arr.push(item);console.log(arr);},arr);


<Q&A 27> 箭头函数的this指向
    取决于箭头函数外层 最接近的this值
    注意：
         obj没有this值，所以箭头函数作为obj的方法时，this等于更外层的this值
         此外：
            正常函数作为obj方法时，this == obj；
            嵌套在别的方法里，属于独立调用，非严下this默认指向window，严格下等于undefined


<Q&A 28> 事件代理的原理

<Q&A 29> call和apply区别，使用场景

<Q&A 30> jsonp原理

<Q&A 31> 不定宽高元素水平垂直居中

<Q&A 32> 3点15分夹角度数

<Q&A 33> 闭包，继承

<Q&A 34> vue双向绑定如何实现、组件封装

<Q&A 35> vue3.0新特征有什么了解

<Q&A 36> 在vue过程中遇到什么问题，怎么解决

<Q&A 37> js继承实现方法

<Q&A 38> async await理解

<Q&A 39> 对class了解吗

<Q&A 40> 闭包是什么，好处和坏处，使用场景

<Q&A 41> vuecli3.0

<Q&A 42> 实现一个diff

<Q&A 43> 实现一个Promise
    
<Q&A 44> 实现一个响应式
<Q&A 45> 结束内部闭包对外部作用域的引用
<Q&A 46> js预编译
    function f(){
        console.log(haha);
        haha = 123;
        function haha(){
            console.log('nihao');
        }
    }
    f();
    console.log(haha);

        f()内部的执行顺序应该是，先声明了haha函数，
        然后又console.log输出函数定义，最后再haha=123，执行完毕后haha消失。
        
        也就是预编译的时候ao里已经有haha了，所以不会提升到全局
        
<Q&A 47> 
    ES5 规定，函数只能在顶层作用域或函数作用域中声明，不能在块级作用域中声明
    
    if (true) {
        function f() {}
    }

    try{
        function f() {}
    } catch(e) {
        //..
    }

    以上声明都是错的，但浏览器不会报错，为了兼容旧代码
<Q&A 48> position的值
<Q&A 49> css选择器
<Q&A 50> js如何取标签
<Q&A 51> http请求结构
<Q&A 52> get和post区别

        get参数通过url传递，post放在request body中
        get请求的url的参数长度有限制，post没有
        post更安全，不会暴露参数
        get只支持url编码， post支持多种编码
        get请求 浏览器会主动cache， post的参数不会被保留
        get和post本质是TCP链接，
        get产生一个数据包，post产生两个数据包
            post请求会先发一个tcp包，把header发过去，然后由于nagle算法，等待tcp的ack，再发剩下的包
            （到底发多少个tcp包，不是http协议的事情，是操作系统tcp协议栈和框架代码里write调用的事情。大多数框架都是尽量在一个tcp包里面把HTTP请求发出去的，
            但是也确实存在先发HTTP头，然后发body的框架。但是具体发多少个TCP包，这个是代码的问题，是tcp协议栈的问题，跟HTTP没关系。）

<Q&A 53> 浏览器缓存
        
<Q&A 54> vuex
<Q&A 55> 状态码
<Q&A 56> 快排
<Q&A 57> 事件委托
<Q&A 58> 继承
<Q&A 59> 时间片轮转法
<Q&A 60> 缓存
        304 协商缓存
        302 
        303 
        307 
<Q&A 61> 不用cookie,怎么做身份识别
<Q&A 62> Object.prototype.toString.call(obj)
<Q&A 63> 
 JS基础知识

        原始类型
        对象类型
        typeof与instanceof
        类型转换
        this
        == 与===
        闭包
        深浅拷贝
        原型
        
 ES6知识点
        
        var，let，const
        原型继承和class继承
        模块化
        Proxy
        map, filter, reduce
        
 JS异步编程
        
        并发与并行
        回调函数
        Generator生成器
        Promise
        async 及 await
        常用定时器函数
        
 手写 Promise
        
        Promise/A+规范
        实现一个符合 Promise/A+ 规范的 Promise
        
 Event Loop
        
        进程与线程
        执行栈
        浏览器中的 Event Loop
        Node 中的 Event Loop
        
 JS进阶知识
        
        自己动手实现call、apply 及 bind 函数
        new关键字
        instanceof 的原理
        为什么 0.1 + 0.2 != 0.3
        垃圾回收机制
        
<Q&A 64> cvte 一面
    盒子模型 margin重叠 解决 水平垂直居中对齐 移动端上下固定中间 自适应滚动布局
    原型原型链应用场景 闭包及应用场景
    手写防抖动和节流
    apply和call 的区别
    es6用过哪些
    cookie作用 如何添加和删除cookie
    storage作用
    http状态码 401和403区别  http缓存  跨域  安全
    vue原理 vue-router钩子函数作用 vue内组件传值方式
    用过nodejs吗 前端优化方法 
    webpack作用 配置过webpack吗
    快排和冒泡区别 时间复杂度  手写快排
    编程：找出字符串中第一个出现一次的字符
    外来三年规划

<Q&A 65> 发一个ajax请求到后台，那么会经历哪些阶段才会重新回到前端和从浏览器输入地址到页面加载的过程有什么不同？

<Q&A 66> 防抖

<Q&A 67> 谈谈对前端安全的理解及防范

<Q&A 68> cors跨域

<Q&A 69> 手写ajax 然后封装一个类似axios的函数 

<Q&A 70> 手写jsonp

<Q&A 71> async await 原理

<Q&A 72> promise和他们的区别

<Q&A 73> css动画

<Q&A 74> es6 proxy vue双向绑定实现 css动画 js动画 dom动画 vue实现一个组件

<Q&A 75> 实现不同分辨率的屏幕上有不同体验效果
    媒体查询和flex

<Q&A 76> vue依赖收集
    数据劫持 的依赖收集
    dep的target为什么要缓存this

<Q&A 77> vue 数据劫持、路由、nexttick
    数据劫持是用Object.defineproperty

<Q&A 78> Object.defineproperty()怎么实现数据劫持并发布?
    Set和get 加上发布订阅模式
    set触发 对应监听对象的回调函数
    Get收集  监听对象

<Q&A 79> jq中怎么避免回流跟重绘

<Q&A 80> cookie
        cookies主要作用是维护服务器和客户端状态
        不是存储 所以才有loacl和session出现

<Q&A 81> PDD实习岗

    一面技术

    1. 前后端用不同的协议https，http能直接通信吗？

    2. http实现机制

    3. Vue底层如何实现双向数据绑定的

    4. JS是软硬类型语言，不同类型变量组合比较

    5. axios底层实现，和ajax的比较

    6. mock底层实现

    7. git一些指令，和svn比较

    8. 即时通信用什么协议（WebSocket）

    9. Echarts，热力图原生实现

    10. 手写闭包和讲解

    11. 继承有哪些

    12. 讲下Promise，Generator和async

    13. webpack如何在浏览器中实现ES6

    14. Vue如何获取页面内的元素，知道ref吗
    Vue1.x中使用v-el标记DOM元素，v-ref标记组件元素,2.0以后统一使用ref标记

    15. 组件通信，知道VUEX吗

    16. 缓存（只说了cookie貌似太少了），如果存储一些不需要改变的数据可以怎么缓存

    17. 跨域形成的原因

        一个域的文档或脚本访问另一个域的资源时，产生跨域问题    
        
        出于安全考虑：预防CSRF(跨站点请求伪造)？？？

        域名、端口、协议

    18. VUE和其他框架比的优缺点


    二面HR
    为什么投拼多多的前端实习岗位
    为什么会选择前端
    怎么看待拼多多这家公司
    本科和研究生期间为什么没去实习
    是保研吗，为什么考研不考一个更好学校
    除了PDD，有投其他公司的实习吗
    家庭成员工作情况

<Q&A 82> 当焦点从页面的一个元素移向另一个元素
    依次触发：
    focusout
    focusin
    blur 
    DOMFocusOut
    focus
    DOMFocusIn

    其中 
    focus 和 blur不冒泡
     focusout 和 focusin 冒泡 是IE 事件  被纳入 DOM3
     DOMFocusOut 和 DOMFocusIn 冒泡 是 Opera 事件

<Q&A 83> 为什么需要块级作用域

    1.防止由于变量提升导致内层变量覆盖外层变量
    2.防止计数的循环变量泄漏到全局
    3.可以代替IIFE(立即执行函数) IIFE最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。

<Q&A 84> ES5 和 ES6 区别

    1.es5不允许块级作用域内声明函数，es6允许

    2.es5只能通过 var function 命令声明变量， es6 增加了 let const import class
    
    3.es5中顶层对象的属性和全局变量是等价的 var a=12; window.a // 12  
      es6中 var function声明的变量是顶层对象的属性，而let和const calss声明的不是，全变与顶对逐渐隔离

    4.es5中 浏览器顶层对象是window，浏览器和web worker的self指向 顶层对象，Node 没有self，其顶层对象是global
      全局环境中，this返回顶层对象， 在Node和ES6模块中，this返回当前模块。

    5.es6 允许模式匹配赋值 let [a,b,c] = [1,2,3];

    6.es5不允许为函数的参数设置默认值，默认值是惰性求值的，es6允许 指定默认值后，length属性失真，返回第一个具有默认值的参数之前的没有默认值的参数个数

    7.es5函数内部可以 严格模式， es6 函数参数使用默认值，解构赋值或者扩展运算符，就不能 严格模式 
        原因：严格模式同时适用于参数和函数体，但只有从函数体中才能知道参数是否应该严格，而执行顺序则是先参后体
        办法：全局严格模式；把函数包在IIFE里，IIFE里声明 “use strict”

    8.es6新增 set、map
        js原有表示集合的数据结构：array 和 object ，es6 新增 set map
        const set = new Set([1,1,2,4,5,3,2]);
        [...set]
        (5) [1, 2, 4, 5, 3]

        const set = [1,2,3,4,5];
        set  = new Set([...set].filter(x=>(x%2)==0); //[2,4]

        let union = new Set([...a, ...b]) //并集

        set的运算规则类似 ===  但是会认为NaN等于自身， 而 === 运算符不等
        set 没有键名只有键值(key和value同值)

        两个对象总是不相等的
        set.add({});
        set.add({});
        set.size //2

        es6规定 weakSet不能遍历（因为都是弱引用），成员只能是对象，且对象都是弱引用

        object结构：字符串--值
        Map结构： 值--值

        weakMap不能遍历不能取键名，不能清空
        weakmap只接受对象做key，weakset成员也只能是对象，都是弱引用，垃圾回收不会考虑其引用
        应用：
         1.以DOM节点作为键名  注册监听事件的listener对象适合放在WeakMap里
            const listener = new WeakMap();

            listener.set(element1, handler1);
            listener.set(element2, handler2);

            element1.addEventListener('click', listener.get(element1), false);
            element1.addEventListener('click', listener.get(element2), false);
         2.部署私有变量
            一旦实例删除，利用WeakMap部署的私有变量立即销毁

    9. es6新增 for...of
    
    10. es6提供了Generator 作为异步编程解决方案
        Generator是es6对协程的不完全实现，称为 半协程（只有Generator函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行）

    11. es6中Class可以通过extends实现继承，es5需要修改原型链
        es5继承实质是先创造子类this，然后将父类的方法添加到this上，Parent.aply(this)
        es6继承实质是先创造父类实例对象this（所以须先调用super），然后再用子类构造函数修改this

    12. 浏览器加载ES6模块时，也使用<script></script>, 但要加type="module"属性

    13. ES5模块开发 使用 AMD、CMD、CommonJS ES6新增 export/import

    14. 默认参数
            es5 无法设默认值为0 因为 0 就是 false， || 会取 false
                var link = function (height, color, url) {
                    var height = height || 50
                    var color = color || 'red'
                    var url = url || 'http://azat.co'
                    ...
                }
            es6  
                var link = function(height = 50, color = 'red', url = 'http://azat.co') {
                    ...
                }

    15. 模版表达式 `${}`  
                    es5 var name = 'Your name is ' + first + ' ' + last + '.' 
                    es6 var name = `Your name is ${first} ${last}`

    16. 多行字符串
                es5 
                    var roadPoem = 'Then took the other, as just as fair,nt'
                    + 'And having perhaps the better claimnt'
                es6
                    var roadPoem = `Then took the other, as just as fair,
                    And having perhaps the better claim`

    17. 拆包表达式（结构？）
                 es5
                    var data = $('body').data(), // 假设data中有mouse和house的值
                    house = data.house,
                    mouse = data.mouse
                 es6
                    var { house, mouse} = $('body').data()

    18. 改进的对象表达式

    19. 箭头函数 =>
                    es5 
                        var _this = this
                            $('.btn').click(function(event){
                            _this.sendData()
                        })
                    es6 去掉了_this = this, 箭头函数可直接获得外部 this ，使用箭头函数可以让我们不再用that = this或者self = this或者_this = this或者.bind(this)这样的代码
                        $('.btn').click((event) =>{
                            this.sendData()
                        })

    20. Promise
                es5
                    setTimeout(function(){
                        console.log('Yay!')
                    }, 1000)
                es6
                    var wait1000 =  new Promise(function(resolve, reject) {
                        setTimeout(resolve, 1000)
                    }).then(function() {
                        console.log('Yay!')
                    })    

                    var wait1000 =  new Promise((resolve, reject)=> {
                        setTimeout(resolve, 1000)
                    }).then(()=> {
                        console.log('Yay!')
                    })

    21. 块级作用域的let和const

    22. 类
            ES6的类会用prototype来实现而不是function。现在有一个baseModel类，其中我们可以定义构造函数和getName()方法
                class baseModel {
                    constructor(options = {}, data = []) { // class constructor
                        this.name = 'Base'
                    this.url = 'http://azat.co/api'
                        this.data = data
                        this.options = options
                    }
                
                    getName() { // class method
                        console.log(`Class name: ${this.name}`)
                    }
                }
                class AccountModel extends baseModel {
                    constructor(options, data) {
                    // 调用父类构造函数时，只需带上参数轻松的调用super()方法。
                    super({private: true}, ['32113123123', '524214691']) //call the parent method with super
                    this.name = 'Account Model'
                    this.url += '/accounts/'
                }

    23. 模块化 
                ES5中你会用script标签和IIFE(立即执行函数)，或者是其他的像AMD之类的库,ES6中你可以用export来暴露你的类。用和Node.js语法一样的CommonJS，然后用Browserfy来浏览器化。
                es5 
                    ES5的main.js中，
                    module.exports = {
                        port: 3000,
                        getAccounts: function() {
                        ...
                        }
                    }
                    用require('模块')来导入
                    var service = require('module.js')
                    console.log(service.port) // 3000
                es6 
                    ES6中的module.js文件
                    export var port = 3000
                    export function getAccounts(url) {
                    ...
                    }
                    用export和import
                    import {port, getAccounts} from 'module'
                    console.log(port) // 3000
        
    24. es6对象扩展
                    Object.is()
                                ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。
                                它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。
                                JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。
                                
                                它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
                                    Object.is('foo', 'foo')
                                    // true
                                    Object.is({}, {})
                                    // false
                                    
                                    +0 === -0 //true
                                    NaN === NaN // false

                                    Object.is(+0, -0) // false
                                    Object.is(NaN, NaN) // true

                    Object.assign()
                                用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
                                会忽略enmerable为false的属性
                                var target = { a: 1 };
                                var source1 = { b: 2 };
                                var source2 = { c: 3 };

                                Object.assign(target, source1, source2);
                                target // {a:1, b:2, c:3}
                    
                    __proto__属性、Object.setPrototypeOf()、Object.getPrototypeOf()
                                Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。
                                // 格式
                                Object.setPrototypeOf(object, prototype)

                                // 用法
                                var o = Object.setPrototypeOf({}, null);
                                该方法等同于下面的函数。

                                function (obj, proto) {
                                obj.__proto__ = proto;
                                return obj;
                                } 
                    
                    Object.values()，Object.entries()
                                Object.keys() 是es5引入的，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。
                                目前，ES7有一个提案，引入了跟 Object.keys()配套的 Object.values()和 Object.entries()
                                Object.values()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。
                                Object.values()返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。

                                    var obj = { 100: 'a', 2: 'b', 7: 'c' };
                                    Object.values(obj)
                                    // ["b", "c", "a"]

                                    Object.values('foo')
                                    // ['f', 'o', 'o']
                                
                                Object.entries() 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。
                                    var obj = { foo: 'bar', baz: 42 };
                                    Object.entries(obj)
                                    // [ ["foo", "bar"], ["baz", 42] ]
                                    除了返回值不一样，该方法的行为与Object.values基本一致。
                                    Object.entries() 的基本用途是遍历对象的属性。
        
    25. 会忽略enmerable为false的属性的操作
                es5
                    for...in循环：只遍历对象自身的和继承的可枚举的属性
                    Object.keys()：返回对象自身的所有可枚举的属性的键名
                    JSON.stringify()：只串行化对象自身的可枚举的属性
                es6 增加了Object.assign
    
    26. es6数组扩展
                    Array.from()
                    Array.of()
                    fill()
                                        

<Q&A 85> ES6 块级作用域声明函数报错

    ES6书 P25
    使用函数表达式而不是声明
    必须使用大括号

<Q&A 86> const 不是变量的值不变，而是变量指向的内存地址不变

<Q&A 87> 任何具有Iterator接口的对象都可以 for...of  

    var map = new Map();
    map.set('first','hello');
    map.set('second','world');
    for (let [key,value] of map){}
    for (let [,value] of map){}

<Q&A 88> es6 函数默认值和解构默认值 结合  书P106

    // 1
    function m1({x=0,y=0}={}){return [x,y];}
    // 2
    function m2({x,y}={x:0,y:0}){return [x,y];}

    m1() // [0,0]
    m2() // [0,0]

    m1({x=3,y=8}) // [3,8]
    m2({x=3,y=8}) // [3,8]

    m1({x:3}) // [3,0]   函数参数输入为{x:3}，解构后 x=3，y=undefined  y有默认值且全等于undefined  y取默认值 0
    m2({x:3}) // [3,undefined]  函数参数输入为{x:3}，解构后 x=3，y=undefined  y没有默认值 返回undefined

    m1({}) // [0,0]  函数参数输入为{}，解构后 x=undefined，y=undefined  x，y都有默认值所以且全等于undefined x=0，y=0
    m2({}) // [undefined,undefined]  函数参数输入为{}，解构后 x=undefined，y=undefined  x，y都没有默认值 返回 undefined

    m1({z:3}) // [0,0]
    m2({z:3}) // [undefined,undefined]

<Q&A 89> es7 函数绑定

    显示绑定this call apply bind
    箭头函数
    es7  对象::函数    将对象的上下文环境绑到函数上
    foo::bar;  ===  bar.bind(foo);
    foo::bar(...arguments);  ===  bar.apply(foo,arguments);
    ::obj.foo;  ===  obj::obj.foo  ===  obj.foo.bind(obj);

<Q&A 90> undefined 和 null 无法转换成对象

<Q&A 91> H5 一共有6种缓存机制

    1.浏览器缓存机制
        cache-control：max-age=600；
        cache-control 配合 last-modified 使用，
        last-modified 标记资源最新更新时间 如果缓存过期，浏览器请求if-modified-since字段带上该时间发送服务端，资源没修改 返回304
        Expires: Thu, 10 Nov 2015 08:45:11 GMT
        Expires是HTTP1.0 实现的 cache-control是HTTP1.1 新加 两者类似，标记资源过期时间 ，cache-control优先级高
        Etag 和 last-modified 一样， 值是标识文件的特征字符串，Etag优先级大于Last-Modified
        浏览器通过if-none-match 将特征字符串发给服务端，服务端与新文件的特征字符串比较，没变 返回304

        etag —— if-none-match
        last-modified —— if-modified-since (进行协商缓存时，客户端通过该字段将last-modified的值发送给服务器，和服务器端保存的值进行比较，检查资源是否更新)

        etag last-modified存在缓存资源的响应头中

        手动刷新页面（F5)，浏览器会直接认为缓存已经过期（可能缓存还没有过期），在请求中加上字段：Cache-Control:max-age=0，发包向服务器查询是否有文件是否有更新。
        强制刷新页面（Ctrl+F5)，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control:no-cache（或 Pragma:no-cache），发包向服务重新拉取文件。

        Cache-Control:no-cache  在释放缓存之前，强制提交请求给原始服务器
        Cache-Control:no-store  缓存不应存储有关客户端请求或服务器响应的任何内容。

        Cache-Control 和 Last-Modified 一般用在 Web 的静态资源文件上，如 JS、CSS 和一些图像文件。
        带 if-Modified-Since 字段的请求，如果服务器回包304，回包带有 Cache-Control:max-age 或 Expires 字段，文件的缓存有效时间会更新，就是文件的缓存会重新有效。

        强缓存：命中cache-control和expires 不通知服务器，直接从本地缓存取
        协商缓存：命中etag和last-modified 通知服务器，服务器检查后发现资源未更新通知客户端可以继续用缓存，返回304 和 新的cache-control和expires

        协商缓存都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，
        这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），
        则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。

    2.Dom Storgage（Web Storage）存储机制

        Dom Storage 是通过存储字符串的 Key/Value 对来提供的，并提供 5MB （不同浏览器可能不同，分 HOST)的存储空间（Cookies 才 4KB)。
        另外 Dom Storage 存储的数据在本地，不像 Cookies，每次请求一次页面，Cookies 都会发送给服务器。

        sessionStorage 用来存储与页面相关的数据，它在页面关闭后无法使用。适用于会话的小段数据。适合意外刷新时，保存已填写的数据
                <script type="text/javascript">
                // 当页面刷新时，从sessionStorage恢复之前输入的内容
                window.onload = function(){
                    if (window.sessionStorage) {
                        var name = window.sessionStorage.getItem("name");
                        if (name != "" || name != null){
                            document.getElementById("name").value = name;
                        }
                    }
                };
                
                // 将数据保存到sessionStorage对象中
                function saveToStorage() {
                    if (window.sessionStorage) {
                        var name = document.getElementById("name").value;
                        window.sessionStorage.setItem("name", name);
                        window.location.href="session_storage.html";
                    }
                }
                </script>
                
                <form action="./session_storage.html">
                    <input type="text" name="name" id="name"/>
                    <input type="button" value="Save" onclick="saveToStorage()"/>
                </form>
        localStorage 则持久存在，在页面关闭后也可以使用。可以不指定域名，子域名不能访问，是storage实例
                <script>
                //通过localStorage直接引用key, 另一种写法，等价于：
                //localStorage.getItem("pageLoadCount");
                //localStorage.setItem("pageLoadCount", value);
                if (!localStorage.pageLoadCount)
                localStorage.pageLoadCount = 0;
                    localStorage.pageLoadCount = parseInt(localStorage.pageLoadCount) + 1;
                    document.getElementById('count').textContent = localStorage.pageLoadCount;
                </script>
                
                <p>
                    You have viewed this page
                    <span id="count">an untold number of</span>
                    time(s).
                </p> 

        二者区别：
                sessionStorage是面向会话的，临时的，全局对象，会话期间有效的存储空间，关闭也页面就没了，打开的各个页面之间没影响
                localStorage是持久的，重新打开页面，可以获取上次保存的数据。全局性的，各页面之间共享一份数据

    3.Web SQL Database 存储机制

        用于存储适合数据库的结构化数据。根据官方的标准文档，Web SQL Database 存储机制不再推荐使用，也不在维护
                <script>
                    if(window.openDatabase){
                        //打开数据库，如果没有则创建
                        var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024);
                
                        //通过事务，创建一个表，并添加两条记录
                        db.transaction(function (tx) {
                            tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)');
                            tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, "foobar")');
                            tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, "logmsg")');
                        });
                
                        //查询表中所有记录，并展示出来
                        db.transaction(function (tx) {
                            tx.executeSql('SELECT * FROM LOGS', [], function (tx, results) {
                                var len = results.rows.length, i;
                                msg = "<p>Found rows: " + len + "</p>";
                                for(i=0; i<len; i++){
                                    msg += "<p>" + results.rows.item(i).log + "</p>";
                                }
                                document.querySelector('#status').innerHTML =  msg;
                            }, null);
                        });
                    }
                
                </script>
                
                <div id="status" name="status">Status Message</div>

    4.Application Cache（AppCache）机制

        似乎是为支持 Web App 离线使用而开发的缓存机制,类似于浏览器的缓存（Cache-Control 和 Last-Modified）机制，
        都是以文件为单位进行缓存，且文件有一定更新机制。但 AppCache 是对浏览器缓存机制的补充，不是替代。

                <!DOCTYPE html>
                <html manifest="demo_html.appcache">
                <body>

                <script src="demo_time.js"></script>

                <p id="timePara"><button onclick="getDateTime()">Get Date and Time</button></p>
                <p><img src="img_logo.gif" width="336" height="69"></p>
                <p>Try opening <a href="tryhtml5_html_manifest.htm" target="_blank">this page</a>, then go offline, and reload the page. The script and the image should still work.</p>

                </body>
                </html>
        
        AppCache 的原理有两个关键点：manifest 属性和 manifest 文件。
        HTML 在头中通过 manifest 属性引用 manifest 文件。manifest 文件，就是上面以 appcache 结尾的文件，是一个普通文件文件，列出了需要缓存的文件。

        完整的 manifest 文件，包括三个 Section。

            CACHE MANIFEST - Files listed under this header will be cached after they are downloaded for the first time
            NETWORK - Files listed under this header require a connection to the server, and will never be cached
            FALLBACK - Files listed under this header specifies fallback pages if a page is inaccessible
            
            CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存
            NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存
            FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）

        完整的 manifest 文件，如：

            CACHE MANIFEST
            # 2012-02-21 v1.0.0
            /theme.css
            /logo.gif
            /main.js

            NETWORK:
            login.asp

            FALLBACK:
            /html5/ /offline.html
        
        浏览器在首次加载 HTML 文件时，会解析 manifest 属性，并读取 manifest 文件，获取 Section：CACHE MANIFEST 下要缓存的文件列表，再对文件缓存。
        浏览器缓存文件和APPCache缓存文件是分开存的
        AppCache更新机制，浏览器在下次加载时，除了会默认使用缓存外，还会在后台检查 manifest 文件有没有修改（byte by byte)。
        有修改，就会重新获取 manifest 文件，对 Section：CACHE MANIFEST 下文件列表检查更新。manifest 文件与缓存文件的检查更新也遵守浏览器缓存机制

        AppCache 已经不推荐使用了，标准也不会再支持。

    5.Indexed Database （IndexedDB）

        不是传统的关系数据库，可归为 NoSQL 数据库。
        IndexedDB 又类似于 Dom Storage 的 key-value 的存储方式，但功能更强大，且存储空间更大。
        Key 是必需，且要唯一；Value 也是必需的，可以是任何类型的对象。
        有个非常强大的功能，就是 index（索引），可以基于索引进行 Value 对象的快速查询。

                <script type="text/javascript">

                var db;
                
                window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
                
                //浏览器是否支持IndexedDB
                if (window.indexedDB) {
                    //打开数据库，如果没有，则创建
                    var openRequest = window.indexedDB.open("people_db", 1);
                
                    //DB版本设置或升级时回调
                    openRequest.onupgradeneeded = function(e) {
                        console.log("Upgrading...");
                
                        var thisDB = e.target.result;
                        if(!thisDB.objectStoreNames.contains("people")) {
                            console.log("Create Object Store: people.");
                
                            //创建存储对象，类似于关系数据库的表
                            thisDB.createObjectStore("people", { autoIncrement:true });
                
                            //创建存储对象， 还创建索引
                            //var objectStore = thisDB.createObjectStore("people",{ autoIncrement:true });
                            // //first arg is name of index, second is the path (col);
                        //objectStore.createIndex("name","name", {unique:false});
                        //objectStore.createIndex("email","email", {unique:true});
                        }
                }
                
                //DB成功打开回调
                openRequest.onsuccess = function(e) {
                    console.log("Success!");
                
                    //保存全局的数据库对象，后面会用到
                    db = e.target.result;
                
                    //绑定按钮点击事件
                        document.querySelector("#addButton").addEventListener("click", addPerson, false);
                
                    document.querySelector("#getButton").addEventListener("click", getPerson, false);
                
                    document.querySelector("#getAllButton").addEventListener("click", getPeople, false);
                
                    document.querySelector("#getByName").addEventListener("click", getPeopleByNameIndex1, false);
                }
                
                    //DB打开失败回调
                    openRequest.onerror = function(e) {
                        console.log("Error");
                        console.dir(e);
                    }
                
                }else{
                    alert('Sorry! Your browser doesn\'t support the IndexedDB.');
                }
                
                //添加一条记录
                function addPerson(e) {
                    var name = document.querySelector("#name").value;
                    var email = document.querySelector("#email").value;
                
                    console.log("About to add "+name+"/"+email);
                
                    var transaction = db.transaction(["people"],"readwrite");
                var store = transaction.objectStore("people");
                
                    //Define a person
                    var person = {
                        name:name,
                        email:email,
                        created:new Date()
                    }
                
                    //Perform the add
                    var request = store.add(person);
                    //var request = store.put(person, 2);
                
                    request.onerror = function(e) {
                        console.log("Error",e.target.error.name);
                        //some type of error handler
                    }
                
                    request.onsuccess = function(e) {
                        console.log("Woot! Did it.");
                    }
                }
                
                //通过KEY查询记录
                function getPerson(e) {
                    var key = document.querySelector("#key").value;
                    if(key === "" || isNaN(key)) return;
                
                    var transaction = db.transaction(["people"],"readonly");
                    var store = transaction.objectStore("people");
                
                    var request = store.get(Number(key));
                
                    request.onsuccess = function(e) {
                        var result = e.target.result;
                        console.dir(result);
                        if(result) {
                            var s = "<p><h2>Key "+key+"</h2></p>";
                            for(var field in result) {
                                s+= field+"="+result[field]+"<br/>";
                            }
                            document.querySelector("#status").innerHTML = s;
                            } else {
                            document.querySelector("#status").innerHTML = "<h2>No match!</h2>";
                            }
                        }
                }
                
                //获取所有记录
                function getPeople(e) {
                
                    var s = "";
                
                        db.transaction(["people"], "readonly").objectStore("people").openCursor().onsuccess = function(e) {
                        var cursor = e.target.result;
                        if(cursor) {
                            s += "<p><h2>Key "+cursor.key+"</h2></p>";
                            for(var field in cursor.value) {
                                s+= field+"="+cursor.value[field]+"<br/>";
                            }
                            s+="</p>";
                            cursor.continue();
                            }
                            document.querySelector("#status2").innerHTML = s;
                        }
                }
                
                //通过索引查询记录
                function getPeopleByNameIndex(e)
                {
                    var name = document.querySelector("#name1").value;
                
                    var transaction = db.transaction(["people"],"readonly");
                    var store = transaction.objectStore("people");
                    var index = store.index("name");
                
                    //name is some value
                    var request = index.get(name);
                
                    request.onsuccess = function(e) {
                        var result = e.target.result;
                        if(result) {
                            var s = "<p><h2>Name "+name+"</h2><p>";
                            for(var field in result) {
                                s+= field+"="+result[field]+"<br/>";
                            }
                            s+="</p>";
                    } else {
                        document.querySelector("#status3").innerHTML = "<h2>No match!</h2>";
                        }
                    }
                }
                
                //通过索引查询记录
                function getPeopleByNameIndex1(e)
                {
                    var s = "";
                
                    var name = document.querySelector("#name1").value;
                
                    var transaction = db.transaction(["people"],"readonly");
                    var store = transaction.objectStore("people");
                    var index = store.index("name");
                
                    //name is some value
                    index.openCursor().onsuccess = function(e) {
                        var cursor = e.target.result;
                        if(cursor) {
                            s += "<p><h2>Key "+cursor.key+"</h2></p>";
                            for(var field in cursor.value) {
                                s+= field+"="+cursor.value[field]+"<br/>";
                            }
                            s+="</p>";
                            cursor.continue();
                            }
                            document.querySelector("#status3").innerHTML = s;
                        }
                }
                
                </script>
                
                <p>添加数据<br/>
                <input type="text" id="name" placeholder="Name"><br/>
                <input type="email" id="email" placeholder="Email"><br/>
                <button id="addButton">Add Data</button>
                </p>
                
                <p>根据Key查询数据<br/>
                <input type="text" id="key" placeholder="Key"><br/>
                <button id="getButton">Get Data</button>
                </p>
                <div id="status" name="status"></div>
                
                <p>获取所有数据<br/>
                <button id="getAllButton">Get EveryOne</button>
                </p>
                <div id="status2" name="status2"></div>
                
                <p>根据索引:Name查询数据<br/>
                    <input type="text" id="name1" placeholder="Name"><br/>
                    <button id="getByName">Get ByName</button>
                </p>
                <div id="status3" name="status3"></div>

    6.File System API

        H5 新加入的存储机制
        为 Web App 提供了一个虚拟的文件系统，就像 Native App 访问本地文件系统一样。

        两种类型的存储空间：临时的和持久性的。
        临时的存储空间是由浏览器自动分配的，但可能被浏览器回收；
        持久性的存储空间需要显示的申请，申请时浏览器会给用户一提示，需要用户进行确认。
        持久性的存储空间是 WebApp 自己管理，浏览器不会回收，也不会清除内容。
        持久性的存储空间大小是通过配额来管理的，首次申请时会一个初始的配额，配额用完需要再次申请。

        虚拟的文件系统是运行在沙盒中。不同 WebApp 的虚拟文件系统是互相隔离的，虚拟文件系统与本地文件系统也是互相隔离的。
                <script type="text/javascript">

                window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
                
                //请求临时文件的存储空间
                if (window.requestFileSystem) {
                        window.requestFileSystem(window.TEMPORARY, 5*1024*1024, initFS, errorHandler);
                }else{
                    alert('Sorry! Your browser doesn\'t support the FileSystem API');
                }
                
                //请求成功回调
                function initFS(fs){
                
                    //在根目录下打开log.txt文件，如果不存在就创建
                    //fs就是成功返回的文件系统对象，fs.root代表根目录
                    fs.root.getFile('log.txt', {create: true}, function(fileEntry) {
                
                    //fileEntry是返回的一个文件对象，代表打开的文件
                
                    //向文件写入指定内容
                    writeFile(fileEntry);
                
                    //将写入的内容又读出来，显示在页面上
                    readFile(fileEntry);
                
                    }, errorHandler);
                }
                
                //读取文件内容
                function readFile(fileEntry)
                {
                    console.log('readFile');
                
                    // Get a File object representing the file,
                    // then use FileReader to read its contents.
                    fileEntry.file(function(file) {
                
                        console.log('createReader');
                
                        var reader = new FileReader();
                
                        reader.onloadend = function(e) {
                
                        console.log('onloadend');
                
                        var txtArea = document.createElement('textarea');
                        txtArea.value = this.result;
                        document.body.appendChild(txtArea);
                        };
                
                        reader.readAsText(file);
                    }, errorHandler);
                }
                
                //向文件写入指定内容
                function writeFile(fileEntry)
                {
                    console.log('writeFile');
                
                    // Create a FileWriter object for our FileEntry (log.txt).
                    fileEntry.createWriter(function(fileWriter) {
                
                        console.log('createWriter');
                
                        fileWriter.onwriteend = function(e) {
                        console.log('Write completed');
                        };
                
                        fileWriter.onerror = function(e) {
                            console.log('Write failed: ' + e.toString());
                        };
                
                        // Create a new Blob and write it to log.txt.
                        var blob = new Blob(['Hello, World!'], {type: 'text/plain'});
                
                        fileWriter.write(blob);
                
                        }, errorHandler);
                }
                
                function errorHandler(err){
                    var msg = 'An error occured: ' + err;
                    console.log(msg);
                };
                
                    </script>
        
        （现在 File System API 只有 Chrome 43+、Opera 32+ 以及 Chrome for Android 46+ 这三个浏览器支持）。
        由于 Google Chrome 禁用了本地 HTML 文件中的 File System API功能，在启动 Chrome 时，要加上”—allow-file-access-from-files“命令行参数。

        Android 系统的 Webview 还不支持 File System API。
    
    7.移动端 Web 加载性能（缓存）优化

        现在 Android App（包括手 Q 和 WX）大多嵌入了 Webview 的组件（系统 Webview 或 QQ 游览器的 X5组件），通过内嵌Webview 来加载一些H5的运营活动页面或资讯页。
        对于 Web 在本地或服务器获取的数据，可以通过 Dom Storage 和 IndexedDB 进行缓存。


    优缺点：
            1.浏览器缓存：Cache-Control 和 Last-Modified 一般用在 Web 的静态资源文件上，如 JS、CSS 和一些图像文件。
              通过设置资源文件缓存属性，对提高资源文件加载速度，节省流量很有意义，特别是移动网络环境。
            2.Dom Storage：存储空间更大（相对 Cookies)，用法也比较简单，方便存储服务器或本地的一些临时数据。
              适合存储比较简单的数据，要存储结构化的数据，可能要借助 JASON，不太适合存储比较复杂或存储空间要求比较大的数据，也不适合存储静态的文件等。
            3.Web SQL Database: 优势在于能够存储结构复杂的数据，能充分利用数据库的优势，可方便对数据进行增加、删除、修改、查询。由于 SQL 语法的复杂性，
              使用起来麻烦一些。SQL Database 也不太适合做静态文件的缓存。
            4.AppCache:看起来是一种比较好的缓存方法，除了缓存静态资源文件外，也适合构建 Web 离线 App。
              但是：
                    要更新缓存的文件，需要更新包含它的 manifest 文件，那怕只加一个空格。常用的方法，是修改 manifest 文件注释中的版本号。如：# 2012-02-21 v1.0.0

                    被缓存的文件，浏览器是先使用，再通过检查 manifest 文件是否有更新来更新缓存文件。这样缓存文件可能用的不是最新的版本。
                    
                    在更新缓存过程中，如果有一个文件更新失败，则整个更新会失败。
                    
                    manifest 和引用它的HTML要在相同 HOST。
                    
                    manifest 文件中的文件列表，如果是相对路径，则是相对 manifest 文件的相对路径。
                    
                    manifest 也有可能更新出错，导致缓存文件更新失败。
                    
                    没有缓存的资源在已经缓存的 HTML 中不能加载，即使有网络。例如：http://appcache-demo.s3-website-us-east-1.amazonaws.com/without-network/
                    
                    manifest 文件本身不能被缓存，且 manifest 文件的更新使用的是浏览器缓存机制。所以 manifest 文件的 Cache-Control 缓存时间不能设置太长。
            5.IndexedDB:是一种灵活且功能强大的数据存储机制，它集合了 Dom Storage 和 Web SQL Database 的优点，
              用于存储大块或复杂结构的数据，提供更大的存储空间，使用起来也比较简单。可以作为 Web SQL Database 的替代。不太适合静态文件的缓存。
                    以key-value 的方式存取对象，可以是任何类型值或对象，包括二进制。

                    可以对对象任何属性生成索引，方便查询。
                    
                    较大的存储空间，默认推荐250MB(分 HOST)，比 Dom Storage 的5MB 要大的多。
                    
                    通过数据库的事务（tranction）机制进行数据操作，保证数据一致性。
                    
                    异步的 API 调用，避免造成等待而影响体验。
            6.file system api:
                    可以满足大块的二进制数据（ large binary blobs）存储需求。

                    可以通过预加载资源文件来提高性能。
                    
                    可以直接编辑文件。

<Q&A 92> 如何解决 304
        在要缓存的资源文件名中加上版本号或文件 MD5值字串，如 common.d5d02a02.js，common.v1.js，
        同时设置 Cache-Control:max-age=31536000，也就是一年。在一年时间内，资源文件如果本地有缓存，就会使用缓存；也就不会有304的回包。

        如果资源文件有修改，则更新文件内容，同时修改资源文件名，如 common.v2.js，html页面也会引用新的资源文件名。


        已经缓存了,那么该如何更新( 现代互联网企业,会把静态资源和动态网页分集群部署,静态资源会被部署到CDN节点上,网页中引用的资源也会变成对应的部署路径 )
        在资源内容更改后,更改动态网页中的静态资源网址,强制用户下载新的响应

        把在需要缓存的资源设置 Cache-Control:max-age= 31536000 , 正常情况是设置成一年。在一年内，使用本地缓存; 那问题来了，你不让浏览器发资源请求，这缓存怎么更新呐？
        通过更新页面中引用的资源路径( MD5 )，让浏览器主动放弃缓存，加载新资源
        至于如何替换MD5的静态资源路径 - 使用构建工具 webpack 资源修改变更过文件名
        这块属于静态资源优化

            配置超长时间的本地缓存 - 节省带宽,提高性能
            内容变更才改变对应的文件名 - 精准控制变更的缓存
            静态资源部署CDN - 优化网络请求
            更新资源发布路径 实现非覆盖式发布 - 平滑升级

<Q&A 93> 组合继承 问题

    构造继承多复制了一份超类型属性，屏蔽了原型链继承复制的那一份，浪费了内存。

    构造继承：  父类构造函数 --复制父类构造函数属性--> 子类实例
    原型链继承：父类构造函数 --复制父类实例属性--> 子类原型
        function SuperType(){this.colors=['1','2'];}
        SuperType.prototype.sayname = function(){console.log(this.colors);}
        function SubType(name){SuperType.call(this);this.name=name;}
        SubType.prototype = new SuperType();

        var instance = new SubType('z');
        var instance2 = new SubType('x');

        instance
        SubType {colors: Array(2), name: "z"}
        instance2
        SubType {colors: Array(2), name: "x"}
        
        instance.__proto__
        SuperType {colors: Array(2)}

<Q&A 94> 锚点
    锚点本质是：通过滚动显示被标记的内容
    如果不能滚动，则锚点定位失败

    1.触发锚点
    2.锚点元素通过scrollTop值改变向上偏移定位
    3.锚元素的上边缘和可滚动容器上边缘对齐

<Q&A 95> overflow:

        /* 默认值。内容不会被修剪，会呈现在元素框之外 */
        overflow: visible;
        
        /* 内容会被修剪，并且其余内容不可见 */
        overflow: hidden;
        
        /* 内容会被修剪，浏览器会显示滚动条以便查看其余内容 */
        overflow: scroll;
        
        /* 由浏览器定夺，如果内容被修剪，就会显示滚动条 */
        overflow: auto;
        
        /* 规定从父元素继承overflow属性的值 */
        overflow: inherit;

        visible
        默认值。内容不会被修剪，可以呈现在元素框之外。
        hidden
        如果需要，内容将被剪裁以适合填充框。 不提供滚动条。
        scroll
        如果需要，内容将被剪裁以适合填充框。 浏览器显示滚动条，无论是否实际剪切了任何内容。 （这可以防止滚动条在内容更改时出现或消失。）打印机仍可能打印溢出的内容。
        auto
        取决于用户代理。 如果内容适合填充框内部，则它看起来与可见内容相同，但仍会建立新的块格式化上下文。 如果内容溢出，桌面浏览器会提供滚动条。
        overlay  
        行为与auto相同，但滚动条绘制在内容之上而不是占用空间。 仅在基于WebKit（例如，Safari）和基于Blink的（例如，Chrome或Opera）浏览器中受支持。

<Q&A 96> 提交Form数据时需要serialize(),FormData会自动序列化数据  XHR对象会自动为FormData配置请求头

<Q&A 97> setTimeout setInterval

<Q&A 98> 浏览器  进程和线程

        1.Browser进程： 只有一个，负责浏览器界面的显示与交互；各个页面的管理，创建和销毁其他进程；网络的资源管理、下载等。

        2.Renderer进程: 也称为浏览器渲染进程或浏览器内核，内部是多线程的。主要负责页面渲染，脚本执行，事件处理等。

            . GUI渲染线程：负责渲染浏览器界面，解析 HTML、CSS，构建 DOM tree和 render tree，布局和绘制等。当界面需要重绘（repaint）或由于某种操作引发回流（reflow）时，该线程就会执行。
            . JS引擎线程：也称为 JS 内核；GUI 渲染线程 与 JS 引擎线程是互斥的；JS 阻塞页面加载。
            . 事件触发线程：当一个事件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎处理
            . 定时触发器线程：setTimeout 和 setInterval 所在的线程；并不是由 JS 引擎计数的；JS 是单线程的，如果处于阻塞线程状态就会影响计时的准确
            . 异步http请求线程：XMLHttpRequest 在建立连接后，通过浏览器新开一个线程请求，一旦检测到状态变更并且设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，等待 JS 引擎空闲时处理。

        3.第三方插件进程: 每种类型的插件对应一个进程，仅当使用该插件时才创建

        4.GPU进程: 最多一个，用于 3D 绘制等。

<Q&A 99> Browser进程和Renderer进程 通信

        打开浏览器的一个 tab 页时，我们看下其中的大致过程：

            . Browser 进程收到用户请求，通过网络下载获取页面内容，然后将该任务通过RendererHost接口传递给 Renderer 进程；
                
            . Renderer 进程的 Renderer 接口收到消息，简单解释后，交给 GUI 渲染线程开始渲染；
                
                    ..GUI 渲染线程接收请求，加载网页并渲染网页，这个过程中可能需要 Browser 进程获取资源和 GPU 进程来帮助渲染，也可能会有 JS 引擎线程操作 DOM（可能造成回流并重绘）；
                    ..最后 Renderer 进程将结果传递给 Browser 进程；
                
                
            . Browser 进程接收到结果，并将结果绘制出来。

<Q&A 100> 浏览器渲染流程

                                                DOM
                                                 |
                                                 V           layout
                    HTML --> HTML Parser --> DOM Tree           ^
                                                |               |
                                                V               V
                                            Attachment --> Render Tree --> Painting -->Display
                                                ^
                                                |    
            Style Sheets --> CSS Parser --> Style Tree
                             

        1.解析 HTML 文件，生成 DOM tree；同时解析 CSS 文件以及样式元素中的样式数据，生成 CSS Rules。
        2.构建 render tree：根据 DOM tree 和 CSS Rules 来构建 render tree，它可以让浏览器按照正确的顺序绘制内容。
        3.布局（layout / reflow）：计算各元素尺寸、位置。
        4.绘制（paint）：绘制页面像素信息。
        5.浏览器将各层信息发送给 GPU，GPU 将各层信息合成（composite），显示在屏幕上。

        补充：
            Webkit 将 render tree 中的元素称为 render object （或 renderer），每一个 render object 都代表一个的矩形区域，通常对应于相关节点的 CSS 框，这些矩形的排列顺序就是它们在屏幕上显示的顺序。
            Render object 和 DOM 节点是相对应的，但并非一一对应。非可视化的 DOM 元素不会插入 render tree 中，例如“head”元素 和 一些 display: none 的节点就没必要放在 render tree 中了。

<Q&A 101> html5 新特性

    1.语义化标签
            <hrader></header>  头部区域标签，块级标签
            <footer></footer>  底部区域标签，块级标签
            <nav></nav> 导航区域标签，块级标签
            <time></time> 时间区域标签，内联标签
            <article></article> 文章段落标签，块级标签
            <aside></aside> 侧边栏区域标签，块级标签
            <mark></mark> 标记记号标签，内联标签
            <summary></summary> 单词翻译: 摘要，h5官方文档描述：定义 details 元素的标题，块级标签
            <detailes></detailes> 单词翻译：细节，h5官方文档描述：定义元素的细节，块级标签
            <section></section> 单词翻译：部分，h5官方文档描述：定义 section，块级标签
        
    2.新表单类型
            <input type="email" />  e-mail 地址的输入域
            <input type="number" /> 数字输入域
            <input type="url" /> URL 地址的输入域
            <input type="range" /> range 类型显示为滑动条，默认value值是1~100的限定范围，可以通过min属性和max属性自定义范围<input type="range" name="points" min="1" max="10" />
            <input type="search" /> 用于搜索域
            <input type="color" /> 用于定义选择颜色
            <input type="tel" /> 电话号码输入域
            <input type="date" /> date类型为时间选择器
        
        html5新增属性
            placehoder 属性，简短的提示在用户输入值前会显示在输入域上。即我们常见的输入框默认提示，在用户输入后消失。
            required  属性，是一个 boolean 属性。要求填写的输入域不能为空
            pattern 属性，描述了一个正则表达式用于验证<input> 元素的值。
            min 和 max 属性，设置元素最小值与最大值。
            step 属性，为输入域规定合法的数字间隔。
            height 和 width 属性，用于 image 类型的 <input> 标签的图像高度和宽度。
            autofocus 属性，是一个 boolean 属性。规定在页面加载时，域自动地获得焦点。
            multiple 属性 ，是一个 boolean 属性。规定<input> 元素中可选择多个值。

    3.视频和音频
                <video width="600" height="400" id="video" controls="controls">
                    <source src="video/jieda2.mp4" type="audio/mp4"></source>
                </video>
                需要转换为AVC(H264)格式
        
                <audio src="audio/putclub.com_Googlewasjusta.mp3" id="audio"></audio>  支持mp3 Wav Ogg

                play() 开始播放音频/视频
                pause() 暂停当前播放的音频/视频
                load() 重新加载音频/视频元素

                controls 属性设置或返回音频/视频是否显示控件（比如播放/暂停等）
                defaultPlaybackRate 属性设置或返回音频/视频的默认播放速度
                duration 属性返回当前音频/视频的长度（以秒计）
                ended 属性返回音频/视频的播放是否已结束

    4.Canvas绘图
                是图形容器，需要使用js脚本画图
                    <canvas id="mycanvas" width="600" height="400"></canvas>

                    var myCanvas = document.getElementById('mycanvas');
                    var canvas2d =	myCanvas.getContext('2d'); //包含上下文标识符定义和绘制上下文关联到canvas上。可能的值是:"2d", 导致建立一个 CanvasRenderingContext2D 对象代表一个二维渲染上下文。

                    canvas2d.moveTo(100, 100);  // 线条起始位置
                    canvas2d.lineTo(400, 100);  // 线条结束位置
                    canvas2d.strokeStyle = '#CD5C5C'    // 线条颜色
                    canvas2d.lineWidth = 5；    // 定义线宽
                    canvas2d.font = '20px Arial'; // 定义字体大小和字体类型
                    canvas2d.fillText('Canvas绘图demo', 400, 100)   // 设置绘制的文本和位置
                    canvas2d.stroke();    //执行绘画

    5.SVG
            可伸缩矢量图形，是一种使用XML描述2D图形的语言
            SVG DOM中每个元素都是可用的，我们可以为某个元素添加js事件处理器
            被绘制的图形称为对象
            SVG属性发生变化，浏览器能够自动重现图形
            svg图形的样式和css有些不同：
                fill是定义图形填充色，
                stroke描边色，
                stroke-width是线宽

            document.getElementById()获取需要操作的svg图形节点，通过getAttribute()和setAttribute()操作SVG图形属性
    
    6.拖放（drag和drop）
        dargstart drag dragenter dragover dragleave dragend drop
        拖拽对象必须把draggable属性设置为true

    7.地理定位（获取用户位置信息）
            getCurrentPosition()

    8.离线存储
            创建cache manifest文件，创建web应用的离线版本
            如果要启用应用程序缓存，必须在文档的 <html> 标签中包含 manifest 属性：每个指定了 manifest 的页面在用户对其访问时都会被缓存。
            manifest 文件的建议的文件扩展名是：".appcache".请注意，manifest 文件需要配置正确的 MIME-type，即 "text/cache-manifest"。必须在 web 服务器上进行配置
            离线存储就是把web资源文件存储起来，移动端应用更合适，可以节省大量流量

    9.web存储
            sessionStorage（setItem、getItem、removeItem）
            localStorage（setItem、getItem、removeItem、key、clear）
            存储的数据都是字符串类型
    
    10.websocket
            在单个TCP连接上进行全双工通信的协议  ws://localhost:9988/echo
            使用特定的服务器，普通的http服务器不行  
            允许服务端主动推送数据
            只需要完成一次握手，建立永久链接
            Socket.readyState
                    0 未建立
                    1 已建立
                    2 正关闭
                    3 已关闭或打不开
            Socket.bufferedAmount
                    已由send放入队列等待传输的UTF-8文本字节数
            事件：
                Socket.onopen
                Socket.onmessage 接受数据时触发
                Socket.onerror 
                Socket.onclose 
    
    11.web workers
                
            Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。
            在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。
            这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。

            Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。
            但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。

            运行在后台的js脚本，不影响性能
            ·创建web worker文件，通过worker.postMessage()发送数据给主线程,主线程通过worker.onmessage()监听
            ·调用页面创建worker对象，var w = new Worker("worker文件路径ws://localhost:9988/echo")，然后通过实例对象调用onmessage事件进行监听，获取worker返回的数据
            ·终止web worker，创建后会持续监听，使用w.terminate() 终止
            <script>    
                w.onmessage = function(event){
                    document.getElementById("result").innerHTML=event.data;
                }
            </script>
            Worker 属于外部文件，不能获取js对象：window对象，document对象，parent对象

            HTML5 提出了 Web Worker的标准，允许 JS 脚本创建多个线程，但是子线程完全受主线程控制，而且不能对 DOM 进行操作，所以也并没有改变 JS 引擎为单线程的本质。

            worker不能访问本地文件， 只能请求网络资源，下载不到worker默认失败



<Q&A 102> 说一下http和https

    https的SSL是在传输层实现的
    1.基本概念
        http是超文本传输协议，是客户端和服务器请求和应答的标准（TCP），用于从www服务器向本地浏览器传输超文本的协议
        https是已安全为目标的http通道，是http的安全版，增加了SSL层，目标是建立安全连接，确保网站真实性
    2.区别
        http是明文传输
        https增加了SSL协议，安全性更高
        https需要ca证书，费用较高
        使用不同的链接方式，端口不同，http 80，https 443
        http链接是无状态的，https是由http协议和ssl协议构建的可加密传输和身份认证的网络协议
    3.https协议工作原理（SSL原理，区别于TLS ？）
        客户端通过https url访问服务器时，要求服务端建立SSL连接
        服务器收到请求后，会将网站证书（证书中含有公钥）返回客户端
        客户端和服务端协商SSL链接的加密等级
        客户端和服务端建立会话密钥，客户端通过服务端的公钥加密会话秘钥，发送给网站
        服务端通过私钥解密密钥
        通过密钥加密通信
    4.https优点
        通过https协议可以认证用户和服务器，能确保将消息发送给正确的客户端
        https协议是通过SSL和http协议构建的，更安全，可防止数据在传输过程中不被窃取，保证数据完整性
        https增加了中间人攻击的成本
        google2014调整搜索引擎算法，采用https的网站排名更高
    5.https缺点
        握手阶段耗时，会增加50%的页面加载时间，10-20%的耗电
        https缓存不如http高效，增加数据开销
        SSL证书要钱
        SSL证书要绑定IP，无法一个ip绑定多个域名，ipv4不够消耗

<Q&A 103> TLS 通信原理

    先TCP三次握手建立连接
    客户端发送请求建立TLS连接，（支持的TLS版本、认证算法、加密算法、数据校验算法、一串随机码）
    服务端响应请求（TLS版本、...算法、一串随机码）
    客户端请求数字证书
    服务端发送证书：
        证书1: “*.zhihu.com”，由GeoTrust RSA CA 2018签名并颁发
        证书2: “GeoTrust RSA CA 2018”，由DigiCert Global Root CA签名并颁发
    客户端验证证书：
        使用DigiCert Global Root CA的公钥解密证书2，证书2里包含GeoTrust RSA CA的明文公钥
         （DigiCert Global Root CA作为一个权威CA，已经被浏览器预先安装在可信任根证书列表，那么我们信任该CA的一切，当然包括其公钥，在该证书里包含了明文的公钥）
        解开，证明证书是由CA私钥加密的，说明证书2有效，证书1的明文公钥也是可信的
        用GeoTrust RSA CA的公钥解密证书1的签名，证书1 里有 *.zhihu.com的公钥
        客户端检查证书有效期
    客户端用 *.zhihu.com 的公钥加密一串随机码，发送给服务端
    服务端用私钥解密，得到明文字符串
    客户端和服务端用三串随机码和协商加密算法生成相同的master key，并推导出session key、HMAC key
    session key用于加密解密数据，HMAC key用于保护数据完整性

<Q&A 104> TCP UDP区别

    1.tcp是面向链接的，传输前要三次握手建立连接； udp是无连接的。
    2.tcp提供可靠服务，tcp传输数据无差错，不丢失，不重复，且按需到达；udp尽最大努力交付，不可靠
    3.tcp是面向字节流的；udp是面向报文的，网络出现拥塞不会降低发送速率
    4.tcp只能1对1 udp可以1对多
    5.tcp首部字段20字节，udp首部字段8字节
    6.TCP的应用：WEB浏览器，电子邮件，文件传输程序 ； UDP的应用：DNS，视频流，IP语音（VoIP）

<Q&A 105> websocket实现和应用
    1.是什么
        websocket是HTML5新增的协议，支持持久化链接，http1.0和1.1 都不支持持久化链接，http1.1通过keep-alive将多个请求合并成一个
    2·为什么用，好处
        http请求的周期是通过request界定的，http1.0周期就是一个request一个response，http1.1新增connect：keep-alive字段，允许一次http链接中发送多个request和response，但一个request对应一个response，但response只能被动回复
        websocket是基于http协议的，需要先通过http协议完成一部分握手，在握手阶段和http是相同的，再升级为websocket链接，需要特定的服务器支持，普通http服务器不行。（ws://localhost:9988/echo）
    3.websocket握手协议
        基本请求如下：
        GET /chat HTTP/1.1
        Host: server.example.com
        Upgrade: websocket
        Connection: Upgrade
        Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
        Sec-WebSocket-Protocol: chat, superchat
        Sec-WebSocket-Version: 13
        Origin: http://example.com
        多了下面2个属性：
        Upgrade:webSocket
        Connection:Upgrade
        告诉服务器发送的是websocket
        Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
        Sec-WebSocket-Protocol: chat, superchat
        Sec-WebSocket-Version: 13

<Q&A 106> http请求的方式 head方式

    head：类似get请求，但返回的响应中没有具体内容，获取报头
    options：允许客户端查看服务器性能，如服务器支持的请求方式

<Q&A 107> 一个图片url访问后直接下载 如何实现

    请求的返回头里，用于浏览器解析的重要参数就是OSS的API文档里面的返回http头，决定用户的下载行为的参数
    1. x-oss-object-type:
    Normal
    2. x-oss-request-id:
    598D5ED34F29D01FE2925F41
    3. x-oss-storage-class:
    Standard

<Q&A 108> 说一下web quality（无障碍）

    能够被残疾人士使用的网站称得上一个易访问的网站
    使用 alt 属性实现：
    <img src="person.jpg" alt="this is a person"/>
    浏览器有时无法显示图像：用户关闭图像；浏览器是不支持图像的mini版；语音浏览器
    使用alt属性，在无法显示图像时，浏览器可以显示或读出图像描述

<Q&A 109> 几个实用的BOM属性对象方法

    BOM是浏览器对象
        1.location对象
            location.href-- 返回或设置当前文档的URL
            location.search -- 返回URL中的查询字符串部分。例如 http://www.dreamdu.com/dreamdu.php?id=5&name=dreamdu 返回包括(?)后面的内容?id=5&name=dreamdu
            location.hash -- 返回URL#后面的内容，如果没有#，返回空
            location.host -- 返回URL中的域名部分，例如www.dreamdu.com
            location.hostname -- 返回URL中的主域名部分，例如dreamdu.com
            location.pathname -- 返回URL的域名后的部分。例如 http://www.dreamdu.com/xhtml/ 返回/xhtml/
            location.port -- 返回URL中的端口部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回8080
            location.protocol -- 返回URL中的协议部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回(//)前面的内容http:
            location.assign -- 设置当前文档的URL
            location.replace() -- 设置当前文档的URL，并且在history对象的地址列表中移除这个URL location.replace(url);
            location.reload() -- 重载当前页面

        2.history对象
            history.go() -- 前进或后退指定的页数
            history.back() -- 后退一页
            history.forward() -- 前进一页
        
        3.Navigator对象（有关浏览器信息）
            navigator.userAgent -- 返回用户代理头的字符串表示（包括浏览器版本信息等）
            navigator.cookieEnabled -- 返回浏览器是否支持cookie

<Q&A 110> 说一下html5 drag api

        dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发，。
        darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。
        dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。
        dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。
        dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。
        drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。
        dragend：事件主体是被拖放元素，在整个拖放操作结束时触发

<Q&A 111> 说一下 http 2.0

        HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），是HTTP协议的的第二个主要版本，使用于万维网。HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，
        主要基于SPDY协议（是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验）。

    https是基于ssl加密的http协议
    http2.0是基于1999年发布1.0后首次更新
    提升访问速度（请求资源所需时间更少，访问更快）
    允许多路复用：允许同时通过单一http2.0发送多重请求-响应信息，改善了http1.1中，客户端同一时间，针对同一域名的请求有一定数量限制，超过限制会被阻塞（FireFox, Chrome上限6个 ）
                http1.x里有keep-alive可以避免TCP三次握手，但是keep-alive又是串行的。所以要么并行多握手，要么串行不握手，都不是最好的结果
                HTTP/2解决了这个问题。当客户端与服务端建立连接后，就会在双方建立一个双向流通道。这个流通道，可以同时包含多个消息（http请求），不同消息各自的数据帧在流里可以乱序并行的发送，
                不会互相影响与堵塞，从而实现了一个TCP链接，并发执行N个http请求。通过提高并发，减少TCP连接开销，HTTP/2的速度得到了很大提升，尤其是在网络延迟比较高的情况下。
    二进制分帧：http2.0将所有传输信息分割为更小的信息或帧，并进行二进制编码
    首部压缩: 采用HPACK算法，能极大压缩头部数据，减少总体资源请求大小。大致的原理就是维护两本字典，一本静态字典，维护比较常见的头部名称。一本动态字典，维护不同请求的公共的头数据。
    服务器端推送(Server Push): HTTP/2的连接会建立一个双向流通道。Server Push就是在某次流中，可以返回客户端并没有主动要的数据。

    


<Q&A 112> 400 401 403

    1.400：请求无效
        前端提交数据的字段名称和字段类型和后台的实体不一致
        前端提交的数据应该是json字符串类型，但没有json.stringify转化

        对照字段名，检查一致
        序列化数据
    2.401：当前请求用户需要验证
    3.403：服务器得到请求，但拒绝执行

<Q&A 113> fetch发送两次请求

    fetch发送post请求，总是发送两次，第一次返回204，第二返回响应
    fetch发送post时，第一次发送Options请求，询问服务器是否支持修改请求头，如果支持，第二次发送真正请求

<Q&A 114> cookie、sessionStorage、localStorage区别

    共同点：都保存在浏览器，并且是同源的

    cookie：
            4KB，用于小数据，如会话标识
            在设置的过期时间前有效，即使窗口关闭 默认cookies失效时间是直到关闭浏览器
            数据始终在同源http请求中携带（即使不需要），在浏览器和服务器之间传递
            cookie还有路径限制，可以限制某cookie只属于某个路径 domain、path
            在所有同源窗口中共享
            

    sessionStorage：
                    5MB或更大
                    不能持久保存，是基于会话的缓存，仅在当前窗口关闭前有效，页面刷新后仍可用
                    不会主动把数据发给服务器，仅在本地保存
                    是Storage的一个实例
                    不同页面或标签页间不能共享，即使同一页面多次打开，只能由最初给对象存储数据的页面访问。
                    标签页中包含的多个同源iframe间可以共享
                    
    localStorage：
                    5MB或更大
                    周期是永久（不清除的话），用于持久数据
                    不会主动把数据发给服务器，仅在本地保存
                    是Storage的一个实例
                    相同浏览器同源窗口中都是共享的

    web Storage支持事件通知机制，api接口更方便

    cookie：
            保存用户登录状态（免登录）
            跟踪用户行为（显示用户所在地的天气）

<Q&A 115> 说一下 web worker 和 ShareWorker

    在HTML页面中 执行脚本时，页面是不可响应的，web worker试运行在后台的js脚本，独立于其它脚本，不影响页面性能，通过postMessage将结果传给主线程

    创建：
         检测浏览器是否支持web worker
         创建web worker文件（js、回调函数）
         创建web worker对象

    主线程通过 postMessage 向worker传递信息，子线程通过 onmessage捕获，接受 MessageEvent 对象
    通过onmessage监听父线程传递进来的消息，如果消息内容是'start'就执行计算，计算完成之后我们再次通过postMessage把结果传递回去，
    在主线程中我们需要通过指定worker来调用postMessage (worker.postMessage)，而在子线程中我们则不需要指定worker，直接调用postMessage方法就可以了。
    主线程中，也可以通过worker.onmessage监听子线程传递过来的数据。

    button.addEventListener('click', function () {
        // 向worker传递消息
        worker.postMessage('start');
    });

    // workers.js
    onmessage = function (messageEvent) {
        switch (messageEvent.data) {
            case 'start':
                let result = fabonacci(42);
                postMessage(result);
        }
    }
    
    终止的worker，可以直接调用terminate方法：

    var myWorker = new Worker('worker.js');
    myWorker.terminate();

    ShareWorker
        shareWorkder会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个进程，当所有的页面都关闭之后该线程也会随之被结束。
        
        new SharedWorker(aURL, name);
        其中aURL是脚本的地址，name是子线程的名称，相同名字的线程会被共享（但必须符合同源策略）

        // 传递strat指令
        worker.port.postMessage('start');
        // 接收子线程的数据
        worker.port.onmessage = function (val) {
            timeDom.innerHTML = val.data
        }

        通过addEventListener绑定message事件的话（而不是.onmessage）这时候需要手动的调用 port 的 .start()方法。

        worker.port.start();
        worker.port.addEventListener('message', function(e) {
            // ... 
        });

        同样的在子线程中我们的使用也有些小的区别，我们可以通过对onconnect事件获取到新的shareWorker的连接，
        然后在connect的参数中的ports字段我们可以拿到MessageEvent，这时候我们就可以使用 .onmessage 和 .postMessage 来处理和传递我们的数据了。

        // sharedworkers.js
        onconnect = function (e) {
            // 通过 e.ports 拿到 port
            var port = e.ports[0];

            // port.onmessage 监听父线程的消息
            port.onmessage = function () {
                // port.postMessage 向父线程传递消息
                port.postMessage(a++)
            }
        }
        下面我们来完整的分析一下我们的 sharedworkders.js 的内容，在进程启动的时候，我们会通过var a = 1;创建一个变量，
        然后在每次的父线程发来消息的时候就会把a加上一，这样就能实现所有的页面共享同一个变量a。

        sharedworkders是后台线程在chrome浏览器中我们可以通过chrome://inspect/来很方便的调试shareWorker

<Q&A 116> 对html语义化标签的理解

        html5语义化标签是指正确的标签包含正确的内容，结构良好，便于阅读， 如nav表示导航条 article、header、footer

<Q&A 117> iframe是什么？ 缺点

        iframe元素会创建包含另一个文档的内联框架
        可以将提示文字放在<iframe></iframe>之间，提示不支持的浏览器

    缺点：
         阻塞主页面onload事件
         搜索引擎无法解读这种页面，不利于SEO
         iframe和主页面共享连接池，而浏览器对相同区域有限制，所以会影响性能

<Q&A 118> Doctype作用？ 如何区分严格模式和混杂模式，
    
    Doctype声明于文档最前面，告诉浏览器以何种模式渲染页面，分严格模式和混杂模式
    严格模式的排版和JS运行按浏览器支持的最高标准
    混杂模式，向后兼容，模拟老式浏览器，兼容

<Q&A 119> cookie如何防范xss攻击

    XSS（跨站脚本攻击）是指攻击者在html中插入js脚本，从cookie中获取用户信息
    需要在http头部添加 set-cookie：字段
    httponly 属性 禁止js脚本访问cookie
    secure 属性 告诉浏览器仅在http请求时发送cookie

<Q&A 120> cookie和session 区别

    http是无状态协议，因此cookie最大作用是存储sessionId唯一标识用户

<Q&A 121> 一句话概括RESTFUL

    就是用URL定位资源，用http描述操作

<Q&A 122> 讲讲viewport和移动端布局

    
<Q&A 123> click在ios上有300ms延迟，原因 解决

    2007年apple发布iPhone时，当时网站都是为大屏屏幕设备设计的，工程师做了部分约定，双击缩放 是300ms延迟的主要原因。
    ios Safari浏览器需要预留300ms来检测用户是否再次点击了屏幕，以判断用户操作是双击缩放还是click

    1.禁用缩放，更改默认视口宽度
        <meta name="viewport" content="width=device-width, user-scalable=no">
    2.利用FastClick
        检测到touchend事件，立刻触发模拟click事件，并阻止浏览器300ms之后真正触发的事件

<Q&A 124> addEventListener参数

    addEventListener(event, function, useCapture)
    event指定事件名
    function指定事件触发时执行的函数
    useCapture指定事件是否在捕获或冒泡阶段执行 默认false 在冒泡阶段执行

    对于事件目标上的事件监听器来说，事件处于“目标阶段”，既不是冒泡也不是捕获阶段，监听器不在乎参数是 true和是false

<Q&A 125> offsetleft

    offsetLeft值跟offsetTop值的获取跟父级元素没关系，而是跟其上一级的定位元素(除position:static;外的所有定位如fixed,relative,absolute)有关系。

<Q&A 126> cookie session 区别

    1.cookie数组在浏览器，session数据在服务器的文件或数据库中
    2.cookie保存在本地，没有session安全
    3.session访问增多可能会影响服务器性能
    4.cookie 4KB，很多浏览器限制一个站点最多保存20个cookie

<Q&A 127> session

    1.是什么
            http协议是无状态的，服务端不会保存用户的状态信息
            session就是为了让服务端了解当前访问用户的信息的方案，通过cookie可以为每次会话标记唯一的id，在下一次请求中，用户会携带该cookie值，服务端就可以分辨用户身份，
            服务端会将用户的信息存储起来（在php中，ID为abc的用户信息会存在/tmp/phpsess_abc[1] 文件里，存取需要序列化数据），之后请求就可以利用会话id获取保存的session数据
    2.存在哪里
            不是内存，而是服务器上的文件或数据库里

<Q&A 128> iframe通信

            同源：
                根据父页面
                cookie
            不同源：
                    设置子域

<Q&A 129> http状态码

    响应分为五类：信息响应，成功响应，重定向，客户端错误和服务器错误。

    100 continue 客户端继续其请求
    101 switching protocols 切换协议
    200 ok 请求成功 一般用于get和post请求
    201 created 已创建 成功请求并创建了新的资源
    202 accepted 已接受 但未处理完
    203 non-authoritative information 非授权信息 返回的meta信息不在原始服务器，而是副本
    204 no content 无内容
    205 reset content 重置内容 用户端重置文档视图 可以用来清除浏览器表单域 该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。
    206 partial content 部分内容 成功处理部分get请求
    300 multiple choices 多种选择 请求的资源包括多个位置，返回资源特征和地址的列表供客户端选择
    301 moved permanently 永久移动
    302 found 临时移动
    303 see other 查看其它地址 get和post请求
    304 not modified 资源未更新  通知客户端可以继续使用缓存
    305 use proxy 使用代理 所有请求必须通过代理访问
    306 unused 已被废弃的状态码
    307 temporary redirect 临时重定向 使用get请求重定向
    400 bad request 客户端请求的语法错误 服务端无法理解
    401 unauthorized 请求要求用户的身份认证
    402 payment required 保留的状态码
    403 forbidden 拒绝执行请求
    404 not found 找不到资源
    405 method not allowed 客户端请求中的方法被禁止
    406 not accepted 服务器无法根据请求的内容特性完成请求
    407 proxy authentication required 请求要求代理的身份认证
    408 request time-out 请求发送时间超时
    409 conflict put 请求时可能返回 服务器处理请求时发生冲突
    410 gone 请求的资源已经不存在 不同于404 如果以前有资源 现在被删除，可以用410，再用301重定向
    411 length required 服务器无法处理客户端发送的不带content-length的请求
    412 precondition failed 客户端请求信息的先决条件错误
    413 request entity too large 请求的实体过大 为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息
    414 request-URI too large 请求的URI过长
    415 Unsupported media type 无法处理请求附带的媒体格式
    416 request range not satisfiable 请求的范围无效
    417 expectation failed 无法满足expect的请求头信息
    500 internal server error 服务器内部错误 无法完成请求
    501 not implemented 服务器不支持请求的功能
    502 bad gateway 网关错误  网关或代理执行请求时，收到无效响应
    503 service unavailable 服务器暂时无法处理请求  延时的长度可包含在服务器的retry-after头信息中
    504 gateway time-out 网关或代理未及时获取请求
    505 http version not supported 不支持请求的http协议版本

<Q&A 130> http请求头
        accept            可接受的响应类型（content-types）
        accept-charset    可接受的字符集
        accept-encoding   可接受的响应内容的编码方式
        accept-language   可接受的响应内容语言列表
        accept-datetime   可接受的按照时间来表示的响应内容版本
        authorization     需要认证资源的认证信息
        cache-control     指定请求/回复中，是否使用缓存机制
        connection        优先使用的链接类型
        cookie            由之前服务器通过set-cookie设置的http协议cookie
        content-length    以8进制表示的请求体的长度
        content-MD5       请求体的内容的二进制MD5散列值，以base64编码
        content-type      请求体的MIME类型（用于post和put请求）
        date              发送该消息的日期和时间（http日期格式
        expect            客户端要求服务器做出特定的行为
        from              发起请求的用户的邮件地址
        host              服务器域名以及监听的端口号
        if-match          客户端提供的实体和服务器上的对应实体匹配时才进行对应操作，用于put方法
        if-modified-since 在对应资源未修改时返回304 ，对应请求中的 last-modified字段
        if-non-match      在对应资源未修改时返回304 ，对应请求中的etag字段
        if-range          如果实体未修改过，返回缺少的那一个或多个部分，否则返回整个新实体
        if-unmodified-since  仅当该实体自某个特定时间以来未修改，才发送
        max-forwards      限制该消息可被代理及网关转发的次数
        origin            发起针对跨域资源共享的请求（该请求要求服务器在响应中加入access-control-allow-origin的消息头，表示访问控制所允许的来源）
        pragma            在请求/响应中任何时候产生
        proxy-authorization  用于向代理认证的认证信息
        range             表示请求某个实体的一部分，字节偏移以0开始
        referer           表示浏览器访问的前一个页面，可以认为是之前访问的页面的链接将浏览器带到了当前页面
        TE                浏览器预期接受的传输时的编码方式：可使用回应协议头transfer-encoding中的值（还可以使用trailers表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接到一些额外的字段
        user-agent        浏览器的身份标识字符串
        upgrade           要求服务器升级到高版本协议
        via               告诉服务器这个请求是由哪些代理发出的
        warning           一般性警告，表示在实体内容中可能存在错误
        
<Q&A 131> 强、协商缓存

            缓存分为强缓存 协商缓存  根据响应的header内容决定

            强缓存       从缓存取       200        直接从缓存取
            协商缓存     从缓存取       304        由服务器告知浏览器缓存仍旧可用

            强缓存字段：expires  cache-control  后者优先级更高    如果当前时间都没有超过设置的缓存过期时间（expires、cache-control：max-age=20000）直接从缓存拿数据，不用请求服务器
            协商缓存字段：last-modified/if-modified-since  etag/if-non-match  etag优先级高于last-modified，单位了兼容http1.0 一般同时使用
                        如果expires和cache-control都过期，向服务器请求，
                        请求中添加if-modified-since和if-non-match字段（分别携带last-modified和etag的值，这些值都是服务器给的），服务器比较自己和请求的中的两个值，
                        如果相同 资源没更新，返回304  响应中设置新的expires和max-age值  告诉浏览器缓存依旧可用 以及新的过期时限
                        不同，资源更新， 返回200和新的数据 并通知浏览器或cdn缓存  响应中包含新的 expires cache-control last-modified etag

<Q&A 132> 讲讲 304

            如果客户端发送了一个带条件的get请求，且该请求已被允许  而资源（自上次访问或依据请求条件）并没有改变，服务器返回304  通知浏览器，当前缓存依旧可用

<Q&A 133> 前端优化

            降低请求量：合并资源，减少http请求数，minify/gzip压缩，webP，lazyLoad
            加快请求速度：预解析DNS，减少域名数，并行加载，CDN分发
            缓存：http协议缓存请求，离线缓存manifest，离线数据缓存localStorage
            渲染： JS/CSS优化， 加载顺序， 服务端渲染，pipeline

<Q&A 134> 不需要缓存的场景

            缓存是为了提升访问速度，节省带宽，减轻服务器压力，图片 css js资源文件一般需要缓存 
            但像接口数据等数据变动的http请求都是不缓存的

        场景：
            1.HTML文件不需要强缓存，协商缓存即可
                html可以返回304 但不要返回 200（from memory cache） 最好设置过期时间为0 强制跟服务器对比
                js和css文件可以使用版本做控制或随机数

            2.js代码版本迭代更新时不能缓存
                需要进行js类库版本控制 
                <script src="../js/jquery.js?version=1.8.9"></script>
                升级到2.0.0
                <script src="../js/jquery.js?version=2.0.0"></script>

                缓存是根据url处理的，只要url不同，就是新资源

            3.前后端使用ajax请求接口数据
        
        解决：
            1.url中添加随机数（前端做处理）
            2.请求头添加cache-control：no-cache 浏览器和服务器都不能缓资源 并不绝对 其实可以缓存 只是在请求资源时 需要跟服务器确认资源是否更改过 （no-store 请求/响应的信息不能缓存在浏览器和服务器中  绝对禁止缓存）
                为兼容http1.0  还需添加program：no-cache

<Q&A 135> 使浏览器不缓存资源

            1.cache-control：no-cache，no-store，must-revalidate
            2.给请求的资源增加版本号
                <link rel="stylesheet" type="text/css" href="../css/style.css?version=1.8.9"/>
            3.html禁用缓存
                <meta http-equiv="cache-control" content="no-cache,no-store,must-revalidate"/>

<Q&A 136> 301和302 区别

        301 Moved Permanently 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。
        302 Found 请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。
        
        字面上的区别就是301是永久重定向，而302是临时重定向。
        
        301比较常用的场景是使用域名跳转。
        302用来做临时跳转 比如未登陆的用户访问用户中心重定向到登录页面。

<Q&A 137> http支持的方法

            get、post、head（只请求页面的首部）、options（允许客户端查看服务器性能）、put、delete、trace、connect

<Q&A 138> 画三角形

            边框均分
            div{
                width:0px;
                height:0px;
                border-top:10px solid red;
                border-right:10px solid transparent;
                border-bottom:10px solid transparent;
                border-left:10px solid transparent;
            }

<Q&A 139> html5新增元素

            header、footer、nav、aside、section、
            表单中，为input增加了color、email、data、range等类型
            存储，提供了sessionStorage、localStorage和离线存储
            媒体，audio和video
            新增地理定位、Canvas画布、拖放、多线程编程的web worker和websocket协议

<Q&A 140> 在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？

        输入url后，首先需要找到这个url域名的服务器ip,为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存，
        缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，
        主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器，服务器解析这个请求来作出响应，返回相应的html给浏览器，
        因为html是一个树形结构，浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码，这会造成阻塞，
        这就是为什么推荐JS代码应该放在html代码的后面，之后根据外部样式，内部样式，内联样式构建一个CSS对象模型树CSSOM树，构建完成后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，
        比如script，meta标签和排除display为none的节点，之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，
        遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 
        Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用Cache-Control，在请求这些有设置了缓存的数据时，
        会先 查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了ETag值会在这次请求的时候作为If-None-Match的值交给服务器校验，
        如果一致，继续校验 Last-Modified，没有设置ETag则直接验证Last-Modified，再决定是否返回304

<Q&A 141> 

        从安全性来说，因为每次http请求都回携带cookie信息，这样子浪费了带宽，所以cookie应该尽可能的少用，此外cookie还需要指定作用域，不可以跨域调用，限制很多，但是用户识别用户登陆来说，
        cookie还是比storage好用，其他情况下可以用storage，localstorage可以用来在页面传递参数，sessionstorage可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数，
    
<Q&A 142> 常见的http首部

        可以将http首部分为通用首部，请求首部，响应首部，实体首部

        通用首部表示一些通用信息，比如date表示报文创建时间，
        
        请求首部就是请求报文中独有的，如cookie，和缓存相关的如if-Modified-Since
        
        响应首部就是响应报文中独有的，如set-cookie，和重定向相关的location，
        
        实体首部用来描述实体部分，如allow用来描述可执行的请求方法，content-type描述主题类型，content-Encoding描述主体的编码方式

<Q&A 143> http2.0 特性

            1.内容更安全，http2.0 基于https
            2.二进制格式，http1.x解析是基于文本的，http2.0 将传输信息分割为更小的消息和帧，并进行二进制编码
            3.多路复用，增强长连接，request可以随机混合，接收方可以根据request.id 将请求分类到各自请求端，多路复用支持流的优先级，浏览器可以告诉服务器哪些资源优先级更高

<Q&A 144> cache-control 值

            cache-control是通用消息头字段，在请求和响应中实现缓存机制，缓存指令是单向的，
            private、no-cache、max-age、must-revalidate，默认为private（表示该响应专用于某个用户，中间人不能缓存，只能用于浏览器私有缓存中）

<Q&A 145> 浏览器在生成页面的时候，会生成那两颗树？

            DOM树和CSSOM规则树
            浏览器解析服务器返回的HTML文档，遍历文档节点，生成DOM树
            浏览器解析css文件，生成CSSOM规则树

            最后根据DOM和CSSOM树生 成 render树，指导浏览器绘制内容

<Q&A 146> 谈一下 js面向对象和继承

            JavaScript每天有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承  --《JavaScript设计模式与开发实践》

            js的面向对象是基于原型克隆的方式创建对象的，并以原型链的方式实现对象之间的关系

            js基于原型编程语言的基本规则：
                1.所有数据都是对象
                2.要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它
                3.对象会记住它的原型
                4.如果对象无法响应请求，会委托给其原型
            
            原型链继承：可继承父类私有属性和原型上的属性和方法，但是，父类私有属性的继承是引用同一内存地址，修改属性会影响到其他对象
            构造函数继承：可继承父类的私有属性和方法，但不会继承父类原型的属性和方法， 对象间修改属性不会相互影响
            组合继承：可继承父类私有属性和方法，并且为子类私有，可继承父类原型属性，可传参，可复用，但是调用了两次父类方法，性能有损耗
            原型式继承：类似于函数闭包的用法，语义上不够明显
            寄生式继承
            寄生组合式继承：1、函数的原型等于另一个实例。2、在函数中用apply或者call引入另一个构造函数。继承方式太过复杂。
            es6继承：使用extends关键字实现继承，语法上更加清晰明了，子类继承父类后，子类的构造函数，必须执行super方法
                class Animals {
                    constructor(type, name) {
                        this.type = type;
                        this.name = name;
                    }			
                    eat() {
                        console.log('这是一只小'+ this.type + '： 它会吃东西');
                    }
                }
                        
                let animal = new Animals('狗', '旺财');
                    
                class Car extends Animals {
                    constructor(sex) {
                        super('猫', '小花');   
                        // 此处是重点在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则
                        // 会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例
                        this.sex = sex;
                    }
                }			
                let car = new Car('公');
                car.eat();
            
            

<Q&A 147> es5和es6 创建类时 都需要使用 关键字 new

            1.创建对象obj
            2.将obj的内置属性__proto__指向父类的prototype
            3.将父类的this执行obj
            4.返回对象obj，即是新建的实例
        
        红宝书：
            1.创建对象obj
            2.将构造函数的作用域赋给obj，即将this指向obj
            3.执行构造函数中的代码，为obj添加属性
            4.返回obj

<Q&A 148> js 事件

            三类：一般事件 表单事件 页面事件

            UI事件
            鼠标和滚轮事件
            滚轮事件
            焦点事件
            文本事件
            键盘事件
            合成事件 DOM3新增
            变动事件
            变动名称事件

            hetml5 新增： HTML5事件 设备事件 触摸事件 手势事件 

            事件流：
                
                addEventListener：chrome   最后一个参数 true/捕获 false/冒泡 默认冒泡
                attachEvent： IE Opera

                IE和Opera 不支持事件捕获 

                阻止冒泡
                event.stopPropagation()
                event.preventDefault()

            浏览器内核：

            js事件绑定：

                1.html事件处理程序
                    <input type="button" onclick="alert('我是事件绑定方式一：HTML事件处理程序，我是内嵌在HTML结构中的');" value="事件绑定方式一【内嵌】" />

                    或	<input type="button" onclick="mupiaoFn()" value="事件绑定方式一【调用】" />

                    function mupiaoFn(){
                        alert("我是事件绑定方式一：HTML事件处理程序");
                    }

                2.DOM0
                    就是把一个函数/方法赋给一个事件处理程的 属性如：id 、class 、元素名等 【用得最多，兼容性好，简单，灵活，跨浏览器 ；缺点：不能绑定多个同类型事件】

                        <input type="button" name="eventBtn2" id="eventBtn2" value="事件绑定方式二【通用属性绑定】" />

                        /*------事件绑定方式二：DOM 0级事件处理程序------*/
                        var Btn2 = document.getElementById("eventBtn2");//给谁绑定事件，就要先获取谁

                        //绑定事件1:【赋给方式】
                        Btn2.onclick = function(){
                        alert("我是事件绑定方式二：DOM 0级事件处理程序");
                        }

                        或
                        //绑定事件2：【调用方式】
                        function publick(){
                        alert("我也是事件绑定方式二：DOM 0级事件处理程序");
                        }
                        Btn2.onclick = publick; //注：publick后面不要加()括号，否则会变为立即执行函数！

                        //删除事件：
                        Btn2.onclick = null;	

                        注：当我们希望给同一个元素/标签绑定多个同类型事件的时候（如，为上面的按扭标签绑定2个或是个以上的点击事件），是不被允许的。

                3.DOM2

                    addEventListener/removeEventListener: IE9+、FireFox、Safari、Chrome Opera
                    attachEvent/detachEvent(只支持冒泡)：IE8- 

                        var Btn3 = document.getElementById("eventBtn3");//给谁绑定事件，就要先获取谁

                        //添加监听事件1：【内嵌方式】
                        Btn3.addEventListener('click' , function(){alert("我是事件绑定方式二：DOM 2级事件处理程序");} , false) //false:冒泡，true:捕获

                        //添加监听事件2：【调用方式】
                        Btn3.addEventListener('click' , addevFn , false);
                        function addevFn(){	
                            alert("我是事件绑定方式二：DOM 2级事件处理程序 【调用方式】");
                        }

                        //添加不同的监听事件：鼠标移入事件【调用方式】
                        Btn3.addEventListener('mouseover' , addevFn2 , false);
                        function addevFn2(){
                            alert(this.value);
                        }

                        //*删除监听事件【注：删除时事件类型名、事件函数名要一一对应哦（就是和添加事件时的参数一样）】
                        Btn3.removeEventListener("mouseover" , addevFn2, false)
                
            事件委托：
                    当时一个页面事件处理程序比较多的时候使用，利用事件冒泡，只指定一个事件处理程序，就可以管理一个类型的所有事件。
                    给元素的父级或者祖级，甚至页面绑定事件，然后利用事件冒泡的基本原理，通过事件目标对象进行检测，然后执行相关操作。

                    好处：  
                        1.大大减少了事件处理程序的数量和设置事件处理程序的时间（所需要的查找操作以及DOM引用也就更少了）。
                        2.将事件委托到document上（注：上面的例子没有绑定在document上，而是绑定到了父级的div上，最为推荐的是绑定在document上），对象可以很快的访问到，而且可以在页面生命周期的任何时点上为它添加事件处理程序，
                          并不需要等待DOMContentLoaded或者load事件。换句话说，只要可单击的元素在页面中呈现出来了，那么它就立刻具备了相应的功能。
                        3.整个页面占用的内存空间会更少，从而提升了整体的性能。
                   
            事件移除：

                    每当将一个事件处理程序指定给一个元素时，在运行中的浏览器代码与支持页面交互的JavaScript代码之间就会建立一个连接。连接数量也直接影响着页面的执行速度。
                    所以，当内存中存在着过时的“空事件处理程序”的时候，就会造成Web应用程序的内存和性能问题。

                    文档中元素存在事件，通过一些DOM节点操作（removeChild、replaceChild等方法），移除了这个元素，但是DOM节点的事件没有被移除。innerHTML去替换页面中的某一部分，
                    页面中原来的部分存在事件，没有移除。页面卸载引起的事件处理程序在内存中的滞留。

                    解决方法：
                    
                        合理利用事件委托；
                        在执行相关操作的时候，先移除掉事件，再移除DOM节点；
                        在页面卸载之前，先通过onunload事件移除掉所有事件处理程序。

<Q&A 149> csrf和xss的网络攻击及防范

        CSRF：跨站请求伪造  攻击这盗用用户的身份，以用户的名义发送恶意请求。 专业术语来说就是在受害者访问一个网站时，其 Cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，
        防御：使用验证码、检查https头部的refer、使用token

        XSS：跨站脚本攻击   攻击者通过注入恶意脚本，在用户浏览网页的时候进行攻击，比如获取cookie。发生在目标用户的浏览器层面上，当渲染DOM树的过程发生不在预期内执行的js代码，
            攻击可分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型并不存储在数据库中，往往表现为将代码放在url地址的请求参数中
        防御：为cookie设置HTTPOnly属性，对用户的输入进行检查，进行特殊字符过滤

<Q&A 150> 衡量网站的性能

        检测页面加载时间一般有两种方式
        被动检测：在页面置入脚本或探针，当用户访问时，探针自动采集数据并传回数据库进行分析
        主动检测：搭建分布式受控环境，模拟用户发起页面访问请求，主动采集性能数据并分析，专业的第三方工具效果更能好，如性能极客

<Q&A 151> 介绍http协议（特征）

        http是基于TCP/IP通信协议来传递数据（html文件、图片、查询结果），属于应用层面向对象的协议，简捷、快速，适用于分布式超媒体信息系统。
        工作在客户端-服务端架构上，浏览器作为http客户端通过url向http服务器即web服务器发送所有请求。

<Q&A 152> 输入url到页面加载显示完成发生了什么

        DNS解析 - TCP链接 - 发送http请求 - 服务器处理请求并返回http报文 - 浏览器解析渲染页面 - 链接结束

<Q&A 153> 说一下cookie和session  cookie的限制

        1.cookie放在客户端，session放在服务器（一般不在内存，文件或数据库）
        2.cookie并不安全，可能会泄露
        3.session存在服务器上，如果数量过多可能会影响服务器性能

        单个cookie大小不能超过4k，浏览器会限制同一个站点下的cookie数量，一般最多20个

<Q&A 154> 具体有哪些请求头是跟缓存相关的

        根据响应头内容决定是那种缓存
        强缓存：expires cache-control：max-age=223322
        协商缓存：etag/if-none-match last-modified/if-modified-since

<Q&A 155> cookie有哪些字段可以设置

        name、value、domain(cookie域名)、path(访问此cookie的页面路径)、expires/cache-control：max-age=12423(cookie超时时间，不设置的话，默认与session一同失效：当浏览器关闭时)、
        size、httpOnly（true：只能在http请求头中携带此cookie，document.cookie无法查看）、secure（是否通过https传递cookie）

        当前域名为非顶级域名，domain只能设置为顶级域名或者当前域名，不能设置其他二级域名的cookie
        当前域名为顶级域名，domain只能设置为当前顶级域名，且只能获取到domain设置为当前顶级域名的cookie
        当前域名为二级域名，可以读取domain设置为顶级域名或当前二级域名的cookie
        想要cookie在多个二级域名中共享，需要设置domain为顶级域名
        
<Q&A 156> cookie编码方式

        encodeURI()

<Q&A 157> 看过图解http？ 解释下200 304 区别

        200 OK 请求成功 get/post
        304 Not Modified 未修改  协商缓存时，服务器比较自己存储的etag、last-modified和请求头中携带的值，如果相同，
        说明此时、当前的请求条件下 资源没有更新，服务器会返回304状态码和新的expires/max-age值给浏览器，但不返回任何资源，告诉浏览器资源未更新，缓存依旧可用

<Q&A 158> ajax 兼容

        function getXHR() {
            var xhr = null;
            if(window.XMLHttpRequest) {
              xhr = new XMLHttpRequest();
            } else if (window.ActiveXobject) {
              try {
                xhr = new ActiveXobject("MSxml2.XMLHTTP");
              } catch (e) {
                try {
                  xhr = new ActiveXobject("Microsoft.XMLHTTP");
                } catch (error) {
                    console.log("Your browser not support ajax");
                }
              }
            }
            return xhr;
          }

<Q&A 159> JS 事件循环 event loop

          见 195
        
<Q&A 160> Promise

        概念： 一种容器，包含之后需要进行的操作(异步)，
        特点：
             1.只有三种状态： Pending、Fulfilled、Rejected
             2.Promise对象的状态不收外界影响，只能由异步结果决定，无法通过其他操作影响，状态一旦发生变化则之后无法修改，状态确定后称为Resolved
             3.状态只能由Pending -> Fulfilled 或 Pending -> Rejected
             4.错过，则无法再监听
             5.一旦创建，则立即执行，无法中途取消
             6.如果不设置回调函数，Promise内部错误不会反应到外部
        
        创建实例
            <script>
                var Promise = new Promise(function(resolve, reject){
                    //...
                    if(异步成功) {
                        resolve(value); // 修改Promise状态 Pending -> Fulfilled， 并将异步操作的结果作为参数传递出去
                    } else {
                        reject(error);  // 修改Promise状态 Pending -> Rejected， 并将异步操作的报错作为参数传递出去
                    }
                });
            </script>

        生成Promise实例后，then方法可以指定Fulfilled和Rejected的回调，两个回调函数都接受Promise传出的值作为参数
            <script>
                Promise.then(function(value){
                    // success
                }, function(error){
                    // failure
                });
            </script>
            
        Promise状态改变就会触发then绑定的回调
            <script>
                function timeout(ms) {
                    return new Promise( (resolve, reject) => {
                        setTime(resolve, ms, 'done');
                    });
                }
                timeout(100).then( (value) => {
                    console.log(value);
                });
            </script>

        Promise创建后就会立即执行
            <script>
                let Promise = new Promise(function(resolve,reject) {
                    console.log('Promise');
                    resolve();
                });

                Promise.then(function(){
                    consoloe.log('Resolved');
                });

                console.log('Hi');

                //Promise
                //Hi
                //Resolved
            </script>

        异步加载图片
            <script>
                function loadImageAsync(url) {
                    return new Promise(function(resolve, reject) {
                        let image = new Image();
                        image.onload = function() {
                            resolve(image);
                        }
                        image.onerror = function() {
                            reject(new Error('Could load the image at' + url));
                        }
                        image.src = url;
                    });
                }
            </script>

        Promise实现ajax
            <script>
                var getJson = function(url) {
                    var promise = new Promise(function(resolve, reject) {
                        var client = new XMLHttpRequest();
                        client.open('GET',url);
                        client.onreadystatechange = handler;
                        client.responseType = 'json';
                        client.setRquestHeader('Accept', 'application/json');
                        client.send();

                        function handler() {
                            if(readyState !== 4) {
                                return;
                            }
                            if(status == 200) {
                                resolve(this.response);
                            } else {
                                reject(new Error(this.statusText));
                            }
                        }
                    });
                    return promise;
                };

                getJson('/posts.json').then(function(json) {
                    console.log('Content:' + json);
                }, function(error) {
                    console.error('出错了' + error);
                });
            </script>
        
        resolve参数可以是另一个Promise（异步操作返回另一个异步操作）
            <script>
                var p1 = new Promise(function (resolve, reject) {
                    setTimeout(()=>reject(new Error('p1 fail')),3000);
                });
                ​
                var p2 = new Promise(function(resolve, reject){
                    setTimeout(()=>resolve(p1),1000);
                });
                ​
                p2.then(result=>console.log(result)).catch(error=>console.log(error));

                // Error: p1 fail
            </script>
            p2的状态在1秒后改变，resolve返回p1，p2返回的是另一个Promise，导致p2状态无效，由p1的状态决定p2，后面的then语句都变成针对p1，再过两秒，p1变成rejected，触发catch

            调用resolve和reject不会终止Promise参数函数执行，还可以继续执行之后的语句（一般后续语句放在then里，resolve、reject前加return，）

        Promise.prototype.then
                为Promise实例添加状态改变时的回调函数
                第一个参数是Fulfilled状态的回调
                第二个是rejected的回调
                方法返回的是另一个Promise，可以采用链式写法

                getJSON("/post/1.json").then(function(post) {
                    return getJSON(post.commentURL);
                }).then(function funcA(comments) {
                        console.log("Resolved: ", comments);
                    }, function funcB(err){
                        console.log("Rejected: ", err);
                    });
                后面的then取决于前面返回的Promise实例状态

        Promise.prototype.catch
                .catch是.then(null, rejection)的别名，指定错误时的回调
                返回的也是一个Promise实例
                
                p.then((val)=>console.log('fulfilled:',val)).catch((error)=>console.log('rejected:',error)); // p状态fulfilled回调then，rejected回调catch
                等价于
                p.then((val)=>console.log('fulfilled:',val)).then(null,(error)=>console.log('rejected:',error)); // p状态变成rejected，第一个then没有指定失败的回调所以返回一个rejected状态的Promise实例，执行第二个then的回调
                
                then指定的回调函数出错也会被catch捕获
                    <script>
                        var promise = new Promise(function(resolve, reject) {
                            try {
                                throw new Error('test');
                            } catch(e) {
                                reject(e);
                            }
                        });

                        promise.catch(function(error) {
                            console.log(error);
                        });
                        等价于
                        var promise = new Promise(function(resolve, reject) {
                            reject(new Error('test'));
                        });

                        promise.catch(function(error) {
                            console.log(error);
                        });
                    </script>

                reject作用等同于抛错
                Promise的错误类似冒泡，一直向后传递，总会被下一个catch捕获
                一般不要定义rejected状态的回调，而是使用catch方法,不适用catch回调，promise的错误不会传递到外层
                    promise
                    .then(function(data) {
                        // success
                    }).catch(function(error) {
                        // error
                    })

        Promise.resolve()
                将现有对象转为Promise对象
                    Promise.resolve('foo'); === new Promise(resolve => resolve('foo'));
                方法接受四种参数：
                    1. Promise实例
                        原封返回该实例

                    2. thenable对象（具有then方法的对象）
                        转成Promise对象，并立即执行thenable对象的then方法
                        let thenable = {
                            then: function(resolve, reject) {
                              resolve(42);
                            }
                          };
                          
                          let p1 = Promise.resolve(thenable);
                          p1.then(function(value) {
                            console.log(value);  // 42
                          });
                        转换完thenable对象，并执行其then方法后，对象p1的状态就变为resolved，从而立即执行p1的then方法指定的回调函数，输出42。

                    3. 对象不具有then方法或根本不是对象
                        返回一个新的Promise对象，状态为Resolved(一生成就是该状态，立即调用回调)
                        var p = Promise.resolve('Hello');
                        p.then(function(s) {
                            console.log(s);
                        });
                        // Hello

                    4. 不带参数
                        直接返回Resolved的Promise对象（可以用来直接取一个Promise对象） 必须事先指定then回调？
                            var p = new Promise.resolve();
                            p.then(function() {
                                //
                            });
                        需要注意的是，立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。
                            setTimeout(function() {
                                console.log('three');
                            }, 0);

                            Promise.resolve().then(function() {
                                console.log('two');
                            });

                            console.log('one');
                            //one
                            //two
                            //three
                            <worning = "console.log()是立即执行，最先输出；setTimeout()是在下一轮‘事件循环’开始时执行；Promise.resolve()在本轮‘事件循环’结束时执行">
        
        Promise.reject()
                返回一个Rejected的Promise对象
                Promise.reject()的参数会作为reject的理由变成后续方法的参数
                const thenable = {
                    then(resolve, reject) {
                      reject('出错了');
                    }
                  };
                  
                  Promise.reject(thenable).catch(e => {console.log(e === thenable);});
                // true (不是‘出错了’)

        Promise.all()
                将多个Promise实例封装成一个
                var p = Promise.all([p1,p2,p3]).then(function(posts) {
                    //
                }).catch(function(reson) {
                    //
                });
                p的状态由p1,p2,p3决定，数组中不是Promise实例的值会先调用Promise.resolve()转化
                都为Fulfilled，p为Fulfilled，p1,p2,p3的返回值组成数组传给p的回调函数(只有都Fulfilled，才触发then回调)
                一个Rejected，p为Rejected，第一个Rejected的返回值传给P回调(只有出现一个Rejected，才触发catch回调，如果参数中的Promise实例定义了catch，则不会触发Promise.all()的catch)
                    const p1 = new Promise((resolve, reject) => {resolve('hello');}).then(result => result).catch(e => e);
                    const p2 = new Promise((resolve, reject) => {throw new Error('出错了');}).then(result => result).catch(e => e);
                    Promise.all([p1, p2]).then(resutl => console.log(result)).catch(e => console.log(e));
                    // ['hello', Error: 出错了]
                    // p1会resolved，p2首先会rejected，但p2有catch方法，该方法返回一个新的Promise实例，p2实际上指向这个实例，该实例执行完catch后会变成resolved（并不是p2变，而是这个新实例，p2状态已固定为rejected）
                    // 此时Promise.all()的两个实例都会resolved，因此会调用.all的then方法，而不是catch

                    // promise.all源码
                    Promise.all = function(arr) {
                        return new Promise(function(resolve, reject) {
                            if (!arr || typeof arr.length === 'undefined')
                                throw new TypeError('Promise.all accepts an array');
                            var args = Array.prototype.slice.call(arr);
                            if (args.length === 0) return resolve([]);
                            var remaining = args.length;

                            function res(i, val) {
                                try {
                                    // 如果 val 是 Promise 对象的话，则执行 Promise,直到 resolve 了一个非 Promise 对象
                                    if (val && (typeof val === 'object' || typeof val === 'function')) {
                                        var then = val.then;
                                        if (typeof then === 'function') {
                                            then.call(
                                                val,
                                                function(val) {
                                                    res(i, val);
                                                },
                                                reject
                                            );
                                            return;
                                        }
                                    }
                                    // 用当前resolve||reject 的值重写 args[i]{Promise} 对象
                                    args[i] = val;
                                    // 直到所有的 Promise 都执行完毕，则 resolve all 的 Promise 对象，返回args数组结果
                                    if (--remaining === 0) {
                                        resolve(args);
                                    }
                                } catch (ex) {
                                    // 只要其中一个 Promise 出现异常，则全部的 Promise 执行退出，进入 catch异常处理
                                    // 因为 resolve 和 reject 回调有 done 变量的保证只能执行一次，所以其他的 Promise 都不执行
                                    reject(ex);
                                }
                            }

                            for (var i = 0; i < args.length; i++) {
                                res(i, args[i]);
                            }
                        });
                    };
                            
        Promise.race()
                race也是将多个Promise实例封装到一起
                var p = Promise.race([p1,p2,p3]);
                p的状态取决于第一个改变状态的实例，第一个变化的实例会将返回值传给p的回调函数
                    var p = Promise.race([
                        fetch('/resource-that-may-take-a-while'),
                        new Promise(function (resolve, reject) {
                            setTimeout(() => reject(new Error('request timeout')), 5000)
                        })
                    ]);
                    p.then(response => console.log(response));
                    p.catch(error => console.log(error));
                    // 5秒之内fetch无返回，第二个参数实例率先变为rejected，而后p变成rejected，执行catch

        done()
                Promise对象的回调链，无论是then，catch结尾，最后一个方法出错都无法捕获，done方法处于回调链尾端，保证抛出错误
                AsyncFuns().then().catch().then().done();
                Promise.prototype.done = function(onFulfilled, onRejected) {
                    this.then(onFulfilled, onRejected).catch(function(reason) {
                        // 抛出全局错误
                        setTimeout(()=>throw reason, 0);
                    });
                };

        finally()
                不管Promise对象最后的状态如何，都会执行，接受回调函数作为参数
                    server.listen(0).then(function() { //.. }).finally(server.stop);

        Promise 应用：
                1. 加载图片
                    const preloadImage = function(path) {
                        return new Promise(function(resolve, reject) {
                            let image = new Image();
                            image.onload = resolve;
                            image.onerror = reject;
                            image.src = path;
                        });
                    };
                2. Generator与Promise
                    使用Generator函数管理流程，遇到异步操作，返回一个Promise对象
        
        Promise.try()
                实现同步操作同步处理，异步操作异步处理
                const f = ()=>console.log('now');
                Promise.try(f);
                console.log('next');
                // now
                // next
                使用then管理流程，最好使用Promise.try()包装一下，便于错误管理
                Promise.try(database.users.get({id:userId})).then(...).catch(...); // 此时catch可以捕获所有同步和异步错误
                Promise.try模拟了try代码块 Promise.catch模拟了catch

        ----------------------------for example--------------------------------------https://developers.google.com/web/fundamentals/primers/promises#promise_generator
        <script>
            var storyPromise;

            function getChapter(i) {
                storyPromise = storyPromise || getJSON('story.json');
            
                return storyPromise.then(function(story) {
                return getJSON(story.chapterUrls[i]);
                })
            }
            
            // and using it is simple:
            getChapter(0).then(function(chapter) {
                console.log(chapter);
                return getChapter(1);
            }).then(function(chapter) {
                console.log(chapter);
            })
        </script>
        直到 getChapter 被调用，我们才下载 story.json，但是下次 getChapter 被调用时，我们重复使用 story romise(第一次提取时，已保存在全局变量storyPromise中)，
        因此 story.json 仅提取一次。 这就是 Promise 的魅力所在！

        <script>
            getJSON('story.json').then(function(story) {
                addHtmlToPage(story.heading);

                return story.chapterUrls.reduce(function(sequence, chapterUrl) {
                    // Once the last chapter's promise is done…
                    return sequence.then(function() {
                        // …fetch the next chapter
                        return getJSON(chapterUrl);
                    }).then(function(chapter) {
                        // and add it to the page
                        addHtmlToPage(chapter.html);
                    });
                }, Promise.resolve());
            }).then(function() {
            // And we're all done!
            addTextToPage("All done");
            }).catch(function(err) {
            // Catch any error that happened along the way
            addTextToPage("Argh, broken: " + err.message);
            }).then(function() {
            // Always hide the spinner
            document.querySelector('.spinner').style.display = 'none';
            })
        </script>   
    
            同时加载所有章节
            Promise.all 包含一组 promise，并创建一个在所有内容成功完成后执行的 promise。 您将获得一组结果（即一组 promise 执行的结果），其顺序与您与传入 promise 的顺序相同。
            <script>
                getJSON('story.json').then(function(story) {
                    addHtmlToPage(story.heading);
    
                    // Take an array of promises and wait on them all
                    return Promise.all(
                        // Map our array of chapter urls to
                        // an array of chapter json promises
                        story.chapterUrls.map(getJSON)
                    );
                }).then(function(chapters) {
                    // Now we have the chapters jsons in order!Loop through…
                    chapters.forEach(function(chapter) {
                        // …and add to the page
                        addHtmlToPage(chapter.html);
                    });
                    addTextToPage("All done");
                }).catch(function(err) {
                    // catch any error that happened so far
                    addTextToPage("Argh, broken: " + err.message);
                }).then(function() {
                    document.querySelector('.spinner').style.display = 'none';
                })
            </script>

            先下载一章节并显示，其余一起
            <script>
                getJSON('story.json').then(function(story) {
                    addHtmlToPage(story.heading);

                    // Map our array of chapter urls to
                    // an array of chapter json promises.
                    // This makes sure they all download in parallel.
                    return story.chapterUrls.map(getJSON).reduce(function(sequence, chapterPromise) {
                        // Use reduce to chain the promises together,
                        // adding content to the page for each chapter
                        return sequence.then(function() {
                            // Wait for everything in the sequence so far,
                            // then wait for this chapter to arrive.
                            return chapterPromise;
                        }).then(function(chapter) {
                            addHtmlToPage(chapter.html);
                        });
                    }, Promise.resolve());
                }).then(function() {
                    addTextToPage("All done");
                }).catch(function(err) {
                    // catch any error that happened along the way
                    addTextToPage("Argh, broken: " + err.message);
                }).then(function() {
                    document.querySelector('.spinner').style.display = 'none';
                })
            </script>


            <script>
                function spawn(generatorFunc) {
                    function continuer(verb, arg) {
                        var result;
                        try {
                            result = generator[verb](arg);
                        } catch (err) {
                            return Promise.reject(err);
                        }
                        if (result.done) {
                            return result.value;
                        } else {
                            return Promise.resolve(result.value).then(onFulfilled, onRejected);
                        }
                    }
                    var generator = generatorFunc();
                    var onFulfilled = continuer.bind(continuer, "next");
                    var onRejected = continuer.bind(continuer, "throw");
                    return onFulfilled();
                }
            </script>

            结合新 ES6 的优势，将其转变为：
            纳入很多新的 ES6 元素：promise、generator、let、for-of。
           <script>
                spawn(function *() {
                    try {
                        // 'yield' effectively does an async wait,
                        // returning the result of the promise
                        let story = yield getJSON('story.json');
                        addHtmlToPage(story.heading);

                        // Map our array of chapter urls to
                        // an array of chapter json promises.
                        // This makes sure they all download in parallel.
                        let chapterPromises = story.chapterUrls.map(getJSON);

                        for (let chapterPromise of chapterPromises) {
                            // Wait for each chapter to be ready, then add it to the page
                            let chapter = yield chapterPromise;
                            addHtmlToPage(chapter.html);
                        }
                        addTextToPage("All done");
                    }
                    catch (err) {
                        // try/catch just works, rejected promises are thrown here
                        addTextToPage("Argh, broken: " + err.message);
                    }
                    document.querySelector('.spinner').style.display = 'none';
                })
           </script>
           一个 promise 后，spawn 帮助程序将等待该 promise 来解析并返回一个终值。 如果 promise 拒绝，spawn 会让 yield 语句抛出异常，我们可通过常规的 JavaScript try/catch 来捕获此异常。


<Q&A 161> 箭头函数

        var f = v => v;
        var f = function(v) {
            return v;
        }

        var f = () => 5; // 不需要参数或多个

        特点：
             1.函数体内的this指向函数定义时所在的对象，而不是使用时所在的对象，this在箭头函数内是固定的 （实际上，箭头函数没有自身的this，其this就是外层代码块的this，正是没有this，所以不能做构造函数）
             2.不能当做构造函数使用，不能使用new
             3.不可以使用arguments对象，该对象在函数体内不存在，可以使用rest对象
             4.不能使用yield，箭头函数不能做Generator函数

        嵌套箭头函数：

                function insert(value){
                    return {into: function(array){
                            return {after: fucntion(aftervalue){
                                array.splice(array.indexof(aftervalue)+1,0,value);
                                return array;
                            }};
                    }};
                }
                insert(2).into([1,3]).after(1); //[1,2,3]

                let insert = (value) => ({into: (array) => ({after: (aftervalue) => {array.splice(array.indexof(aftervalue)+1,0,value);return array;}})});
                insert(2).into([1,3]).after(1); //[1,2,3]
                
<Q&A 162> Iterator

        本质是指针对象，遍历器对象具有
        next()： 构造遍历器对象生成函数时必须部署、
        return()：用于提前推出循环、必须返回一个对象（Generator规定）
        throw()： 配合Generator函数
        支持for...of 
        next()返回{value, done} value是当前值，done表示遍历是否结束 false/true   value: undefined和done: false都可以省略

        一个数据结构只要具有Symbol.iterator属性，就是可遍历的（ES6默认的Iterator接口部署在该属性上） 
        原生具备Iterator接口的数据结构：
                Array
                Map
                Set
                String
                TypedArray
                函数的arguments
                NodeList对象
        
        let arr = ['a','b','c'];
        let iter = arr[Symbol.iterator]();

        iter.next(); // { value: 'a', done: false }
        iter.next(); // { value: 'b', done: false }
        iter.next(); // { value: 'c', done: false }
        iter.next(); // { value: undefined, done: true }

        一个对象如果要有可被for...of循环调用的Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。
            class RangeIterator {
                constructor(start, stop) {
                    this.value = start;
                    this.stop = stop;
                }
            
                [Symbol.iterator]() { return this; }
            
                next() {
                    var value = this.value;
                    if (value < this.stop) {
                        this.value++;
                        return {done: false, value: value};
                    }
                        return {done: true, value: undefined};
                }
            }
            
            function range(start, stop) {
                return new RangeIterator(start, stop);
            }
            
            for (var value of range(0, 3)) {
                console.log(value); // 0, 1, 2
            }
        部署Iterator接口的简单方法（引用数组的Iterator接口）：NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];

        默认使用Iterator接口的场合
                1. 解构赋值
                    let set = new Set().add('a').add('b').add('c');
                    let [x,y] = set;
                    // x='a' y='b'
                2. 扩展运算符
                    var str = 'hello';
                    [...str] // ['h','e','l','l','o']
                3. yield*
                    yield*后面跟可遍历结构，调用该结构的遍历器接口
                4. 其他
                    for...of
                    Array.from()
                    Map() Set() WeakMap() WeakSet() //weakmap只接受对象做key，weakset成员也只能是对象，都是弱引用，垃圾回收不会考虑其引用
                    Promise.all()
                    Promise.race()
        
        Symbol.iterator 的最简单实现: 使用Generator函数
                var myIterable ={};
                myIterable[Symbol.iterator] = function*() { // 直接为对象的Symbol.iterator属性定义Generator函数
                    yield 1;
                    yield 2;
                    yield 3;
                };
                [...myIterable] // [1,2,3]
                    或
                let obj = {
                    *[Symbol.iterable]() {  
                        yield 'hello';
                        yield 'world';
                    }
                };

                for(let x of obj) {
                    console.log(x);
                }
                // hello
                // world
        
        遍历类似数组的对象
                // 字符串
                let str = "hello";
                
                for (let s of str) {
                    console.log(s); // h e l l o
                }
                
                // DOM NodeList对象
                let paras = document.querySelectorAll("p");
                
                for (let p of paras) {
                    p.classList.add("test");
                }
                
                // arguments对象
                function printArgs() {
                    for (let x of arguments) {
                        console.log(x);
                    }
                }
                printArgs('a', 'b');
                // 'a'
                // 'b'

            不具有Iterator接口的对象，先Array.from()转为数组，在遍历

            Iterator 的作用有三个：
                                    一是为各种数据结构，提供一个统一的、简便的访问接口；
                                    二是使得数据结构的成员能够按某种次序排列；
                                    三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。

<Q&A 163> forEach、for...in 和 for...of 区别

    1. for...in 为js原有，for...of 是es6新增
    2. for...in 循环只能读取键名 for...of 能读取键值
    3. for...of 只返回具有数字索引的属性
            let arr = [3,5,7];
            arr.foo = 'hello';

            for (let i in arr) {
                console.log(i); // '0','1','2','foo' 键名
            }

            for(let i of arr) {
                console.log(i); // '3','5','7' 键值
            }
    4. 只有部署Iterator接口才能使用for...of；for...in 可以直接遍历键名
    5. 数组内置的forEach无法中途推出
    6. for...in 为遍历对象设计，而不是数组，可以遍历数字键名或是手动添加的其他键
    7. for...of 提供了所有数据结构同一的遍历接口

<Q&A 164> Set和Map 都具有以下方法

        entries(): 返回遍历器对象，遍历 [键名，键值] 的数组，数组的键名就是索引值，Set的键名=键值，Map的iterator接口默认调用entries()
        keys(): 返回遍历器对象 遍历所有键名
        values(): 返回遍历器对象 遍历所有键值

<Q&A 165> Generator

        类似一种状态机，封装了多个内部状态，还是一种遍历器对象生成函数
        返回一个遍历器对象（一个指向内部状态的指针对象），可以依次遍历每个内部状态
            function* helloWorldGenerator() {
                yield 'hello';
                yield 'world';
                return 'ending'; // return 也算一种内部状态
            }
            var hw = helloWorldGenerator();
        调用Generator函数后，函数并不执行也不返回运行结果，而是一个指向内部状态的指针对象
        调用next()，指针指向下一个状态
        yield表达式只能用在Generator里，不使用yield，Generator 就是单纯的暂缓执行函数
            function* f() {
                console.log('done');
            }

            var generator = f(); // f没有立即执行，只有调用next才执行，普通函数此时已执行
            setTimeout(function() {generator.next()}, 3000);

        yield没有返回值，总是返回undefined
        next()可以接受一个参数，表示上一条yield的返回值，所以第一次调用next是无法传参的
            可以在Generator函数开始运行后继续向函数内部注入值

        for...of 不需要next就能遍历Generator内部状态，但无法遍历最后return的状态
           function *foo() {
               yield 1;
               yield 2;
               yield 3;
               return 4;
           }
           for (let v of foo()) {
               console.log(v);  // 1 2 3
           }
        除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将Generator函数返回的Iterator对象，作为参数。

        Generator.prototype.throw()
                var g = function* () {
                    try {
                    yield;
                    } catch (e) {
                    console.log('内部捕获', e);
                    }
                };
                
                var i = g();
                i.next();
                
                try {
                    i.throw('a');
                    i.throw('b');
                } catch (e) {
                    console.log('外部捕获', e);
                }
                // 内部捕获 a
                // 外部捕获 b
            上面代码中，遍历器对象i连续抛出两个错误。第一个错误被Generator函数体内的catch语句捕获。i第二次抛出错误，由于Generator函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，
            所以这个错误就被抛出了Generator函数体，被函数体外的catch语句捕获。

            ·注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。
            ·就是是用遍历器对象的throw方法，如果函数内部没有try...catch 也不会捕获
                var g = function* () {
                    while (true) {
                        try {
                            yield;
                        } catch (e) {
                            if (e != 'a') throw e;
                            console.log('内部捕获', e);
                        }
                    }
                };
                
                var i = g();
                i.next();
                
                try {
                    throw new Error('a');
                    throw new Error('b');
                } catch (e) {
                    console.log('外部捕获', e);
                }
                // 外部捕获 [Error: a]
            上面代码之所以只捕获了a，是因为通过全局throw命令抛出的异常只能函数体外捕获，函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。

            遍历器的throw方法被捕获后会附带执行下一条yield，即一次next()

        Generator.prototype.return()
                返回给定的值，并终止遍历，不提供参数，返回的value属性为undefined
                如果函数内部有try...finally，则在调用return方法后执行finally代码，执行完后再执行return方法
                    function* numbers () {
                        yield 1;
                        try {
                            yield 2;
                            yield 3;
                        } finally {
                            yield 4;
                            yield 5;
                        }
                        yield 6;
                    }
                    var g = numbers()
                    g.next() // { value: 1,  done: false }
                    g.next() // { value: 2,  done: false }
                    g.return(7) // { value: 4,  done: false }   调用return时立即执行finally部分
                    g.next() // { value: 5,  done: false }
                    g.next() // { value: 7,  done: true }    finally执行完，再执行return，返回value:7

        yield* 
                在Generator里调用另一个Generator  等于将两个Generator里的yield语句合到一起
                yield* Generator()  当next执行到此时返回的是该遍历器对象的内部值
                yield*后面的Generator函数（没有return语句时，for...of 无法遍历return状态），等同于在Generator函数内部，部署一个for...of循环。反之，则需要用var value = yield* iterator的形式获取return语句的值。
                    function *foo() {
                        yield 2;
                        yield 3;
                        return "foo";
                    }
                    
                    function *bar() {
                        yield 1;
                        var v = yield *foo();  // 可以获取到return的值 v='foo'
                        console.log( "v: " + v );
                        yield 4;
                    }
                    
                    var it = bar();
                    
                    it.next()
                    // {value: 1, done: false}
                    it.next()
                    // {value: 2, done: false}
                    it.next()
                    // {value: 3, done: false}
                    it.next();
                    // "v: foo"
                    // {value: 4, done: false}
                    it.next()
                    // {value: undefined, done: true}

                yield*命令可以很方便地取出嵌套数组的所有成员。

                    function* iterTree(tree) {
                      if (Array.isArray(tree)) {
                        for(let i=0; i < tree.length; i++) {
                          yield* iterTree(tree[i]);
                        }
                      } else {
                        yield tree;
                      }
                    }
                    
                    const tree = [ 'a', ['b', 'c'], ['d', 'e'] ];
                    
                    for(let x of iterTree(tree)) {
                      console.log(x);
                    }
                    // a
                    // b
                    // c
                    // d
                    // e
                
                使用yield*语句遍历完全二叉树。

                    // 下面是二叉树的构造函数，
                    // 三个参数分别是左树、当前节点和右树
                    function Tree(left, label, right) {
                      this.left = left;
                      this.label = label;
                      this.right = right;
                    }
                    
                    // 下面是中序（inorder）遍历函数。
                    // 由于返回的是一个遍历器，所以要用generator函数。
                    // 函数体内采用递归算法，所以左树和右树要用yield*遍历
                    function* inorder(t) {
                      if (t) {
                        yield* inorder(t.left);
                        yield t.label;
                        yield* inorder(t.right);
                      }
                    }
                    
                    // 下面生成二叉树
                    function make(array) {
                      // 判断是否为叶节点
                      if (array.length == 1) return new Tree(null, array[0], null);
                      return new Tree(make(array[0]), array[1], make(array[2]));
                    }
                    let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);
                    
                    // 遍历二叉树
                    var result = [];
                    for (let node of inorder(tree)) {
                      result.push(node);
                    }
                    
                    result
                    // ['a', 'b', 'c', 'd', 'e', 'f', 'g']
        
        对象属性是Generator函数        
                let obj = {
                    * myGeneratorMethod() {
                        ···
                    }
                };
                
                let obj = {
                    myGeneratorMethod: function* () {
                        // ···
                    }
                };

        · Generator返回的遍历器是其实例，继承了Generator函数的prototype对象上的方法
        · 返回的遍历器不是this对象，所以Generator通过this添加的属性，遍历器访问不到
        · Generator不能和new一起

        让Generator返回正常对象，可以next()也能获得this： 生成空对象，用call绑定Generator函数内部的this，调用构造后，该对象就是Generator的实例
                    function* F() {
                        this.a = 1;
                        yield this.b = 2;
                        yield this.c = 3;
                    }
                    var obj = {};
                    var f = F.call(obj); // f是遍历器对象，obj是生成的对象实例 可以统一到一起 var f = F.call(F.prototype);
                    
                    f.next();  // Object {value: 2, done: false}
                    f.next();  // Object {value: 3, done: false}
                    f.next();  // Object {value: undefined, done: true}
                    
                    obj.a // 1
                    obj.b // 2
                    obj.c // 3
                
                将F改成构造函数，就可以使用 new
                    function* gen() {
                        this.a = 1;
                        yield this.b = 2;
                        yield this.c = 3;
                    }
                    
                    function F() {
                        return gen.call(gen.prototype);
                    }
                    
                    var f = new F();
                    
                    f.next();  // Object {value: 2, done: false}
                    f.next();  // Object {value: 3, done: false}
                    f.next();  // Object {value: undefined, done: true}
                    
                    f.a // 1
                    f.b // 2
                    f.c // 3
                    
        Generator与状态机
                var clock = function*() {
                    while (true) {
                    console.log('Tick!');
                    yield;
                    console.log('Tock!');
                    yield;
                    }
                };
        Generator与协程
                协程（coroutine）是一种程序运行的方式，“协作的线程”或“协作的函数”。
                可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。
                可以并行执行 交换执行权的线程就是协程

                ·js是单线程，只保持一个调用栈，引入协程后，每个任务可以保持自己的调用栈，在抛出错误时，就可以找到原始的调用栈。（不像异步操作的回调函数，出错的原始调用栈已销）
                
                Generator是半协程，只有Generator函数的调用者，才能将程序的执行权还给Generator函数 如果是完全执行的协程，任何函数都可以让暂停的协程继续执行
                如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。
        
        Generator应用：
                    1. 处理异步操作
                            function* loadUI() {
                                showLoadingScreen();
                                yield loadUIDataAsynchronously(); // 第一次调用next 会执行到该语句（包括）
                                hideLoadingScreen();
                            }
                            var loader = loadUI();
                            // 加载UI
                            loader.next()
                            
                            // 卸载UI
                            loader.next()
                        第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示Loading界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。
                        所有Loading界面的逻辑，都被封装在一个函数，清楚简洁
                      Generator部署Ajax
                            function* main() {
                                var result = yield request("http://some.url");
                                var resp = JSON.parse(result);
                                console.log(resp.value);
                            }
                            function request(url) {
                                makeAjaxCall(url, function(response) {
                                    it.next(response);
                                });
                            }
                            var it = main();
                            it.next();
                      Generator读取文本文件
                            function* numbers() {
                                let file = new FileReader("numbers.txt");
                                try {
                                    while(!file.eof) {
                                        yield parseInt(file.readLine(),10);
                                    }
                                } finally {
                                    file.close();
                                }
                            }
                    2. 控制流管理
                            step1(function (value1) {
                                step2(value1, function(value2) {
                                    step3(value2, function(value3) {
                                        step4(value3, function(value4) {
                                        // Do something with value4
                                        });
                                    });
                                });
                            });

                        Promise 改写
                            Promise.resolve(step1)
                            .then(step2)
                            .then(step3)
                            .then(step4)
                            .then(function(value4) {
                                // Do something with value4
                            }, function(error) {
                                // Handle any error from step1 through step4
                            })
                            .done();

                        Generator 改写(只适合所有操作都是同步)
                            function* longRunningTask(value1) {
                                try{
                                    var value2 = yield step1(value1);
                                    var value3 = yield step2(value2);
                                    var value4 = yield step3(value3);
                                    var value5 = yield step4(value4);
                                    // Do something with value4
                                } catch {
                                   // Handle any error from step1 through step4
                                }
                            }
                            scheduler(longRunningTask(initialValue));
                            function scheduler(task) {
                                var taskObj = task.next(task.value);
                                // Generator没结束就继续调用
                                if (!taskObj.done) {
                                    task.value = taskObj.value
                                    scheduler(task);
                                }
                            }

                        利用for...of 控制流(只适合所有操作都是同步)
                        <script>
                            let steps  = [step1Func, step2Func, step3Func];
                            function* iterateSteps(steps) {
                                for(var i=0; i<steps.length; i++) {
                                    var step = steps[i];
                                    yield step();
                                }
                            }

                            let jobs = [job1, job2, job3];
                            function* iterateJobs(jobs) {
                                for(var i=0; i<jobs.length; i++) {
                                    var job = jobs[i];
                                    yield* iterateSteps(job.steps);
                                }
                            }

                            for (var step of iterateJobs(jobs)) {
                                console.log(step.id);
                            }
                        </script>
                            
                    
                    3. 部署Iterator接口
                            Generator函数可以在任意对象上部署Iterator接口
                                function* iterEntries(obj) {
                                    let keys = Object.keys(obj);
                                    for(var i=0; i<keys.length; i++) {
                                        let key = keys[i];
                                        yield [key, obj[key]];
                                    }
                                }
                                let myObj = {foo:3, bar:7};
                                for(let [key, value] of iterEntries(myObj)) {
                                    console.log(key, value);
                                }
                                // foo 3
                                // bar 7

                    4. 作为数据结构
                            类似数组结构，为任意表达式提供类似数组接口
                                function *doStuff() {
                                    yield fs.readFile.bind(null, 'hello.txt');
                                    yield fs.readFile.bind(null, 'world.txt');
                                    yield fs.readFile.bind(null, 'and-such.txt');
                                }
                                for (task of doStuff()) {
                                    // task是一个函数，可以像回调函数那样使用它
                                }

                            ES5表达，完全可以用数组模拟Generator的这种用法。
                                function doStuff() {
                                    return [
                                        fs.readFile.bind(null, 'hello.txt'),
                                        fs.readFile.bind(null, 'world.txt'),
                                        fs.readFile.bind(null, 'and-such.txt')
                                    ];
                                }

<Q&A 166> 协程、子例程、普通线程

        1. 子例程 单线程；协程 可以单线程（单线程下多函数）也可以多线程
        2. 子例程 堆栈式 后进先出 只有子函数执行完，才执行父函数；协程 多个线程 可以并行执行，但只有一个处于执行状态，线程间可以切换执行权
        3. 子例程只使用一个栈，而协程同时使用多个栈，但只有一个在运行（以多占内存为代价实现多任务并行运行）
        4. 普通线程和协程都有自己上下文，共享全局变量
        5. 普通线程是抢占式的，由环境决定那个线程得到资源；协程是合作式的，执行权由协程分配

<Q&A 167> async函数

            Generator语法糖  将*改为async 将yield改为await

            ·内置执行器：  调用后自动执行不需要使用next或co模块
            ·语义更好
            ·适用性：  co模块规定yield后面只能是Thunk函数或Promise对象， await后面可以是Promise对象或原始值（数值、字符、布尔型 此时是同步操作）
            ·返回值是Promise：  Generator返回Iterator对象，async返回Promise对象 可以用then指定下一步操作

            async函数可以看作多个异步操作封装成的一个Promise对象，而await就是内部then的语法糖

            用法
                当执行函数时，遇到await就先返回，等异步操作完成，再接着执行后面语句。可以用then为返回的Promise添加回调
                    // 股票报价
                    async function getStockPriceByName(name) {
                        var symbol = await getStockSymbol(name);
                        var stockPrice = await getStockPrice(Symbol);
                        return stockPrice;
                    }
                    getStockPriceByName('goog').then(function(result) {
                        console.log(result);
                    });
            
            async内部return的值会成为then方法的参数
            async内部抛出的错误会使Promise对象变成rejected，并被catch回调捕获
            只要一个await后的Promise对象变为rejected，整个async函数就会中断执行（利用try...catch或catch()可以避免中断），reject的参数也会被catch捕获

            async返回的Promise的状态变化
                    必须等到内部所有await后的Promise执行完才改变状态，除非遇到return或抛错
                    即 内部异步操作执行完，才执行then指定的回调
                    await后的异步出错，async返回的Promise就为rejected
                
            注意：
                ·await后的Promise可能使Rejected，await最好放在try...catch中，或为Promise指定catch回调
                    async function myFunction() {
                        try {
                        await somethingThatReturnsAPromise();
                        } catch (err) {
                            console.log(err);
                        }
                    }
                    // 另一种写法
                    async function myFunction() {
                        await somethingThatReturnsAPromise()
                        .catch(function (err) {
                            console.log(err);
                        };
                    }
                ·不存在继发的await最好同时触发
                    let foo = await getFoo();
                    let bar = await getBar();
                    //写法一
                    let [foo, bar] = await Promise.all([getFoo(), getBar()]);
                    //写法二
                    let fooPromise = getFoo();
                    let barPromise = getBar();
                    let foo = await fooPromise;
                    let bar = await barPromise;
                ·await只能用在async
            
            实现原理
                    将Generator和自动执行器封装在一起

            异步遍历器
                    Iterator的next方法必须是同步的
                    想要异步遍历需要遍历器的next方法返回的value是一个Promise对象或Thunk函数，而done依旧是同步产生的
                    异步遍历器的接口在Symbol.asyncIterator属性上
                        
                        const asyncIterable = createAsyncIterable(['a','b']);
                        const asyncIterator = asyncIterable[Symbol.asyncIterator]();

                        asyncIterator
                        .next()
                        .then(iterResult1 => {
                            console.log(iterResult1); // { value: 'a', done: false }
                            return asyncIterator.next();
                        })
                        .then(iterResult2 => {
                            console.log(iterResult2); // { value: 'b', done: false }
                            return asyncIterator.next();
                        })
                        .then(iterResult3 => {
                            console.log(iterResult3); // { value: undefined, done: true }
                        });

                    异步遍历器第一次会返回Promise对象，等resolve后，返回表示当前数据成员信息的对象

                            const asyncIterable = createAsyncIterable(['a', 'b']);
                            const asyncIterator = someCollection[Symbol.asyncIterator]();
                            
                            asyncIterator.next()
                            .then(iterResult1 => {
                                console.log(iterResult1); // { value: 'a', done: false }
                                return asyncIterator.next();
                            }).then(iterResult2 => {
                                console.log(iterResult2); // { value: 'b', done: false }
                                return asyncIterator.next();
                            }).then(iterResult3 => {
                                console.log(iterResult3); // { value: undefined, done: true }
                            });

                    ·异步遍历的next()可以连续调用,不必等上一步Promise resolve，next累积起来会自动按顺序执行
                            const asyncGenObj = createAsyncIterable(['a', 'b']);
                            const [{value: v1}, {value: v2}] = await Promise.all([
                            asyncGenObj.next(), asyncGenObj.next()
                            ]);
                            
                            console.log(v1, v2); // a b
                    
                    for await...of 
                            遍历asyncIterator接口
                              async function f() {
                                  for await (const x of createAsyncIterable(['a','b'])) {
                                      console.log(x);
                                  }
                              }
                            createAsyncIterable()返回一个异步遍历器，for...of循环自动调用这个遍历器的next方法，会得到一个Promise对象。await用来处理这个Promise对象，一旦resolve，就把得到的值（x）传入for...of的循环体。
                            如果next返回的Promise对象 rejected，for await...of 就会报错
                              async function f() {
                                  try {
                                    for await (const x of createAsyncIterable(['a','b'])) {
                                        console.log(x);
                                    }
                                  } catch(e) {
                                      console.error(e);
                                  }
                              }

                    ·异步遍历器的目的之一就是  让Generator函数能使用同一套接口处理同步和异步操作
                              // 同步Generator
                              function* map(iterable, func) {
                                  const iter = iterable[Symbol.iterator]();
                                  while(true){
                                      const{value, done} = iter.next();
                                      if (done) break;
                                      yield func(value);
                                  }
                              }
                              // 异步Generator
                              function* map(iterable, func) {
                                const iter = iterable[Symbol.asyncIterator]();
                                while(true){
                                    const{value, done} = await iter.next();
                                    if (done) break;
                                    yield func(value); 
                                }
                            }
                            // 异步Generator内部可以同时使用await和yield
                            // 使用yield的地方就是next方法停下的地方
                            // await命令将外部操作产生的值输入函数内部，yield将函数内部的值输出

            异步Generator函数
                        就是async函数和Generator函数的结合
                        函数返回的是异步遍历器对象，但每次调用next都返回一个Promise对象，所以yield后面的也是Promise对象
                              async function* gen() {
                                  yield 'hello';
                              }
                              const genObj = gen();
                              genObj.next().then(x => console.log(x));
                        
                        yield* 也可以与异步遍历器一同使用
            
            ·普通async函数返回的是Promise对象，而异步Generator函数返回的是异步Iterator对象
                原因：两者都是封装异步操作的两种方法 async自带执行器，异步Generator通过for await...of/自定义执行器
                下面就是一个异步Generator函数的执行器。
                    async function takeAsync(asyncIterable, count=Infinity) {
                        const result = [];
                        const iterator = asyncIterable[Symbol.asyncIterator]();
                        while (result.length < count) {
                            const {value, done} = await iterator.next();
                            if (done) break;
                            result.push(value);
                        }
                        return result;
                    }


<Q&A 168> 异步处理方法的比较

        假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。

        Promise
                function chainAnimationsPromise(elem, animations) {
                    // 变量ret保存上一个动画的返回值
                    var ret = null;
                    // 新建空的Promise
                    var p = Promise.resolve();
                    // 使用then添加所有动画
                    for(var anim of animations) {
                        p = p.then(function(val) {
                            ret = val;
                            return anim(elem);
                        });
                    }
                    // 返回部署错误捕捉机制的Promise
                    return p.catch(function(e) {
                        /* 忽略错误，继续执行 */
                    }).then(function(){
                        return ret;
                    });
                }

        Generator
                function chainAnimationsGenerator(elem, animations) {
                    return spawn(function* () {
                        var ret = null;
                        try {
                            for(var anim of animations) {
                                ret = yield anim(elem);
                            }
                        } catch(e) {
                            /* 忽略错误 继续执行 */
                        }
                        return ret;
                    });
                }
                语义比Promise更清晰，定义的操作都在spawn内部，但问题是用户必须自己提供一个任务运行器spawn（返回Promise对象），而且必须保证yield后面的表达式返回Promise

        async
                async function chainAnimationAsync(elem, animations) {
                    var ret = null;
                    try {
                        for(var anim of animations) {
                            ret = await anim(elem);
                        }
                    } catch(e) {
                        /* 忽略错误 继续执行 */
                    }
                    return ret;
                }
                语义最简单，Generator的自动执行器放在了语言层面

<Q&A 169> 封装异步操作的方法

                ·Promise
                ·async函数 （自带执行器）
                ·异步Generator （通过 for await...of 执行）

<Q&A 170> js 4种函数形式 及区别

                普通函数、async函数、Generator函数、异步Generator函数

                如果是一系列按照顺序执行的异步操作（如读取文件，写入内容存硬盘），可以使用async函数
                如果是一系列产生相同数据结构的异步操作（如一行一行读取文件），则使用异步Generator函数

<Q&A 171> class 继承

            使用extends关键字
            子类必须在constructor中调用super方法，否则新建实例会报错，因为子类没有this对象，而是继承父类的this对象，并对其修改
            ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。
            ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。

            所有子类都默认有constructor方法，constructor中只有调用super后才能使用this

            Object.getPrototypeOf()可以获取父类

        super
            既是函数也是对象,必须显示指定是函数还是对象
            函数：代表父类函数，但返回子类的实例 即super内部的this指的是子类  只能用在子类的构造函数中

                super() === 父类.prototype.constructor.call(this)
            对象：在普通方法中指向父类的原型对象；在静态方法中指向父类
                
                ·普通方法
                    通过super调用属性时，调用的是父类原型的属性： super.x === Parent.prototype.x
                    通过super调用父类方法时 super会绑定子类的this： super.print() == 父类.prototype.print()  实际 === super.print.call(this)
                    通过super为属性赋值时，super会绑定子类的this，变成为子类实例赋值， super.x=3 === this.x=3

                            class A {
                                constructor() {
                                this.x = 1;
                                }
                            }
                            class B extends A {
                                constructor() {
                                super();
                                this.x = 2;
                                super.x = 3;
                                console.log(super.x); // undefined
                                console.log(this.x); // 3
                                }
                            }
                            let b = new B();

                ·静态方法

        类的prototype属性和__proto__属性
                    
                    Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。
                            
                            ·子类的__proto__属性，表示构造函数的继承，总是指向父类
                            ·子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性

                            这两条继承链：
                                        作为一个对象，子类（B）的原型（__proto__属性）是父类（A）
                                        作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例
                                        
        extends
                    子类继承Object：子类就是Object的复制，子类的实例就是Object的实例
                                        class A extends Object {
                                        }
                                        A.__proto__ === Object // true
                                        A.prototype.__proto__ === Object.prototype // true
                    不存在任何继承：子类直接继承 Function.prototype
                                        class A {
                                        }
                                        A.__proto__ === Function.prototype // true
                                        A.prototype.__proto__ === Object.prototype // true
                                    子类就是普通函数，所以直接继承Function.prototype,调用子类返回空对象（Object实例）所以子类.prototype.__proto__指向构造函数（Object）的prototype属性。
                    子类继承null：子类也是普通函数，直接继承 Function.prototype
                                        class A {
                                        }
                                        A.__proto__ === Function.prototype // true
                                        A.prototype.__proto__ === Object.prototype // true

        原生构造函数的继承
                            Boolean()
                            Number()
                            String()
                            Array()
                            Date()
                            Function()
                            RegExp()
                            Error()
                            Object()
                        原生构造函数是无法继承的（原生构造函数的this无法绑定，导致拿不到内部属性）
                        es6允许继承原生构造函数定义子类（因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承）es6可以自定义原生数据结构的子类
 
                    

<Q&A 172> Module

            es6之前：CommonJS（服务器）、AMD（浏览器）  都只能在运行时加载
            es6在语言层面上实现了模块化，静态加载/编译时加载  尽量静态化，编译时就能确定模块的依赖关系以及输入输出的变量  es6模块本身不能被引用，因为不是对象

            // CommonJS模块
            // 加载fs模块，即加载fs的所有方法，生成对象_fs 然后从该对象读取3个方法（运行时加载，只有运行时才能得到对象，没法静态优化）
            let { stat, exists, readFile } = require('fs');

            let _fs = require('fs');
            let stat = _fs.stat;
            let exists = fs.exists;
            let readfile = _fs.readfile;

            // ES6
            // 通过export命令显式输出，import输入
            import { stat, exists, readFile } from 'fs';

            ·不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。
            ·将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。
            ·不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。

            es6模块自动采用严格模式

            export
                    // profile.js 模块文件
                    var firstName = 'Michael';
                    var lastName = 'Jackson';
                    var year = 1958;
                    
                    function v1() { ... }
                    function v2() { ... }

                    export {
                        firstName, 
                        lastName, 
                        year, 
                        v1 as streamV1,
                        v2 as streamV2,
                        v2 as streamLatestVersion
                    };
                    或
                    export var firstName = 'Michael';
                    export var lastName = 'Jackson';
                    export var year = 1958;

                    export输出的接口与对应值是动态绑定的，如果值变，拿到的值也会变 与CommonJS不同（是缓存的值，不变）

                    export和import不能放在块级作用域内，不然无法静态优化

            import
                    会提升到模块头部首先执行， 在编译阶段执行，先于代码运行
                    导入模块时，若不带路径，必须通过配置文件告诉js引擎模块位置

                    模块整体加载所在的那个对象（下例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。
                    import * as circle from './circle'; // 除*外，导入的方法要加 { }
                    // 下面两行都是不允许的
                    circle.foo = 'hello';
                    circle.area = function () {};

                    同时引入默认方法和其他接口： 
                                                export default function (obj) {
                                                    // ···
                                                }
                                                
                                                export function each(obj, iterator, context) {
                                                    // ···
                                                }
                                                export { each as forEach };
                                                
                                                import _, { each, each as forEach } from 'lodash';

            export default
                    指定模块的默认输出（一个模块只有一个） 后面不能跟变量声明（export default a 就是将a赋值给default，所以不能 export default var a=1；也可以 export default 1；）
                    // export-default.js
                    export default function () {
                        console.log('foo');
                    }
                    // 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。
                    // import-default.js
                    import customName from './export-default';  // 导入时，不需要 { }
                    customName(); // 'foo'
                    export default命令用在非匿名函数前，也是可以的。但是import时原函数名无效，按匿名函数处理

                        // MyClass.js
                        export default class { ... }

                        // main.js
                        import MyClass from 'MyClass';
                        let o = new MyClass();

            export和import复合
                    import { foo, bar } from 'my_module';
                    export { foo, bar };
                    等价于
                    export { foo, bar } from 'my_module';

                    三种import没有复合
                    import * as someIdentifier from "someModule";
                    import someIdentifier from "someModule";
                    import someIdentifier, { nameIdentifier } from "someModule";
                
            模块间的继承
                    // circleplus.js
                    export * from 'circle'; // 导出circle的所有模块，但忽略default方法
                    export var e = 2.71828;
                    export default function(x) {
                        return Math.exp(x);
                    }
                    在circleplus模块中导入再导出circle模块，之后导出circleplus定义的变量和默认方法

            模块间共享常量
                    // constants.js
                    export const A = 1;
                    export const B = 3;
                    export const C = 4;

                    // test1.js
                    import * as constants from './constants';
                    console.log(constants.A); // 1

                    // test2.js
                    import {A, B} from './constants';
                    console.log(B); // 3

                    如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。
                        // constants/db.js
                            export const db = {
                            url: 'http://my.couchdbserver.local:5984',
                            admin_username: 'admin',
                            admin_password: 'admin password'
                        };

                        // constants/user.js
                        export const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];
                    然后，将这些文件输出的常量，合并在index.js里面。
                        // constants/index.js
                        export {db} from './db';
                        export {users} from './users';
                    使用的时候，直接加载index.js就可以了。
                        // script.js
                        import {db, users} from './constants/index';

            import()
                    实现动态加载的import，而且是异步加载
                    import命令无法取代node的require方法，require是运行时架子啊模块，
                       const path = './' + fileName;
                       const myModual = require(path);
                    上述require是动态加载（同步加载），只有运行时才知道加载谁，import做不到，import()可以
                    import() 返回Promise对象
                        const main = document.querySelector('main');

                        import(`./section-modules/${someVariable}.js`)
                        .then(module => {
                            module.loadPageInto(main);
                        })
                        .catch(err => {
                            main.textContent = err.message;
                        });
                    使用场景：
                            ·按需加载
                                button.addEventListener('click', event => {
                                    import('./dialogBox.js')
                                    .then(dialogBox => {
                                        dialogBox.open();
                                    })
                                    .catch(error => {
                                        /* Error handling */
                                    })
                                });
                            ·条件加载
                                if(condition) {
                                    import('moduleA').then(...);
                                } else {
                                    import('moduleB').then(...);
                                }
                            ·动态路径加载
                                import(f()).then(...); // 根据f()的返回值加载不同模块

                    import()加载后，模块会作为对象当做then的参数

<Q&A 173> js模块加载

            <!-- 页面内嵌的脚本 -->
            <script type="application/javascript">
                // module code
            </script>
            
            <!-- 外部脚本 -->
            <script type="application/javascript" src="path/to/myModule.js"></script>

            加载js模块时 浏览器的js引擎线程负责的，而浏览器的GUI渲染线程与其阻塞，执行完js脚本才会继续渲染
            如果js脚本过大，可以异步
            <script src="path/to/myModule.js" defer></script>
            <script src="path/to/myModule.js" async></script>

            defer和async区别：
                            · async实现外部js文件加载和dom解析异步，加载完立即阻塞dom，执行js；defer同样使js文件加载异步，但执行要等到dom全部解析完
                            · defer要等渲染结束（DOM结构完全生成，其它脚本执行完成），才会执行；而async一旦js模块下载完，就立即执行，之后继续渲染
                            · 多个defer 顺序加载，async 不能保证
                            · 都是实现js模块异步加载，解决js引擎线程和GUI渲染线程阻塞，但加载完后执行脚本也会产生阻塞，但脚本执行时间一般较短

            ES6：
                    浏览器加载ES6模块时，也使用<script></script>, 但要加type="module"属性，
                    浏览器对于带有type="module"的<script></script>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<script></script>标签的defer属性。
                    也可以添加async属性 覆盖默认

                    ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。

                        <script type="module">
                        import utils from "./utils.js";
                        // other code
                        </script>
                    有几点需要注意
                            · 模块内部的顶层变量，外部不可见。代码是在模块作用域之中运行，而不是在全局作用域运行。
                            · 模块脚本自动采用严格模式，不管有没有声明use strict。
                            · 模块之中，可以使用import命令加载其他模块（.js后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。
                            · 模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。
                            · 同一个模块如果加载多次，将只执行一次。

<Q&A 174> ES6模块和CommonJS模块的差异

        1. CommonJS模块输出的是值得复制（缓存机制），ES6输出的是值的引用
        2. CommonJS模块时运行时加载的，ES6是编译时输出接口 
        3. ES6 模块中this=undefined；CommonJS模块中this指向当前模块

        第二点：CommonJS加载的是一个对象：即module.exports属性，该对象在脚本执行结束时生成；ES6的模块不是对象，对外接口是一种静态定义，在代码静态解析时生成
        第一点：CommonJS模块内部的变化影响不到已经输出的值（原始类型值，会被缓存）
                // lib.js
                var counter = 3;
                function incCounter() {
                counter++;
                }
                module.exports = {
                counter: counter,
                incCounter: incCounter,
                };
                // main.js
                var mod = require('./lib');
                console.log(mod.counter);  // 3
                mod.incCounter();
                console.log(mod.counter); // 3

            JS引擎对脚本静态分析的时候，遇到模块加载命令import就会生成一个只读引用，等脚本执行的时候在根据引用 到被加载的模块中取值 （能反应被加载模块的内部变化）

<Q&A 175> Node加载

            有自己的CommonJS模块格式，与ES6不兼容

            分开处理：静态分析阶段，一个模块只要有一行import或export，Node就认为是ES6模块，否则是CommonJS， 如果不输出任何借口，而且是ES6 需要加上 export {}；

            如果没指定绝对路径，ES6和CommonJS的寻找顺序相同：
                import './foo';
                //依次寻找
                // ./foo.js
                // ./foo/package.json
                // ./foo/index.js

                import 'baz';
                //依次寻找
                // ./node_modules/baz.js
                // ./node_modules/baz/package.json
                // ./node_modules/baz/index.js
                //寻找上一级目录
                // ../node_modules/baz.js
                // ../node_modules/baz/package.json
                // ../node_modules/baz/index.js
                //再上一级

<Q&A 176> import加载CommonJS模块

            Node采用CommonJS，模块输出都定义在module.exports属性上，采用import加载CommonJS，Node将module.exports作为默认，等于export default

                    // b.js
                    module.exports = null;
                    
                    // es.js
                    import foo from './b';
                    // foo = null;
                    
                    import * as bar from './b';
                    // bar = { default:null };
                    上面代码中，es.js采用第二种写法时，要通过bar.default这样的写法，才能拿到module.exports。
                    // c.js
                    module.exports = function two() {
                    return 2;
                    };

                    // es.js
                    import foo from './c';
                    foo(); // 2

                    import * as bar from './c';
                    bar.default(); // 2    bar = { default: function two() {return 2;}}
                    bar(); // throws, bar is not a function
                    上面代码中，bar本身是一个对象，不能当作函数调用，只能通过bar.default调用。

                    CommonJS 模块的输出缓存机制，在 ES6 加载方式下依然有效。(不会动态改变)

                    用import加载CommonJS模块时，不能：import {readfile} from 'fs';  fs是CommonJS模块，运行时才能加载，而import命令要求在编译时就确定该接口，所以需要整体输入:
                        // 正确的写法一
                        import * as express from 'express';
                        const app = express.default();
                        
                        // 正确的写法二
                        import express from 'express';
                        const app = express();

<Q&A 177> require 加载ES6模块

        es6所有输出接口都会成为输入对象的属性, 并且存在缓存机制
            // es.mjs
            let foo = { bar: 'my-default' };
            export default foo;
            
            // cjs.js
            const es_namespace = await import('./es.mjs');  // es_namespace = { default: {bar: 'my-default'}};
            // es_namespace = {
            //   get default() {
            //     ...
            //   }
            // }
            console.log(es_namespace.default);
            // { bar:'my-default' }

<Q&A 178> 循环加载

                存在强耦合
                // a.js
                var b = require('b');

                // b.js
                var a = require('a');

<Q&A 179> CommonJS 加载原理

            CommonJS模块就是一个脚本文件，require第一次加载该脚本时会执行整个脚本，在内存中生成对象
             {
                 id: '...', //模块名
                 exports: {...}, //接口
                 loaded: true,
                 ...
             }
            在require也不会执行，直接从缓存取值（exports的属性上），之后都只是取缓存

<Q&A 180> CommonJS循环加载

              CommonJS是在加载时执行，脚本代码在require时就全部执行

<Q&A 181> ES6循环加载

            // a.mjs
            import {bar} from './b';
            console.log('a.js');
            console.log(bar);
            export let foo = 'foo';
            
            // b.mjs
            import {foo} from './a';
            console.log('b.js');
            console.log(foo);
            export let bar = 'bar';
            上面代码中，a.mjs加载b.mjs，b.mjs又加载a.mjs，构成循环加载。执行a.mjs，结果如下。
            
            $ babel-node a.js
            b.mjs
            undefined
            a.js
            bar

<Q&A 182> ES6模块转码

             很多浏览器不支持ES6，需要转码

             babel
             ES6 module transpiler：将ES6转为CommonJS或AMD模块，从而在浏览器中加载
             SystemJS：是一个垫片库（polyfill），在浏览器内加载ES6、AMD、CommonJS，将其转为ES5  后台调用Google的Traceur转码器  System.import使用异步加载，返回一个Promise对象

<Q&A 183> 表单脚本

            取表单：
                    var from = document.getElementById('form1');
                    
                    document.forms;
                    var firstForm = document.forms[0];
                    var myForm = document.forms['form2'];

            提交表单：
                    <!-- 通用提交按钮 -->
                    <input type="submit" value="Submit Form">

                    <!-- 自定义提交按钮 -->
                    <button type="submit">Submit Form</button>

                    <!-- 图像按钮 -->
                    <input type="image" src="graphic.gif">

                    textarea 在文本区回车会换行
                    以上述方式提交表单，浏览器在发送请求给服务器之前触发submit事件，于是有机会验证表单数据
                    取消表单提交 (EventUtil 跨浏览器对象)
                    <script>
                        var form = document.getElementById("myForm");
                        EventUtil.addHandler(form, "submit", function(event) {
                            event = EventUtil.getEvent(event);
                            EventUtil.preventDefault(event);
                        })
                    </script>

                    利用submit()提交表单，不会触发事件
                    var form = document.getElementById("myForm");
                    form.submit();

            重置表单：
                    type="reset"

                    每个表单都有elements属性，所有表单元素的集合（input、textarea、button、fieldset），有序列表

            禁用提交，避免多次提交
                    监听submit事件
                    btn.disabled = true;
                    不能通过onclick事件，不同浏览器处理事件顺序不同：有的先触发click，在submit
                    所以必须在submit事件禁用按钮

            共有表单
                    focus()、blur() 聚焦
                    通过监听load事件，为表单字段绑定focus()，但不能为hidden的input和display、visibility隐藏的字段设置聚焦
                    H5表单字段新增autofocus属性 autofocus = true/''
                    EvenUtil.addHandler(window, "load",function(event) {
                        var element = document.forms[0].elements[0];
                        if (element.autofocus !== true) {
                            element.focus();
                            console.log("JS focus");
                        }
                    })

            取得选中的文本
                    //selectionStart,selectionEnd属性 选中文本的起止
                    //IE8- document.selection对象
                    //H5 文本框有setSelectionRange(startIndex, endIndex)
                    var textbox = document.form[0].element["textbox1"];
                    function getSelectedText(textbox) {
                        if(textbox.selectionStart == "number") {
                            return textbox.value.substring(textbox.selectionStart, textbox.selectionEnd);
                        } esle if (document.selection){
                            return document.selection.createRange().text;
                        }
                    }
            
            屏蔽所有按键操作  //addHandler: function(element, type, handler){ // 该方法接受 3 个参数：要操作的元素，事件名称和事件处理程序函数
                    EventUtil.addHandler(textbox, "keypress", function(event) {    
                        event = EvetnUtil.getEvent(event);
                        EventUtil.preventDefault(event);
                    })

            文本框检测输入的黏贴值, 不是数字就屏蔽按键
                    EventUtil.addHandler(textbox, "paste", function(event) {
                        event = EventUtil.getEvent(event);
                        var text = EventUtil.getClipboardText(event);
                        if(!/^\d*$/.text(text)) {
                            EventUtil.preventDefault(event);
                        }
                    });

            除Opera，都支持剪贴板事件，copy、cut、paste
            Firefox chrome Safari只允许发生paste事件时获取剪贴板数据，IE随时都行


<Q&A 184> 301和302区别
<Q&A 185> 跨浏览器时间处理程序方式
        提供一个 EventUtil 对象, 可以用这个对象来处理浏览期间的差异：

        var EventUtil = {   
            addHandler: function(element, type, handler){ // 该方法接受 3 个参数：要操作的元素，事件名称和事件处理程序函数   
                if (element.addEventListener){ // 检查传入的元素是否存在 DOM2 级方法   
                    element.addEventListener(type, handler, false); // 若存在，则使用该方法   
                } else if (element.addEvent){ // 如果存在的是 IE 的方法   
                    element.attachEvent("on" + type, handler); // 则使用 IE 的方法，注意，这里的事件类型必须加上 "on" 前缀。   
                } else { // 最后一种可能是使用 DOM0 级   
                    element["on" + type] = hander;   
                }   
            },   
            
            removeHandler: function(element, type, handler){ // 该方法是删除之前添加的事件处理程序   
                if (element.removeEventListener){ // 检查传入的元素是否存在 DOM2 级方法   
                    element.removeEventListener(type, handler, false); // 若存在，则使用该方法   
                } else if (element.detachEvent){ // 如果存在的是 IE 的方法   
                    element.detachEvent("on" + type, handler); // 则使用 IE 的方法，注意，这里的事件类型必须加上 "on" 前缀。   
                } else { // 最后一种可能是使用 DOM0 及方法 (在现代浏览器中，应该不会执行这里的代码)   
                    element["on" + type] = null;   
                }   
            },

            getClipboardText: function(event) { // 获取剪切板的值
                var clipboardDtat = (event.clipboardData || window.clipboardData);
                return clipboardDtat.getData("text");
            },

            setClipboardText: function(event, value) {
                if (event.clipboardData) { // 设置剪切板的值
                    return event.clipboardData.setData("text/application", value);
                } else if (window.clipboardData) {
                    return window.clipboardData.setData("text", value);
                }
            }
        };  
        可以像下面这样使用 EventUtil 对象:
        
        var btn =document.getElementById("mybtn");   
        var hander= function(){   
            alert("clicked");   
        };   
        // 这里省略了部分代码   
        EventUtil.addHandler(btn,"click",hander);   
        // 这里省略了部分代码   
        EventUtil.removeHandler(btn,"click",hander); // 移除之前添加的事件处理程序  

<Q&A 186> H5 新增
    form属性
    input type=email/url属性  step=5属性 pattern="\d+"属性
    iframe.window./document.getSelection()

<Q&A 187> 选择框脚本

        <select name="nameSele" id="">
            <option value="">...</option>
            <option></option>
            <option></option>
        </select>
        var selectbox = document.form[0].elements["nameSele"];
        var text = selectbox.option[0].text;
        var value = selectbox.option[0].value;

        选择框的change事件，不同于其他表单，只要内容改变，就算没失去焦点也会触发
        value属性 = value特性（标签里的） ，如未设置value特性，IE8返回 '' ,其他浏览器返回 text特性

        添加选项
            var newOption  = document.createElement("option");
            newOption.appendChild(document.createTextNode("Option text"));
            newOption.setAttribute("value", "Option value");
            selectbox.appendChild(newOption);


<Q&A 188> document可以创建的几种节点

<Q&A 189> appendChild() insertBefore()

<Q&A 190> 表单序列化

        表单序列化过程中，一般不包含任何按钮字段

<Q&A 191> 表单提交期间，浏览器是怎样将数据发送给服务器的

        对表单字段名称和值进行URL编码，使用 & 分隔
        不发送禁用的表单字段
        只发送勾选的复选框和单选按钮
        不发送type=reset/button的按钮
        多选选择框的每个选中条目值单独一个条目
        单击提交按钮提交表单时，也会发送提交按钮；否则不发送提交按钮，也包括type=image的 input元素
        select的值，就是选中option元素的value特性值，如果没设置value特性，则是option的文本值


<Q&A 192> 富文本编辑 WYSIWYG

        并不属于表单

        在页面中嵌入一个包含空HTML的iframe，通过designMode属性开启编辑,页面加载完才能设置，可以使用onload事件
        编辑对象是<body>的HTML代码
            <iframe name="richedit" style="height:100px;width:100px;" src="blank.html"></iframe>
            <script>
                EventUtil.addHandler(window, "load", function() {
                    frames["richedit"].document.designMode = "on";
                });
            </script>
        
        使用contenteditable属性，可以使任何元素可编辑  true/false/inherit(继承)
        <div class="editable" id="richedit" contenteditable></div>
        var div = document.getElementById("richedit");
        div.contentEditable = "true";
        操作富文本
        document.execCommand()
        // 转换粗体,IE和Opera使用<strong>包围文本，Safari和Chrome用<b>，Firefox <span>
        frames["richedit"].document.execCommand("bold", false, null);
        // 格式化为1级标题
        frames["richedit"].document.execCommand("formatblock", false, "<h1>");
        // 更改字体大小
        frames["richedit"].document.execCommand("fontsize", false, "7");

        文本选区
          iframe.window./document.getSelection()  // 返回selection对象
          
        富文本编辑器的HTML不会自动提交给服务器
        
        对于iframe，通常添加隐藏表单字段，让他的值等于iframe的HTML，在表单提交前，从iframe中提取HTML，插入隐藏字段中
            EventUtil.addHandler(form, "submit", function(event) {
                event = EventUtil.getEvent(event);
                var target = EventUtil.getTarget(event);

                target.element["comments"].value = frames["richedit"].document.body.innerHTML; // 插到名为comments的隐藏表单字段中
            });

        对于contenteditable元素
            EventUtil.addHandler(form, "submit", function(event) {
                event = EventUtil.getEvent(event);
                var target = EvetnUtil.getTarget(event);

                target.elements["comments"].value = document.getElementById("richedit").innerHTML;
            });

<Q&A 193> /*jshint esversion: 6 */

<Q&A 194> 排序

        冒泡
            <script>
                function bubbleSort(arr) {
                    var len = arr.length;
                    for (var i = 0; i < len - 1; i++) {
                        for (var j = 0; j < len - 1 - i; j++) {
                            if (arr[j] > arr[j+1]) {        // 相邻元素两两对比
                                var temp = arr[j+1];        // 元素交换
                                arr[j+1] = arr[j];
                                arr[j] = temp;
                            }
                        }
                    }
                    return arr;
                }
            </script>
        插入
            <script>
                function insertionSort(arr) {
                    var len = arr.length;
                    var preIndex, current;
                    for (var i = 1; i < len; i++) {
                        preIndex = i - 1;
                        current = arr[i];
                        while (preIndex >= 0 && arr[preIndex] > current) {
                            arr[preIndex + 1] = arr[preIndex];
                            preIndex--;
                        }
                        arr[preIndex + 1] = current;
                    }
                    return arr;
                }
            </script>
        选择
            <script>
                function selectionSort(arr) {
                    var len = arr.length;
                    var minIndex, temp;
                    for (var i = 0; i < len - 1; i++) {
                        minIndex = i;
                        for (var j = i + 1; j < len; j++) {
                            if (arr[j] < arr[minIndex]) {     // 寻找最小的数
                                minIndex = j;                 // 将最小数的索引保存
                            }
                        }
                        temp = arr[i];
                        arr[i] = arr[minIndex];
                        arr[minIndex] = temp;
                    }
                    return arr;
                }
            </script> 
        希尔
            <script>
                function shellSort(arr) {
                    var len = arr.length;
                    for (var gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {
                        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行
                        for (var i = gap; i < len; i++) {
                            var j = i;
                            var current = arr[i];
                            while (j - gap >= 0 && current < arr[j - gap]) {
                                arr[j] = arr[j - gap];
                                j = j - gap;
                            }
                            arr[j] = current;
                        }
                    }
                    return arr;
                }
            </script>
        归并
            <script>
                function mergeSort(arr) {
                    var len = arr.length;
                    if (len < 2) {
                        return arr;
                    }
                    var middle = Math.floor(len / 2),
                        left = arr.slice(0, middle),
                        right = arr.slice(middle);
                    return merge(mergeSort(left), mergeSort(right));
                }
                
                function merge(left, right) {
                    var result = [];
                
                    while (left.length>0 && right.length>0) {
                        if (left[0] <= right[0]) {
                            result.push(left.shift());
                        } else {
                            result.push(right.shift());
                        }
                    }
                
                    while (left.length)
                        result.push(left.shift());
                
                    while (right.length)
                        result.push(right.shift());
                
                    return result;
                }
            </script>
        快速
            <script>
                function quickSort(arr, left, right) {
                    var len = arr.length,
                        partitionIndex,
                        left = typeof left != 'number' ? 0 : left,
                        right = typeof right != 'number' ? len - 1 : right;
                
                    if (left < right) {
                        partitionIndex = partition(arr, left, right);
                        quickSort(arr, left, partitionIndex-1);
                        quickSort(arr, partitionIndex+1, right);
                    }
                    return arr;
                }
                
                function partition(arr, left ,right) {     // 分区操作
                    var pivot = left,                      // 设定基准值（pivot） pivot只做记录，移动的是index 和 i，
                        index = pivot + 1;      // index记录大于基准的第一个值，将其与后面小于基准的值交换；交换一次移动到下一个大于值
                    for (var i = index; i <= right; i++) {
                        if (arr[i] < arr[pivot]) {  // 只要i记录的值小于基准，就和index交换，哪怕交换自身或另一个小于值，以便index向下移动
                            swap(arr, i, index);  
                            index++;
                        }       
                    }
                    swap(arr, pivot, index - 1);   // 基准值和最后一个小于他的值交换
                    return index-1;
                }
                
                function swap(arr, i, j) {
                    var temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }

            </script>

        堆排
            1. 从下向上调整，构建大顶堆
            2. 交换首尾元素，使最大值到最后
            3. 交换后从上向下调整剩余值，使其再满足大顶堆
            4. 重复2，3
            <script>
                var len;
                function buildMaxHeap(arr) {
                    len = arr.length();
                    for (var i = Math.floor(len/2); i >= 0; i--) {
                        heapift(arr, i);
                    }
                }

                function heapify(arr, i) {
                    left = 2*i+1;
                    right = 2*i+2;
                    largest = i;

                    if (left<len && arr[left] > arr[largest]) {
                        largest = left;
                    }
                    if (right<len && arr[right] > arr[largest]) {
                        largest = right;
                    }
                    if (largest!=i) {
                        swap(arr, i, largest);
                        heapify(arr, largest);
                    }
                }

                function swap(arr, i, largest) {
                    let temp = arr[i];
                    arr[i] = arr[largest];
                    arr[largest] = temp;
                }

                function heapSort(arr) {
                    buildMaxHeap(arr);
                    for (var i=arr.length-1;i>0;i--) {
                        swap(arr, 0, i);
                        len--;
                        heapify(arr, 0);
                    }
                    return arr;
                }
            </script>

        计数
            <script>
                function countingSort(arr, maxValue) {
                    var bucket = new Array(maxValue + 1),
                        sortedIndex = 0;
                        arrLen = arr.length,
                        bucketLen = maxValue + 1;
                
                    for (var i = 0; i < arrLen; i++) {
                        if (!bucket[arr[i]]) {
                            bucket[arr[i]] = 0;
                        }
                        bucket[arr[i]]++;
                    }
                
                    for (var j = 0; j < bucketLen; j++) {
                        while(bucket[j] > 0) {
                            arr[sortedIndex++] = j;
                            bucket[j]--;
                        }
                    }
                
                    return arr;
                }
            </script>

        桶排
            根据映射规则分到不同桶，再对每个桶排序，依次输出
        
        基排
            先按低位余数分组，再按高位余数分组，依次输出

<Q&A 195> JS事件循环机制 浏览器/Nodejs

浏览器--http://lynnelv.github.io/js-event-loop-browser

            异步背后的“靠山”就是event loops。这里的异步准确的说应该叫浏览器的event loops或者说是javaScript运行环境的event loops，
            因为ECMAScript中没有event loops，event loops是在HTML Standard定义的。

            macrotask: 主体js代码、事件回调、XHR回调、定时器(setTimeout/setInterval/setImmediate)、I/O操作、UI render
            microtask: 更新应用程序状态的任务、Promise回调、MutationObserver、process.nextTick、Object.observe

            一次事件循环的步骤包括：
                1. 检查macrotask队列是否为空，非空则到2，为空则到3
                2. 执行macrotask中的一个任务
                3. 继续检查microtask队列是否为空，若有则到4，否则到5
                4. 取出microtask中的任务执行，执行完成返回到步骤3
                5. 执行视图更新

            <script>
                console.log('start');

                setTimeout(function() {
                console.log('setTimeout')
                }, 0);

                Promise.resolve().then(function() {
                console.log('promise1');
                }).then(function() {
                console.log('promise2');
                });

                console.log('end');
                //start
                //end
                //promise1
                //promise2
                //setTimeout

                // 首先，全局代码（main()）压入调用栈执行，打印start；
                // 接下来setTimeout压入macrotask队列，promise.then回调放入microtask队列，最后执行console.log(‘end’)，打印出end；
                // 第一次事件循环：全局代码属于macrotask（加载完全局代码相当于执行过macrotask的一个任务了），macrotask执行完，那接下来就是执行microtask队列的任务了，执行promise回调打印promise1；event loop会把当前的microtask队列一直执行完，然后主线程执行UI渲染(也可能不做，和下几轮一起渲染，看浏览器设置)
                // 第二次事件循环：event loop执行setTimeout回调，microtask已空
            </script>

            渲染时机 UI render
                视图渲染发生在本轮事件循环的microtask队列执行完后，但不一定发生，可能会累积到一起重绘，重绘之前会通知requestAnimationFrame执行回调函数
                <script>
                    setTimeout(function() {console.log('timer1')}, 0)

                    requestAnimationFrame(function(){
                        console.log('requestAnimationFrame')
                    })

                    setTimeout(function() {console.log('timer2')}, 0)

                    new Promise(function executor(resolve) {
                        console.log('promise 1')
                        resolve()
                        console.log('promise 2')
                    }).then(function() {
                        console.log('promise then')
                    })

                    console.log('end')

                    // promise1                 主程 相当于第一次macrotask
                    // promise2                 主程 相当于第一次macrotask
                    // end                      主程 相当于第一次macrotask
                    // promise then             第一次 microtask，清空队列
                    // requestAnimationFrame    UI render渲染
                    // timer1                   setTimeout()，第二次macrotask
                    // timer2                   setTimeout()，第三次macrotask
                    也可能是在第二次循环之后渲染
                    // promise1                 主程 相当于第一次macrotask
                    // promise2                 主程 相当于第一次macrotask
                    // end                      主程 相当于第一次macrotask
                    // promise then             第一次 microtask，清空队列
                    // timer1                   setTimeout()，第二次macrotask
                    // requestAnimationFrame    UI render渲染
                    // timer2                   setTimeout()，第三次macrotask
                    或者在第三次之后
                    // promise1
                    // promise2
                    // end
                    // promise then
                    // timer1
                    // timer2
                    // requestAnimationFrame
                </script>

            总结
            1.事件循环是js实现异步的核心
            2.每轮事件循环分为3个步骤：
                a) 执行macrotask队列的一个任务
                b) 执行完当前microtask队列的所有任务
                c) UI render
            3.浏览器只保证requestAnimationFrame的回调在重绘之前执行，没有确定的时间，何时重绘由浏览器决定


Node.js--http://lynnelv.github.io/js-event-loop-nodejs

        Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现
        根据Node.js官方介绍，每次事件循环都包含了6个阶段，对应到 libuv 源码中的实现：
            timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调
            I/O callbacks 阶段：执行一些系统调用错误，比如网络通信的错误回调
            idle, prepare 阶段：仅node内部使用
            poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里
            check 阶段：执行 setImmediate() 的回调
            close callbacks 阶段：执行 socket 的 close 事件回调

            timers 阶段
                    timers 是事件循环的第一个阶段，Node 会去检查有无已过期的timer，如果有则把它的回调压入timer的任务队列中等待执行，
                    事实上，Node 并不能保证timer在预设时间到了就会立即执行，因为Node对timer的过期检查不一定靠谱，它会受机器上其它运行程序影响，
                    或者那个时间点主线程不空闲。比如下面的代码，setTimeout() 和 setImmediate() 的执行顺序是不确定的。
                        // setTimeout(() => {
                        //      console.log('timeout')
                        // }, 0)

                        // setImmediate(() => {
                        //     console.log('immediate')
                        // })
                    但是把它们放到一个I/O回调里面，就一定是 setImmediate() 先执行，因为poll阶段后面就是check阶段。

            poll 阶段
                    poll 阶段主要有2个功能：

                    处理 poll 队列的事件
                    当有已超时的 timer，执行它的回调函数
                    even loop将同步执行poll队列里的回调，直到队列为空或执行的回调达到系统上限（上限具体多少未详），接下来even loop会去检查有无预设的setImmediate()，分两种情况：

                    若有预设的setImmediate(), event loop将结束poll阶段进入check阶段，并执行check阶段的任务队列
                    若没有预设的setImmediate()，event loop将阻塞在该阶段等待

                    注意一个细节，没有setImmediate()会导致event loop阻塞在poll阶段，这样之前设置的timer岂不是执行不了了？所以咧，在poll阶段event loop会有一个检查机制，
                    检查timer队列是否为空，如果timer队列非空，event loop就开始下一轮事件循环，即重新进入到timer阶段。

            check 阶段
                    setImmediate()的回调会被加入check队列中

        小结
            event loop 的每个阶段都有一个任务队列
            当 event loop 到达某个阶段时，将执行该阶段的任务队列，直到队列清空或执行的回调达到系统上限后，才会转入下一个阶段
            当所有阶段被顺序执行一次后，称 event loop 完成了一个 tick

        浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。
        Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。

            // setTimeout(()=>{
            //     console.log('timer1')
            //     Promise.resolve().then(function() {
            //         console.log('promise1')
            //     })
            // }, 0)

            // setTimeout(()=>{
            //     console.log('timer2')
            //     Promise.resolve().then(function() {
            //         console.log('promise2')
            //     })
            // }, 0)
            
            在浏览器的结果就是下面这个了，道理都懂，就不累述了。

                timer1
                promise1
                timer2
                promise2

            那么Node下执行看看，跟浏览器的运行结果并不一样~

                timer1
                timer2
                promise1
                promise2

        Nodejs    
            首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；
            至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2。

            来自官方文档有意思的一句话，从语义角度看，setImmediate() 应该比 process.nextTick() 先执行才对，而事实相反，命名是历史原因也很难再变。

        process.nextTick() VS setImmediate()
            process.nextTick() 会在各个事件阶段之间执行，一旦执行，要直到nextTick队列被清空，才会进入到下一个事件阶段，
            所以如果递归调用 process.nextTick()，会导致出现I/O starving（饥饿）的问题：

            嵌套调用的 setImmediate() 回调，被排到了下一次event loop才执行，所以不会出现阻塞。

        总结
            Node.js 的事件循环分为6个阶段
            浏览器和Node 环境下，microtask 任务队列的执行时机不同
            Node.js中，microtask 在事件循环的各个阶段之间执行
            浏览器端，microtask 在事件循环的 macrotask 执行完之后执行
            递归的调用process.nextTick()会导致I/O starving，官方推荐使用setImmediate()


<Q&A 196> Browser 进程与浏览器内核的通信过程

        1.Browser 进程收到用户请求，通过网络下载获取页面内容，将该任务内容通过 RenderHost 接口传递给 Render 进程
        2.Render 进程收到请求，简单解释后交给 GUI 渲染进程开始渲染
            GUI 渲染进程接受请求开始加载并渲染网页，并且在此过程中可能需要 Browser 进程获取资源和需要 GPU 进程帮助渲染
            期间也可能会有 JS 引擎线程操作 DOM，可能引起重绘（repainting）或回流（reflow）
            Render 进程最后将结果通过 RenderHost 接口返回给 Browser 进程
        3.Browser 进程接受结果并将其绘制到屏幕上

        通常情况下，一张网页中的DOMContentLoaded（即ready）事件（当DOM加载完成，不包括样式表，图片，事件触发）要比load事件（DOM，样式表，脚本，图片都已经加载完成了）先发生
        CSS是由单独的下载线程异步下载的，不会阻塞 DOM 树的解析，但会阻止 render 树的渲染

<Q&A 197> http1.0 和 http1.1 区别

        http1.0 每次请求都建立一个新的tcp链接，每次链接只处理一次请求，完成就断开，每个页面需要独立建立链接，浏览器未关闭前，链接便会断开。无法做状态链接控制，浪费带宽，链接断开耗时。
                没有host字段(一台主机可能有多个vm共享ip)
        http1.1 支持长连接，允许每次连接中发送多次请求和响应，请求和响应之间可以重叠，不必等待上次请求的响应，一个页面中的图像和文本请求可以在一个连接中完成，但每个页面仍独立建立链接
                Connection=keep-alive/close，还增加了身份验证、cache缓存机制和状态管理相关的字段

        由于HTTP 1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。
        在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。
                

<Q&A 198> Socket连接与HTTP连接

        由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网 络应用中，
        客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，
        因此需要通过轮询告诉网络，该连接处于活跃状态。

        而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。

        很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数 据传送给客户端；
        若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求， 不仅可以保持在线，
        同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。TCP(Transmission Control Protocol)　传输控制协议

        TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:

        位码即tcp标志位,有6种标示:SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)
        Sequence number(顺序号码) Acknowledge number(确认号码)

<Q&A 199> 浏览器渲染页面的过程
        从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：
            1.DNS 查询
            2.TCP 连接
            3.HTTP 请求即响应
            4.服务器响应
            5.客户端渲染

        浏览器对内容的渲染:
            1.处理 HTML 标记并构建 DOM 树。
            2.处理 CSS 标记并构建 CSSOM 树。
            3.将 DOM 与 CSSOM 合并成一个渲染树。
            4.根据渲染树来布局，以计算每个节点的几何信息。
            5.将各个节点绘制到屏幕上。

<Q&A 200> 阻塞渲染：CSS 与 JavaScript

        谈论资源的阻塞时，我们要清楚，现代浏览器总是并行加载资源。例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。

        同时，由于下面两点：
        1.默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。
        2.JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。
        
        存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外：
        1.当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。
        2.JavaScript 可以查询和修改 DOM 与 CSSOM。
        3.CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。

        所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：
        1.CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。
        2.JavaScript 应尽量少影响 DOM 的构建。

        HTML 和 CSS 都是阻塞渲染的资源

        CSS: 最容易想到的当然是精简 CSS 并尽快提供它。除此之外，还可以用媒体类型（media type）和媒体查询（media query）来解除对渲染的阻塞。

            <link href="index.css" rel="stylesheet">
            <link href="print.css" rel="stylesheet" media="print">
            <link href="other.css" rel="stylesheet" media="(min-width: 30em) and (orientation: landscape)">
            第一个资源会加载并阻塞。
            第二个资源设置了媒体类型，会加载但不会阻塞，print 声明只在打印网页时使用。
            第三个资源提供了媒体查询，会在符合条件时阻塞渲染。

        defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），
             会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。
        async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后。需要注意的是，
             这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。

        注意 async 与 defer 属性对于 inline-script 都是无效的



<Q&A 201> 1秒呈现首屏

            DNS查询和TCP链接：300ms
            HTTP请求和响应：300ms
            server响应：200ms
            Client-side Rendering：200ms

            服务器必须在200毫秒内呈现响应内容
            尽可能减少重定向次数
            尽可能减少首次呈现内容所需的网络往返次数 通过新连接进行首次往返的过程中，服务器最多只能发送 10 个 TCP 数据包（约 14KB），然后必须等待客户端确认已收到这些数据，才能增大拥塞窗口并继续发送更多数据。
            避免在首屏内容中包含会阻止内容呈现的外部 JavaScript 和 CSS
            为浏览器布局和呈现预留时间（200 毫秒）
            优化 JavaScript 的执行及呈现用时

<Q&A 202> Polyfill
    
    Polyfill的准确意思为：用于实现浏览器并不支持的原生API的代码。
    例如，querySelectorAll是很多现代浏览器都支持的原生Web API，但是有些古老的浏览器并不支持，那么假设有人写了库，只要用了这个库， 你就可以在古老的浏览器里面使用document.querySelectorAll，
    使用方法跟现代浏览器原生API无异。那么这个库就可以称为Polyfill或者Polyfiller。

<Q&A 203> JavaScript 异常和 promise

        当 promise 被明确拒绝时，会发生拒绝；但是如果是在构造函数回调中引发的错误，则会隐式拒绝：
        <script>
            var jsonPromise = new Promise(function(resolve, reject) {
                // JSON.parse throws an error if you feed it some
                // invalid JSON, so this implicitly rejects:
                resolve(JSON.parse("This ain't JSON"));  // 字符串不是json，parse()会抛错，这个错也会被Promise捕获
            });
            
            jsonPromise.then(function(data) {
                // This never happens:
                console.log("It worked!", data);
            }).catch(function(err) {
                // Instead, this happens:
                console.log("It failed!", err);
            })
        </script>
        这意味着，在 promise 构造函数回调内部执行所有与 promise 相关的任务很有用，因为错误会自动捕获并进而拒绝。
        




<Q&A 204> HTML页面加载和解析流程 

        1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件； 
        2. 浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件； 
        3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件； 
        4. 浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了； 
        5. 浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； 
        6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； 
        7. 浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它； 
        8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码； 
        9. 终于等到了＜/html＞的到来，浏览器泪流满面…… 
        10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径； 
        11. 浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。

<Q&A 205> js css

        内联js一般放在/body前，外部js文件一般放在<body>dom主内容后面</body>，避免加载时间太长影响内容呈现，也可以放在header里，需要添加async属性，实现外部js文件和dom异步，js文件加载完就阻塞dom解析，立即执行

<Q&A 206> 编写CSS时应该注意：

        CSS选择符是从右到左进行匹配的。从右到左！所以，#nav li 我们以为这是一条很简单的规则，秒秒钟就能匹配到想要的元素，但是，但是，但是，是从右往左匹配啊，所以，会去找所有的li，然后再去确定它的父元素是不是#nav。
        因此，写css的时候需要注意：
        
        dom深度尽量浅。
        减少inline javascript、css的数量。
        使用现代合法的css属性。
        不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。
        避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;#tp p{} 子选择符：#tp>p{}
        避免使用通配符，举一个例子，.mod .hd *{font-size:14px;} 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知.

<Q&A 207> z-index GPU线程渲染时 加速 整合各层 composite  CSS3加速

<Q&A 208> web socket / socket

        socket 是位于应用层和传输层之间的一层抽象出来的编程接口，继承tcp/ip api 方便调用
        web socket是h5 新增的支持 持久化长连接 的传输协议，基于http，需要http先握手，服务器升级协议后可以主动推送信息
        
        请求
            GET /chat HTTP/1.1
            Host: server.example.com
            Upgrade: websocket  // 告诉Apache、Nginx等服务器请求时WebSocket协议
            Connection: Upgrade
            Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==   // 一个Base64 encode的值，验证服务器是不是WebSocket助理
            Sec-WebSocket-Protocol: chat, superchat   // 用户定义的字符串，用来区分同URL下，不同的服务所需要的协议
            Sec-WebSocket-Version: 13    //Websocket Draft（协议版本）
            Origin: http://example.com

        响应
            HTTP/1.1 101 Switching Protocols
            Upgrade: websocket
            Connection: Upgrade
            Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=  // 服务器 ID CARD
            Sec-WebSocket-Protocol: chat
        
        
        http1.0 一次链接 一个request 一个response
        http1.1 一次链接 多个request 多个response  可以不用等上次request返回，但还是被动一对一， 增加了keep-alive字段
        ajax轮询：浏览器隔几秒请求一次，并返回相应 （需要服务器有很快的处理速度和资源）
        http long poll：阻塞式轮询 请求过后，没内容就不返回，一直等有更新才返回  （需要有很高的并发，也就是说同时接待客户的能力）

        http是无状态协议，需要重复验证用户
        我们所用的程序是要经过两层代理的，即HTTP协议在Nginx等服务器的解析下，然后再传送给相应的Handler（PHP等）来处理。

<Q&A 209> git

        git clone git@github.com:kanlidy/hellogit.git  //从远程仓库下载代码
        git status   //查看当前 分支和提交状态
        git branch -a  //查看远程和本地所有分支
        touch test.txt //创建文件 
        git add .   //使所有文件处于待提交状态
        git commit -m "初次提交"  //提交并备注
        git push origin master  //将提交的文件推送到远程默认的主干分支上, 只有提交的文件才能push到远程
        //一般是创建新分支，分支确定后再和主干分支合并
        git checkout -b dev    //创建新分支 'dev'
        git push origin dev    //将本地 dev 分支下的文件推送到远程 dev 分支上 （此处省略了本地分支名称）
        git checkout master    //切换到本地 master分支上
        git merge dev     //将本地 dev 分支合并到 当前分支上
        git branch -D dev   //删除本地 dev 分支
        git push origin :dev   //删除远程 dev 分支 （将本地空内容推送到远程dev分支上）
        git reset --hard head^  //退回前一个版本 
        git log/reflog  //查看之前提交版本

 
<Q&A 210> vue 组件状态管理

        父组件向子组件通信传输数据没问题，但子组件向父组件传输需要 $emit() 触发，组件间通信也有问题，所以引入了状态绑定(管理) -- vuex

        组件状态集中管理

        vuex 一般放在 store.js 中
        <script>
            import Vue from 'vue'
            import Vuex from 'vuex'

            Vue.use(Vuex) // 引用vuex

            export default new Vuex.Store({
                state: {
                    count: 0 // 各组件共享的状态，通过改变state里的状态，实现组件状态管理
                },
                mutations: { // 组件改变上述状态的方法集
                    increase () {
                    this.state.count++
                    }
                },
                actions: {

                }
            })
        </script>
        
        组件内使用 vuex 前，先引入store

        页面组件 A.vue 通过 store.commit()利用 mutations 中的方法 改变 vuex 中 count 的状态
        <template>
            <div class="info">
                hello info component
                <button type="button" @click="add()">添加</button>
            </div>
        </template>
        <script>
            import store from '@/store' // 引入store
            export default {
                name: 'Info', // 缩进两个空格！！！ string用单引号
                store,
                mounted () { // vue生命周期，组件挂载完执行该方法
                window.vue = this
                },
                methods: {
                add () {
                    console.log('add Event from Info!')
                    debugger // 暂停进入debug模式
                    store.commit('increase') // 各组件通过commit向 中央管理store（vuex） 提交申请，利用 increase方法改变 state里的状态
                }
                }
            }
        </script>

        页面组件 B.vue  通过 store.state.count 获取 组件 A 传递的 count 状态
        <template>
            <div class="about">
                <h1>This is an about page</h1>
                <p>{{msg}}</p>
            </div>
        </template>
              
        <script>
            import store from '@/store'
            export default {
                name: 'about',
                store,
                data () {
                    return {
                    msg: store.state.count
                    }
                }
            }
        </script>

        

<Q&A 211> requireJS

    对业务 js重新进行模块定义，减轻文件加载   按模块划分 加载 增加可读性  异步请求

<Q&A 212> jquery

        和vue一样，并不是一种框架，只是提供了一些事件操作、DOM API、函数库

        基于DOM操作的函数库，封装了ajax异步请求、JSONP请求
        事件处理，dom节点查找，文本操作、class添加
        map() filter()

<Q&A 213> vue 实现双向数据绑定的本质 

    通过 MVVM 的数据绑定实现自动同步：
                                    View(DOM) --> ViewModel(Vue) --> Model(POJO-原生JS对象)
                                    View(DOM) <-- ViewModel(Vue) <-- Model(POJO-原生JS对象)
                                    
                                    用户修改DOM元素后，会被ViewModel监听到，ViewModel修改模型层的数据，然后ViewModel拼装后再改 View

    本质：创建全局对象 obj， 通过defineProperty()扩展属性，利用get()将用户操作页面产生的数据变化和 obj 绑定到一起，利用set()将 obj的变化和页面{{}}绑定到一起

        双向绑定--数据驱动
    
    步骤：
         1.定义全局对象 obj
         2.通过Object.defineProperty() 扩展属性
         3.利用 defineProperty 内置的 get() 获取用户对页面操作的 数据变化
         4.利用 defineProperty 内置的 set() 将 obj 的变化 反映到 页面上
    
    使用js操作DOM也可以在全局 obj对象上绑定属性，为什么 vue 要使用 Object.defineProperty() ？？？？

    <input type="text" id="userName">
    <span id="uName"></span>
    <script>
        var obj = {} // 创建全局对象
        Object.defineProperty(obj, "userName", { //为 obj 扩展 userName 属性，用来保存 用户操作 产生的数据
            get: function () { // get方法中 监听 html 标签的变化，用户对页面的操作产生 事件， 将事件传递的数据 绑定到全局 obj 对象的属性上
                console.log("get init");
            },
            set: function (val) { // obj 变化会自动触发 set 方法，再方法内部可以把数据 重新 反应到页面上，实现双向绑定 不需要再监听 keyup事件
                console.log("set init");
                document.getElementById("uName").innerText = val;  // defineProperty()具有的 get/set方法可以自动监听 obj属性值的变化，可以在方法内将该变化 (数据) 反映到页面上，实现双向绑定
                document.getElementById("userName").value = val;
            }
        });
        
        // document.getElementById("userName").addEventListener("keyup", function (e) {obj.userName = e.target.value;});
    </script>
    
    Object.defineProperty() 具有 get和set 方法，get可以获取页面数据变化，绑定到obj上，set能自动监听 obj 上属性的值的变化，将变化显示到页面，不需要设置监听事件

<Q&A 214> AMD、CMD、commonJS、es6


<Q&A 215> 前端路由的 优缺点：

    用户体验好，不需要每次从服务器全部获取，快速展示  看似10张页面，实际一次加载，其余9张由前端组合

    不利于SEO，组合的页面没法被搜索引擎收录
    浏览器前进后退，会重新发送请求， 以前的页面都是 服务端 实实在在的页面，会缓存在浏览器，但现在SPA的页面不会缓存
    无法记住滚动条的位置

<Q&A 216> vue  router
    
        route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部的对象，可以获取对应的name,path,params,query等
        $route.params.name 当前url的参数 name    
        this.$router.push('/url') 路由到 url

        $route.query.  不同页面之间跳转，获取拼接的url的参数  query 是页面跳转的参数 如编程路由的goodsId：this.$router.push({path:'/cart?goodsId=123'})
        $route.params.   父子组件间 获取url 的参数  params 是页面的路由参数 如router.js里的cartId： routes: [{path: '/cart/:cartId'}]

        js实现路由：
                    this.$router.push({path:'/cart/123?goodsId=345'})
        router.js：
                    routes: [
                        {
                            path: '/cart/:cartId'
                        }
                    ]
        // 123 就是 :cartId , 页面的路由参数，由$route.params.cartId 获取
        // ? 后面的 goodsId=345 就是 页面的挑战参数，由$route.query.goodsId 获取
        // router.js里path需要注明路由参数 占位，不需要 跳转参数

<Q&A 217> vue3.0 和 vue2.0

        3.0 新加入了 TypeScript 以及 PWA 的支持 
        部分命令发生了变化：
           · 下载安装  npm install -g vue@cli
           · 删除了vue list
           · 创建项目   vue create
           · 启动项目   npm run serve
        默认项目目录结构也发生了变化：
           · 移除了配置文件目录，config 和 build 文件夹
           · 移除了 static 文件夹，新增 public 文件夹，并且 index.html 移动到 public 中
           · 在 src 文件夹中新增了 views 文件夹，用于分类 视图组件 和 公共组件    

    vue-cli3.0默认项目目录与2.0的相比，更精简:
        1.移除的配置文件根目录下的，build和config等目录，
        2.移除了static文件夹，新增了public文件夹，并且index.html移动到public中。
        3.在src文件夹中新增了views文件夹，用于分类 试图组件 和 公共组件 。
        4.大部分配置 都集成到 vue.config.js这里,在项目根目录下

<Q&A 218> python 二进制实现加法

        # -*- coding:utf-8 -*-
        class Solution:
            def Add(self, num1, num2):
                MAX = 0x7FFFFFFF # 除了第一位符号位，其余全是1，表示最大的整形数 int， F 1111
                MIN = 0x80000000 # 符号位 为 1 ，表负，
                mask = 0xFFFFFFFF # 全 1
                while num2 != 0:
                    num1, num2 = (num1 ^ num2), ((num1 & num2) << 1)
                    num1 = num1 & mask
                    num2 = num2 & mask # 这句可有可无
                return num1 if num1 <= MAX else ~(num1 ^ mask) # 大于MAX 符号位为 1 表示负值 ; ~ 按位取反。在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。补码： 正数原值，负数 包括符号位 取反 后 +1
        
        if __name__ == "__main__":
            num1 = -1
            num2 = -9
            print(Solution().Add(num1, num2))

<Q&A 219> Promise 回调函数中 如果需要用this 回调用 箭头函数

        <script>
                new Vue({
                    data() {
                        return {
                            msg: ''
                        }
                    },
                    mounted() { // 全局拦截器
                        
                    },
                    methods: {
                        get() { // axios 直接挂载在 Window上 不像vue-resource挂载 Vue实例上
                            axios.get('./../package1.json', {
                                params: {
                                    userId: 'jack'
                                },
                                headers: {
                                    token: 'ljavocpreagovaehw0[f012rer'
                                }
                            }).then(res=>{ // Promise 回调中 如果需要使用 this.变量 ，回调函数要用 箭头函数， 箭头函数的 this 指向外层，不要用 function(res) { } 格式
                                this.msg = res.data;
                                console.log(res.data);
                            }).catch(error=>{
                                this.msg = error;
                                console.warn('error init.');
                            });
                        },
                        post() {  // 405 方法禁用 ？
                            
                        },
                        http() {
                           
                        }
                    }
                }).$mount('#app')
            </script>

<Q&A 220> vue 3.0 resource和axios post方法405

        响应头中 Allow字段 允许的请求方法没有post  后台不允许？？？

        post、put、delete请求会修改后台数据，需要后台的处理逻辑，向后台发送数据后，需要后台进行逻辑处理，然后返回结果，
        实验中没有服务端，所以不能接受post的数据，无法处理post请求的逻辑
	
        方法：在vue.config.js中模拟服务端的数据处理逻辑
        
        vue笔记（四）------vue-cli3.0开发请求本地模拟数据的配置方法
        来自 <https://www.jianshu.com/p/f561c8425f7f> 

<Q&A 221> 那么axios这个是什么呢？
    
    是一个国外友人开发的基于Promise 用于浏览器和 nodejs 的 HTTP 客户端。它有什么用法呢：

        从浏览器中创建 XMLHttpRequest
        从 node.js 发出 http 请求
        支持 Promise API
        拦截请求和响应
        转换请求和响应数据
        取消请求
        自动转换JSON数据
        客户端支持防止 [CSRF/XSRF](http://baike.baidu.com/link?*url=iUceAfgyfJOacUtjPgT4ifaSOxDULAc_MzcLEOTySflAn5iLlHfMGsZMtthBm5sK4y6skrSvJ1HOO2qKtV1ej_)
        
<Q&A 222> cookie的path和domain属性

    path 默认 '/'
    domain 默认 生成cookie时的域名

    1.domain表示的是cookie所在的域，默认为请求的地址，如网址为www.test.com/test/test.aspx，那么domain默认为www.test.com。
    而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；
    如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。

    2.path表示cookie所在的目录，asp.net默认为/，就是根目录。在同一个服务器上有目录如下：/test/,/test/cd/,/test/dd/，
    现设一个cookie1的path为/test/，cookie2的path为/test/cd/，那么test下的所有页面都可以访问到cookie1，而/test/和/test/dd/的子页面不能访问cookie2。
    这是因为cookie能让其path路径下的页面访问。

    3.浏览器会将domain和path都相同的cookie保存在一个文件里，cookie间用*隔开。

    4.含值键值对的cookie：以前一直用的是nam=value单键值对的cookie，一说到含多个子键值对的就蒙了。现在总算弄清楚了。
    含多个子键值对的cookie格式是name=key1=value1&key2=value2。可以理解为单键值对的值保存一个自定义的多键值字符串，
    其中的键值对分割符为&，当然可以自定义一个分隔符，但用asp.net获取时是以&为分割符。

<Q&A 223> 闭包 看OneNote

        这种内部函数的作用域链仍然保持着对父函数活动对象的引用，就是闭包(closure)

        闭包有两个作用： 
                        第一个就是可以读取自身函数外部的变量（沿着作用域链寻找） 
                        第二个就是让这些外部变量始终保存在内存中 

        <script>
            function outer(){
                var result = new Array();
                for(var i = 0; i < 2; i++){
                    //定义一个带参函数
                    function arg(num){
                        function innerarg(){
                        return num;
                        }
                        return innerarg;  // 初始化innerarg作用域链
                    }
                    //把i当成参数传进去
                    result[i] = arg(i);
                }
                return result;
            }
            var fn = outer();
            console.log(fn[0]());
            console.log(fn[1]());
        
        // 写法二：
            function outer(){
                var result = new Array();
                for(var i = 0; i < 2; i++){
                //定义一个带参函数
                result[i] = function(num){
                    function innerarg(){
                        return num;
                    }
                    return innerarg;
                }(i);//预先执行函数写法
                //把i当成参数传进去
                }
                return result;
            }

        </script>


                          

<Q&A 224> vue 组件通信

        vue 中 只允许数据从父组件流向子组件，不允许子组件修改父组件变量，避免双向绑定导致变量混乱

        SPA中 都是 局部组件 

        父组件向子组件通信传输数据 通过 Props
        子组件向父组件传输需要 $emit() 触发
        组件间通信也有问题

        父组件
        <template>
            <div class="hello">
                <h1>{{ msg }}</h1>
                <!-- 子组件，在父组件内绑定 num 的默认，传递给 子组件，子组件操作 num值，不会影响 父组件内的 num-->
                <!-- 父 -> 子：v-bind：obj + props：obj   子 -> 父：v-on：methods + $emit(mthods) -->
                <Counter v-bind:num="num" v-on:incre="increament" v-on:decre="decreament"></Counter> 
                <p>parent: {{num}}</p>
            </div>
        </template>
              
        <script>
            import Counter from './Counter' //从当前文件目录下引入子组件--component
            export default {
                name: 'HelloWorld',
                data() {
                    return {
                    num: 10
                    }
                },
                props: {
                    msg: String
                },
                components: {
                    Counter  //注册子组件
                },
                methods: {
                    increament () {
                        this.num++;
                    },
                    decreament () {
                        this.num--;
                    }
                }
            }
        </script>

        子组件
        <template>
            <div class="counter">
                <button @click="increament">+</button>
                <button @click="decreament">-</button>
                <p><span>{{num}}</span></p>    
            </div>
        </template>
              
        <script>
            export default {
                name: 'Counter',
                props: {
                    num: Number //从父组件 向子组件通信， Hello 传递过来num 的默认值需要用到  props 属性
                },  
                data() {
                        return {
                        num: 0
                    }
                },
                methods: {
                    increament () {
                        this.$emit('incre'); //从子组件 向父组件通信， 需要 $emit() 触发 父组件中v-on绑定的方法， 改变父组件的变量，其改变又会流向子组件
                    },
                    decreament () {
                        this.$emit('decre');
                    }
                }
            }
        </script>

 
<Q&A 225> vue hook

        一种事件劫持机制，也就是说它会比你的事件更早进行执行处理。

        你可以简单地把它理解为vue的内置事件，但是这个内置事件是由你去配置的。（vue实例中定义的 事件：匿名方法）

        特别值得注意的是created钩子函数和mounted钩子函数的区别
        每个钩子函数都在啥时间触发
        beforeCreate
        在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。
        created
        实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。
        beforeMount
        在挂载开始之前被调用：相关的 render 函数首次被调用。
        mounted
        el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。
        beforeUpdate
        数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。
        updated
        由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。
        当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。
        该钩子在服务器端渲染期间不被调用。
        beforeDestroy
        实例销毁之前调用。在这一步，实例仍然完全可用。
        destroyed
        Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。

        beforeCreate 、 created 、 beforeUpdate 、 beforeDestroy 是在“捕获”过程中调用的；
        mounted 、 updated 、 destroyed 是在“冒泡”过程中调用的。

        在初始化流程、 update 流程和销毁流程中，子级的相应声明周期方法都是在父级相应周期方法之间调用的。
        比如子级的初始化钩子函数（ beforeCreate 、 created 、 mounted ）都是在父级的 created 和 mounted 之间调用的，
        这实际上说明等到子级准备好了，父级才会将自己挂载到上一层 DOM 树中去，从而保证界面上不会闪现脏数据。

<Q&A 226> css布局之文档流，定位与浮动

        网页的布局方式就是浏览器如何对网页中的元素进行排版。
        主要分为：文档流，定位，浮动。

        文档流：
                文档流是文档中可显示对象在排列时所占用的位置。
                将窗体自上而下分成一行行显示，并在每行中按从左到右的顺序排放元素的效果，就是文档流直观的表现。可分为：块级元素与内联元素。
                脱离文档流的方式：float、position：absolute/fixed。

                在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，
                除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。

        定位：
            position属性：把元素放置到一个静态的、相对的、绝对的、或固定的位置中。

            static，position的默认值。没有定位，元素出现在正常的文档流中。
            
            relative(相对定位）仍占据文档流中的位置
            生成相对定位的元素，相对于其正常（原来）位置进行定位。元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。可以微调，不影响其他。top,bottom,left,right的值确定定位元素的位置。

            absolute（绝对定位）
            生成绝对定位的元素，相对最近的一个position不为static的祖先元素进行偏移。不占据文档流的位置。经常用来布局。top,bottom,left,right的值确定定位元素的位置。

            fixed （固定定位）
            生成绝对定位的元素，相对于浏览器窗口进行定位。top,bottom,left,right的值确定定位元素的位置。可以做对话框或者悬浮广告。

            z-index
            z-index指定了一个元素及其子元素的 z-order，元素之间有重叠的时候，z-index可以决定让哪一个元素在上方。通常来说 z-index 较大的元素会覆盖较小的一个。仅对定位的元素有效。
            元素之间重叠默认的顺序是后面的元素会盖住前面的元素。如果设置了z-index可以改变这个顺序。但只对同级的元素有效。父元素永远在子元素后面。
        
        浮动：
            浮动由属性值float来体现，通过浮动可以解决图文混排的问题。浮动是脱离文档流的。清除浮动指的是：在非IE浏览器（如Firefox）下，当容器的高度为auto,
            且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响布局的现象，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。
            
        清除浮动的方式：

            1.clear：both或left或rihgt

                clear有三个属性值分别是both\left\right。写了这个样式的div或者其他标签的两边\左边\右边 就不能有浮动的元素。（只能清楚clear前面的浮动，不管clear后面的浮动。）
                （div的高度是它里面整个文档流的高度，元素加上clear：both后，能让它在所有浮动元素的下面。）
                优点：简单，代码少，浏览器兼容性好。
                缺点：需要添加无语义的html元素，代码不够优雅，后期不容易维护

            2.after（伪类）
            
                伪类原理：相当于在父元素里添加一个子元素（默认内联元素），用来清除容器内的浮动元素。
                .parent::after{
                    content:'';
                    display:block;
                    clear:both;
                }
                优点：兼容性好，稳定。
                缺点：代码多

            3.clearfix（类）

                这是第二种方法的升级版，是用在文章有很多浮动时，你不需要每一个都编辑一次去除浮动。
                .clearfix:after{ // 在需要清除浮动的容器上添加 class="clearfix"
                    content:'';
                    display:block;
                    clear:both;
                }
                优点：方便快捷
                缺点：IE6不支持，css比较多

            4.overflow：hidden
            
                利用overflow触发BFC。在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘），即使存在浮动也是如此。
                优点：只用1个属性，代码少。
                缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。


<Q&A 227> CSS position z-index 层叠上下文

        当元素设置position为absolute,relative或者fixed,它们的层叠顺序大于position为static的。

        absolute 定位是相对于 static 定位以外的第一个父元素进行定位

        使用z-index的元素必须是positioned，设置元素层级。
        
        子元素要看设置层叠上下文的父元素的脸色行事

        层叠顺序的因素：

                        html元素的排列顺序
                        display与float
                        position
                        z-index的使用
                        层叠上下文的产生

        position有三种策略：

        　　1. normal －对象根据它在文档的中位置定位，这意味着它在渲染树和在Dom树中位置一致，并根据它的盒模型和大小进行布局。
        
        　　2. float －对象先像普通流一样布局，然后尽可能的向左或是向右移动。
        
        　　3. absolute －对象在渲染树中的位置和Dom树中位置无关。
        
        　　static和relative是normal，absolute和fixed属于absolute。
        
        　　在static定位中，不定义位置而使用默认的位置。其他策略中，作者指定位置——top、bottom、left、right。

        Absolute和Fixed
        　　这种情况下的布局完全不顾普通的文档流，元素不属于文档流的一部分，大小取决于容器。
            Fixed时，容器为viewport（可视区域--窗口）。
            元素相对于可视区域重新定位，不在乎html DOM中的位置，如 postition: absolute;top:5px,left:5px display:inline-block 此时display失效
            注意－fixed即使在文档流滚动时也不会移动。

        Floats
        　　一个浮动的box移动到一行的最左边或是最右边，其余的box围绕在它周围。

        Layered representation
　　        这个由CSS属性中的z-index指定，表示盒模型的第三个大小，即在z轴上的位置，（即堆叠顺序，谁上谁下）
            Box分发到堆栈中（称为堆栈上下文），每个堆栈中靠后的元素将被较早绘制，栈顶靠前的元素离用户最近，
            当发生交叠时，将隐藏靠后的元素。堆栈根据z-index属性排序，拥有z-index属性的box形成了一个局部堆栈，viewport有外部堆栈

<Q&A 228> 设置float浮动会导致父元素高度坍塌

        塌陷：父元素只包含浮动元素，那么它的高度就会塌缩为零（前提就是没有设置高度height属性,或者设置了为auto就会出现这种情况，当然不是所用的浏览器都是这样的，在IE8下面没有这种情况。）
        如果父元素不包含任何的可见背景，这个问题会很难被注意到，但是这是一个很重要的问题。
        
        解决办法：

                1.在使用浮动的元素后面加一个div，属性设置为style="clear: both" 优点：通俗易懂，容易掌握 缺点：将添加很多无意义的空标签，有违结构与表现的分离

                2.在使用浮动元素的父级容器加属性overflow:hidden 优点：不存在结构和语义化问题，代码量极少 缺点：overflow:hidden 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素； overflow:auto多层嵌套后，firefox与IE 可能会出现显示错误；

                3.父元素设置display: table 优点：结构语义化完全正确，代码量极少 缺点：盒模型属性已经改变，由此造成的一系列问题，得不偿失

                4、给父级容器加一个class="clearfix"

                .clearfix:after {
                    display:block; 
                    content:"clear"; 
                    clear:both; 
                    line-height:0;
                    visibility:hidden;
                }
                    (1) display:block使生成的元素以块级元素显示,占满剩余空间;

                    (2) height:0避免生成内容破坏原有布局的高度。

                    (3) visibility:hidden使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;

                    (4) 通过content:""生成内容作为最后一个元素，至于content里面是点还是其他都是可以的

                    (5) zoom:1触发IE hasLayout。

                通过分析发现，除了clear:both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size:0，line-height：0

        主要分三种：
                html方式：增加额外的标签，并添加clear：both样式
                CSS方式：为父元素添加overflow：hidden
                伪类方式：在容器(父元素)后面增加伪类，并设高度为0不可见
                        #container:after {  
                            content: ".";  
                            display: block;  
                            height: 0;  
                            clear: both;  
                            visibility: hidden;  
                        }  
            

<Q&A 229> 圣杯 双飞翼

        区别：
                圣杯布局是中间栏为两边腾开位置。（通过padding和margin）
                双飞翼布局则是中间栏不变，将内容部分为两边腾开位置（中间main增加子main，设置子main的margin左右宽度，不能修改中间main的margin，因为width就已经占满一行）

             圣杯：两边固定宽度的两栏会挡住中间栏的内容，需要padding和margin调整中间栏
             双飞翼：需要改造HTML结构
                    <header>双飞翼布局</header>
                        <div class="bd">
                            <div class="main text">
                                <div class="main-content">main</div>
                            </div>
                            <div class="left text">
                                left
                            </div>
                            <div class="right text">
                                right
                            </div>
                        </div>
                    <footer>footer</footer>

                    可以看到，我们在main里面又加了一个内容层。如果知道盒子模型，就知道我们是不能直接给main添加margin属性，因为我们已经设置了width：100%，
                    再设置margin的话就会超过窗口的宽度，所以我们再创造一个内容层，将所有要显示的内容放到main-content中，给main-content设置margin就可以了。
                    
                    因为不改变父元素所以只需要给main-content设置margin: 0 200px 0 200px;属性就可以了达到效果



<Q&A 230> position:relative和负margin都可以使元素位置发生偏移?二者有什么区别?
        
       · 负margin会使元素在文档流中的位置发生偏移，它会放弃偏移之前占据的空间，紧挨其后的元素会填充这部分空间；
        
       · 相对定位后元素位置发生偏移，它仍会坚守原来占据的空间，不会让文档流的其他元素流入。
        
<Q&A 231> 如何让一个固定宽高的元素在页面上垂直水平居中?

    绝对定位 和 负margin
        *{margin:0;padding:0;}
        .box{
          width:100px;
          height:100px;
          background: #000;
          position: absolute;
          left:50%;
          top:50%;
          margin-top:-50px;
          margin-left:-50px;
        }

<Q&A 232> 负 margin

        不使用float的话，负margin元素是不会破坏页面的文档流。所以如果你使用负margin上移一个元素，所有跟随的元素都会被上移。

        当static元素的margin-top/margin-left被赋予负值时，元素将被拉进指定的方向。

        但如果你设置margin-bottom/right为负数，元素并不会如你所想的那样向下/右移动，而是将后续的元素拖拉进来，覆盖本来的元素。

        如果没有设定width属性，设定负margin-left/right会将元素拖向对应的方向，并增加宽度，此时的margin的作用就像padding一样。

        如果给一个浮动元素加上相反方向的负margin，则会使行间距为0且内容重叠。这对于创建1列是100%宽度而其他列是固定宽度（比如100px）的自适应布局来说是非常有用的方法。

        如果负margin等于实际宽度，则元素会被完全覆盖。这是因为元素的完全宽度等于margin，padding，border，width相加而成，所以如果负margin等于余下三者的和，那元素的实际宽度也就变成了0px。

        链接无法点击;
        文字难以选中；
        失去焦点后，tab任何链接都会消失；
        解决方法：给元素添加position:relative，便能正常运行！


<Q&A 233> BFC

        
        Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，
        并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。

    二、BFC 概念
                BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。

                具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。


    三、触发 BFC
                只要元素满足下面任一条件即可触发 BFC 特性：

                                · body 根元素
                                · 浮动元素：float 除 none 以外的值
                                · 绝对定位元素：position (absolute、fixed)
                                · display 为 inline-block、table-cells、flex
                                · overflow 除了 visible 以外的值 (hidden、auto、scroll)

    四、BFC 特性及应用

                        1. 同一个 BFC 下外边距会发生折叠
                        
                        从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠， 
                        所以两个盒子之间距离只有 100px，而不是 200px。如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。

                        2. BFC 可以包含浮动的元素（清除浮动）

                        浮动的元素会脱离普通文档流, 由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。


<Q&A 234> Vue 文档

        声明式渲染
                    {{}}： 绑定文本和data中的数据
                    v-bind： 绑定元素属性 和 data数据
        
        条件与循环
                    v-if="seen"
                    v-for="todo in todos"
        处理用户输入
                    v-on:click="reverseMessage"
                    <input v-model="message"> // 实现表单输入和应用状态之间的双向绑定(Object.defineProperty)

<Q&A 235> setTimeout 

        js: setTimeout setInteral 在任务队列尾部添加事件，等同步任务和任务队列现有任务全部执行完才开始
        Node.js： 
                process.nextTick 可以在当前"执行栈"的尾部----下一次Event Loop（主线程读取"任务队列"）之前----触发回调函数。它指定的任务总是发生在所有异步任务之前
                setImmediate  是在当前"任务队列"的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行

<Q&A 236> JS ajax
    <script>
        //步骤一:创建异步对象
        var ajax = new XMLHttpRequest();
        //步骤二:设置请求的url参数,参数一是请求的类型,参数二是请求的url,可以带参数,动态的传递参数starName到服务端
        ajax.open('get','getStar.php?starName='+name);
        //步骤三:发送请求
        ajax.send();
        //步骤四:注册事件 onreadystatechange 状态改变就会调用
        ajax.onreadystatechange = function () {
        if (ajax.readyState==4 &&ajax.status==200) {
            //步骤五 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的
        　　　　console.log(ajax.responseText);//输入相应的内容
        　　}
        }
    </script>
        
<Q&A 237> JS 预编译
        js预编译实现过程：
        
        1.js首先扫描var关键字，提前到顶端；
        
        2.然后扫描function定义，提到var之后
        
        3.然后再顺序执行

<Q&A 238> JS bind 实现
        <script>
            if (!Function.prototype.bind) {
                Function.prototype.bind = function () {
                    var self = this,                        // 保存原函数
                        context = [].shift.call(arguments), // 保存需要绑定的this上下文
                        args = [].slice.call(arguments);    // 剩余的参数转为数组
                    return function () {                    // 返回一个新函数
                        self.apply(context,[].concat.call(args, [].slice.call(arguments)));
                    }
                }
            }
            
            Function.prototype.bind = function (...arg) {
                var self = this;
                    var newArr = [...arg];         // 保存原函数
                var context = newArr.shift(); // 保存需要绑定的this上下文
                return function (...arg2) {
                            var arr = [...newArr];  
                            Array.prototype.push.apply(arr,arg2)
                            self.apply(context,arr);
                }
            }
        </script>

<Q&A 239> 懒加载
    <script>
        /**
        * offsetTop 返回当前元素相对于其 offsetParent 元素的顶部的距离
        * window.innerHeight 浏览器窗口的视口（viewport）高度（以像素为单位）；如果有水平滚动条，也包括滚动条高度。
        * window.pageYOffset 只读属性 是 scrollY 的别名。
        * scrollY 返回文档在垂直方向已滚动的像素值。
        */
       let lazyImages = [...document.querySelectorAll('.lazy-image')]
       let inAdvance = 300 // 自定义一个高度，当距离300px到达图片时加载
       
       function lazyLoad() {
           lazyImages.forEach(image => {
               if (image.offsetTop < window.innerHeight + window.pageYOffset + inAdvance) { // 距离xxpx时加载图片
                   image.src = image.dataset.src
                   image.onload = () => image.classList.add('loaded')
               }
           })
       
           // if all loaded removeEventListener
       }
       
       lazyLoad()
       
       window.addEventListener('scroll', _.throttle(lazyLoad, 16)) // 用到了lodash的节流函数
       window.addEventListener('resize', _.throttle(lazyLoad, 16))
    </script>

<Q&A 240> promise 实现

    <script>
        class PromiseClone {
            constructor (process) {
                this.status = 'pending';
                this.msg = '';
                process(this.resolve.bind(this), this.reject.bind(this));
                return this;
            }
            resolve (val) {
                this.status = 'fulfilled';
                this.msg = val;
            }
            reject (err) {
                this.status = 'rejected';
                this.msg = err
            }
            then (fufilled, reject) {
                if (this.status === 'fulfilled') {
                    fulfilled(this.msg);
                }
                if (this.status === 'rejected') {
                    reject(this.msg);
                }
            }
        }
    </script>

<Q&A 241> js 发布/订阅模式

    观察者模式： subject-observer
        目标事件改变，通知观察者： subject --> observer
        观察者需要直接订阅目标事件： observer --> subject

    发布/订阅模式： 发布者 -- 调度中心 -- 订阅者
        发布相关事件： 发布者 --> 调度中心
        从发布者接收事件，向订阅者发布事件： 发布者 --> 调度中心 <-- 订阅者
        从事件通道注册想订阅的事件： 订阅者 --> 调度中心

    <script>
        const event = {
            clientList: [],
            listen: function(key, fn) {
                if (this.clientListen[key]) {
                    this.clientList[key] = []
                }
                this.clientList[key].push(fn)
            },
            trigger: function() {
                const key = Array.prototype.shift.call(arguments)
                const fns = this.clientList[key]
                if ( !fns || fns.length === 0 ) {
                    return false
                }
                for (let i = 0, fn; fn = fns[i++];) {
                    fn.apply(this, arguments)
                }
            },
            remove: function(key, fn) {
                const fns = this.clientList[key]
                if (!fns) {
                    return false
                }
                if (!fn) {
                    fns && (fns.length = 0)
                } else {
                    for (let l = fns.length - 1; l>=0; l--) {
                        const _fn = fns[l]
                        if (_fn === fn) {
                            fns.splice(l, 1)
                        }
                    }
                }
            }
        }
        
        const installEvent = (obj) => {
            for (let i in event) {
                obj[i] = event[i]
            }
        }
    </script>
    
<Q&A 242> JSONP

    JSONP是通过动态 <script> 元素来使用的，使用时可以为 src 属性指定一个跨域URL。这里的 <script> 元素与 <img> 元素类似，都有能力不受限制地从其他域加载资源。
    因为JSONP是有效的JavaScript代码，所以在请求完成后，即在JSONP响应加载到页面中以后，就会立即执行。

    JSONP之所以在开发人员中极为流行，主要原因是它非常简单易用。与图像Ping相比，它的优点在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。不过，JSONP也有不足。

    首先，JSONP是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃JSONP调用之外，没有办法追究。
    因此在使用不是你自己运维的Web服务时，一定得保证它安全可靠。

    <script>
        var script = document.createElement('script');
        script.type = 'text/javascript';
      
        // 传参并指定回调执行函数为onBack
        script.src = 'http://www.domain-com:8080/login?user=admin&callback=onBack';
        document.head.appendChild(script);
      
        // 回调执行函数
        function onBack(res) {
            alert(JSON.stringify(res));
        }
    </script>
      
<Q&A 243> JS 获取url参数

    <script>
        function getQueryString(name) { 
            var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i"); 
            var r = window.location.search.substr(1).match(reg); // window.location 有关文档当前位置信息  .search 匹配url中的 ？
            if (r != null) return unescape(r[2]); return null;  // 不要使用unescape去解码URLS，使用decodeURI替代。
        }
        // 或
        export function getQueryStringByStr(data) {
            const url = data; // 获取url中"?"符后的字串
            const theRequest = {};
            if (url.indexOf('?') !== -1) {
                const str = url.substr(1);
                const strs = str.split('&');
                for (let i = 0; i < strs.length; i += 1) {
                theRequest[strs[i].split('=')[0]] = unescape(strs[i].split('=')[1]);
                }
            }
            return theRequest;
        }
    </script>
        
<Q&A 244> vue-router 实现与解析

<Q&A 245> diff 算法

<Q&A 246> 浏览器引擎工作流程

    解析html绘制DOM树 --> 加载解析CSS创建style rules --> 绘制Render树 --> 布局 layout 计算各组件在屏幕上的位置和大小 --> 渲染painting

<Q&A 247> why diff　虚拟DOM

        【传统DOM操作(eg:innerHtml)】：render html+重建所有DOM元素
        【虚拟DOM】：render 虚拟DOM + diff算法+更新必要的DOM元素

        浏览器引擎工作流程大致分为： 解析HTML绘制DOM tree  加载CSS构建Style Rules  绘制Render tree  布局Layout计算各组件在屏幕上的位置和大小  渲染painting

        render执行的结果得到的并不是真正的DOM节点，而仅仅是javascript对象，称之为虚拟DOM

        利用js原生api和jQuery等修改DOM时，浏览器会从构建DOM开始执行一边完整的流程。例如在一次操作中需要修改10个DOM节点，最好的方式是一次性完成DOM的构建，
        然后再进行后续操作。但浏览器没那么zhi能，无法预知后续的9次修改，收到第一次更新请求后就立即执行流程，所以会连续执行10次完整的流程。显然像计算DOM节点坐标值都是白白浪费性能，当前一次DOM更新后，
        后续的节点坐标便会发生变。
        即使计算机硬件一直更迭，操作DOM仍然是非常昂贵的，频繁操作仍会出现页面卡顿，影响用户体验，真实的DOM节点，即使一个div也包含很多属性。
        虚拟DOM就是为了解决这个浏览器性能问题而提出的。如果一次操作中包含10更新DOM，虚拟DOM不会直接操作DOM，而是先将10次更新的diff内容保存到本地的一个js对象中，最后将js对象一次性attach到DOM树上，
        再通知浏览器去执行绘制工作，从而节省大量计算工作。
    
        虚拟DOM就是在DOM的基础上在内存建立一个抽象层，所有针对数据和状态的任何改动，都会被自动且高效的同步到虚拟DOM上，最后在批量同步到DOM中。
    
        工作原理：
        React会在内存中维护一个虚拟DOM，当数据变化时，React会自动更新虚拟DOM，比较新的虚拟DOM和旧的虚拟DOM的不同，得出一个diff，然后将diff放到队列中，最后批量更新diff到DOM上
        优点：DOM上的修改只是部分变更，渲染高效，提高网页性能
        缺点：首次渲染大量DOM时，多了一层虚拟DOM的计算，比innerHtml慢

        对虚拟DOM的理解往往停留在：通过JavaScript对象模拟原生DOM，加上DOM Diff 极大提升了DOM操作的性能。然而，虚拟DOM最大的意义不在于性能的提升（JavaScript对象比DOM对象性能高），
        而在于抽象了DOM的具体实现（对DOM进行了一层抽象），这在浏览器中使用 React时不是特别明显，因为写的DOM标签跟原生的没有区别，并且最终都被渲染成了DOM，在React Native中将会有很好的说明。

        diff算法
        <script>
            let result = [];
            // 比较叶子节点
            const diffLeafs = function (beforeLeaf, afterLeaf) {
                // 获取较大节点树的长度
                let count = Math.max(beforeLeaf.children.length, afterLeaf.children.length);
                // 循环遍历
                for (let i = 0; i < count; i++) {
                    const beforeTag = beforeLeaf.children[i];
                    const afterTag = afterLeaf.children[i];
                    // 添加 afterTag 节点
                    if (beforeTag === undefined) {
                        result.push({ type: "add", element: afterTag });
                        // 删除 beforeTag 节点
                    } else if (afterTag === undefined) {
                        result.push({ type: "remove", element: beforeTag });
                        // 节点名改变时，删除 beforeTag 节点，添加 afterTag 节点
                    } else if (beforeTag.tagName !== afterTag.tagName) {
                        result.push({ type: "remove", element: beforeTag });
                        result.push({ type: "add", element: afterTag });
                        // 节点不变而内容改变时，改变节点
                    } else if (beforeTag.innerHTML !== afterTag.innerHTML) {
                        if (beforeTag.children.length === 0) {
                            result.push({
                                type: "changed",
                                beforeElement: beforeTag,
                                afterElement: afterTag,
                                html: afterTag.innerHTML
                            });
                        } else {
                            // 递归比较
                            diffLeafs(beforeTag, afterTag);
                        }
                    }
                }
                return result;
            }
        </script>
    
<Q&A 248> CSS

        无限旋转
    <style>
        @keyframes rotate{
            0%{
                transform: rotate(0);
              }
            50%{
                transform:rotate(200deg);
            }
            100%{
                 transform: rotate(0);
                }
            }
         
        .rotate{
            transition: 0.5s;
            transform-origin: 30px 30px;  
            animation: rotate 10s linear infinite;  /*开始动画后无限循环，用来控制rotate*/
        }
    </style>

<Q&A 249> 卡牌翻转
    <style>
        .wutai{
            position: relative;
            perspective: 800px;
            width: 220px;
            height: 292px;
            transform-style: preserve-3d;
        }
        #trans{
            position: absolute;
            width: 100%;
            height: 100%;
            transition: all 1s;
            transform-style: preserve-3d;
        }
                .back{transform: rotateY(180deg);}
                .flip{transform: rotateY(180deg);}
    </style>

<Q&A 250> HTTPS和HTTP的区别主要如下：

    1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
    
    2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
    
    3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
    
    4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
    
<Q&A 251> https 缺点

    （1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；

    （2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；
    
    （3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。
    
    （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。
    
    （5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，
        特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。
        
<Q&A 252> http option请求方法

        1、获取服务器支持的HTTP请求方法；

        2、用来检查服务器的性能。
        
        其实在正式跨域之前，浏览器会根据需要发起一次预检（也就是option请求），用来让服务端返回允许的方法（如get、post），被跨域访问的Origin（来源或者域），还有是否需要Credentials(认证信息)等。
        
<Q&A 253> TCP与UDP的区别

        1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接
        
        2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付
        3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
        UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
        5、TCP首部开销20字节;UDP的首部开销小，只有8个字节
        
        6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
        
<Q&A 254> http2.0 vs http1.0

        HTTP/2采用二进制格式而非文本格式(二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。)
        HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行
        使用报头压缩，HTTP/2降低了开销
        HTTP/2让服务器可以将响应主动“推送”到客户端缓存中

<Q&A 255> 
    
        位运算 NOT 由否定号（~）表示，它是 ECMAScript 中为数不多的与二进制算术有关的运算符之一。

        位运算 NOT 是三步的处理过程：
        
            把运算数转换成 32 位数字
            
            把二进制数转换成它的二进制反码（0->1, 1->0）
            
            把二进制数转换成浮点数
        
        简单的理解，对任一数值 x 进行按位非操作的结果为 -(x + 1)
        
        console.log('~null: ', ~null);       // => -1
        console.log('~undefined: ', ~undefined);  // => -1
        console.log('~0: ', ~0);          // => -1
        console.log('~{}: ', ~{});         // => -1
        console.log('~[]: ', ~[]);         // => -1
        console.log('~(1/0): ', ~(1/0));      // => -1
        console.log('~false: ', ~false);      // => -1
        console.log('~true: ', ~true);       // => -2
        console.log('~1.2543: ', ~1.2543);     // => -2
        console.log('~4.9: ', ~4.9);       // => -5
        console.log('~(-2.999): ', ~(-2.999));   // => 1

        那么, ~~x就为 -(-(x+1) + 1)

        console.log('~~null: ', ~~null);       // => 0
        console.log('~~undefined: ', ~~undefined);  // => 0
        console.log('~~0: ', ~~0);          // => 0
        console.log('~~{}: ', ~~{});         // => 0
        console.log('~~[]: ', ~~[]);         // => 0
        console.log('~~(1/0): ', ~~(1/0));      // => 0
        console.log('~~false: ', ~~false);      // => 0
        console.log('~~true: ', ~~true);       // => 1
        console.log('~~1.2543: ', ~~1.2543);     // => 1
        console.log('~~4.9: ', ~~4.9);       // => 4
        console.log('~~(-2.999): ', ~~(-2.999));   // => -2

<Q&A 256> 回文

    <script>
        function palindrome(str) {
            var newstr = str.replace(/[^0-9a-z]/gi, "");
            newstr = newstr.toLowerCase();
            for (var i=0, j=newstr.length-1;i<j;i++,j--) {
                if (newstr.charAt(i) !== newstr.charAt(j)) {
                    return false;
                }
            }
            return true;
        }
    </script>

<Q&A 257> 节流函数

    <script>
        function throttle(method,delay,duration){
            var timer=null;
            var begin=new Date();    
            return function(){                
                var context=this, args=arguments;
                var current=new Date();        
                clearTimeout(timer);
                if(current-begin>=duration){
                    method.apply(context,args);
                    begin=current;
                }else{
                    timer=setTimeout(function(){
                        method.apply(context,args);
                    },delay);
                }
            }
        }

        // 函数消抖
        function debounce(method,context){
            clearTimeout(method.tId);
            method.tId=setTimeout(function(){
                method.call(context)
            },300)
        }
        function debounce(method,delay){
            var timer = null; 
            return function(){
                var context = this,args = arguments;
                clearTimeout(timer); 
                timer = setTimeout(function(){
                    method.apply(context,args); 
                },delay);
            }
        }

        const throttle = (method, delay, duration) => {
            const date = new Date();
            let timer = null;
            return function (...arg){
                const current = new Date();
                clearTimeOut(timer);
                if(current - data >= duration){
                    method.apply(this, arg);
                    date = current;
                }
                timer = setTimeOut(() => {
                    method.apply(this, arg);
                }, delay)
            }
        }

    </script>

<Q&A 258> IndexOf的实现

    <script>
        function ArrayIndexOf(arr,value,n){ // 从 索引n 开始向后查找
            var i=isNaN(n)?0:n;//有第三参时
                i=(i<0)?arr.length+i:i;//第三参为负数时
            for(i;i<arr.length;i++){
                if(arr[i]===value){return i;}                   
            }return -1;
        }
    </script>
        
<Q&A 259> 响应式设计、自适应设计

    响应式：网站能兼容多个终端，不需要多个版本
    自适应：网页自适应显示在不同大小终端设备上，需要多个不同版本的页面适配不同终端

    不同点：
           · 比较直观的不同是：自适应：需要开发多套界面；响应式开发一套界面
           · 自适应设计 通过检测视口分辨率，来判断当前访问的设备是：pc端、平板、手机，从而请求服务层，返回不同的页面；
             响应式设计通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。
           · 自适应 对页面做的屏幕适配是在一定范围：比如pc端（>1024）一套适配,平板（768-1024）一套适配，手机端（<768）一套适配;>
             响应式一套页面全部适配。（可以想象：响应式设计要考虑的内容要比自适应设计复杂的多）

            Adaptive design (自适应设计实现原理)：是为不同类别的设备建立不同的网页，检测到设备分辨率大小后调用相应的网页。在app横行的当下，
            目前国内自适应布局应用主要集中在视口已经很稳定的web端，（web端视口大数据[2016]）针对笔记本，台式机进行优化体验。

            响应式设计（Responsive design）是一套界面同时运行到pc端、平板、手机端各个不同的视口。通过检测设备的分辨率，来对页面做出不同的布局和内容。

    响应式优缺点和标志
        标志
            · 面包屑菜单
            · 改变浏览器宽度会在不同分辨率下显示不同的布局
        优点：
            · 面对不同分辨率设备灵活性强
            · 能够快捷解决多设备显示适应问题
        缺点：
            · 仅适用布局、信息、框架并不复杂的部门类型网站
            · 兼容各种设备工作量大，效率低下
            · 代码累赘，会出现隐藏无用的元素，加载时间加长
            · 其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果
            · 一定程度上改变了网站原有的布局结构，会出现用户混淆的情况

    自适应网站优缺点和标志
        标志：
            · 大多只是适配单个终端的主流N个主流视口（2-3个）
            · 当视口大小低于设置的最小视口时，界面会出现显示不全，溢出，并出现横向滑动指示器（主要出现在pc端，移动端决不允许出现这种情况）
            · 总体框架不变，横线布局的板块大多会有所减少
        优点：
            · 对网站的复杂程度兼容性更大
            · 实施起来代价更低，
            · 代码更高效
            · 测试更容易，运营相对更精准（图片可控性更高）
        缺点：
            · 在移动端设计大行其道之下，同一个网站，往往需要为不同的设备开发不同的页面，增加开发成本
            · 当需求改变时，可能会改动多套代码。流程繁琐。

    服务于设计和 开发

            理论上来说，响应式布局在任何情况下都比自适应布局好一些，但在某些情况下自适应布局更切实际。
            
            自适应布局可以让你的设计更加可控，因为你只需要考虑几种状态就万事大吉了。
            
            但在响应式布局中你可能需要面对非常多状态——是的，大部分状态之间的区别很小，但它们又的确是不同的，这样一来就很难确切搞清你的设计会是什么样。
            
            同时这也带来了测试上的难题，你很难有绝对的把握预测到它会怎样。

<Q&A 260> vue 组件通信 全

        https://juejin.im/post/5c776ee4f265da2da53edfad

    全局注册：
        可用在任意模板中，但webpack会打包进去，无论用没用
        <script>
            // install.js  插件用来注册组件
            import Icon from './Icon.vue'
            const install = {
                install: function(Vue) {
                    Vue.component('VIcon', Icon);
                }
            };
            export default install;

            // main.js
            import install from './install.js';
            Vue.use(install); // 利用install插件注册Icon组件,install.js里就Vue.component()有用
            //可以不用插件注册组件 直接在 main.js中注册
            import Icon from './Icon.vue'
            Vue.component('Icon', Icon)
            <icon></icon> // 所有组件都可用 必须小写
        </script>

    局部注册：
        需要的模板中注册
        <script>
            import VIcon from './Icon.vue';
            export default{
                component: {
                    VIcon
                }
            }

            <v-icon></v-icon>
        </script>

    页面组件：我们使用 Vue 时，每个路由代表的页面，都可以称之为组件。
    基础组件：就像上面栗子中的 Icon 组件，就是一个典型的基础组件。基本上不掺杂业务逻辑，在项目中可能被大量使用，
             易于移植。类似的基础组件还有 Button、Input 等，常见于各类 UI 组件库。
    业务组件：业务组件和项目具体的业务逻辑有大量耦合，一般抽离于当前项目。
    
    组件通信：
        
        1. Props
            父组件传值给子组件
            <script>
                Vue.component('blog-post', {
                // 在 JavaScript 中是 camelCase 的
                props: ['postTitle'],
                template: '<h3>{{ postTitle }}</h3>'
                })
            </script>

            <!-- 在 HTML 中是 kebab-case 的 -->
            <blog-post post-title="hello!"></blog-post>

            给 prop 传入一个静态的值：
            <blog-post title="My journey with Vue"></blog-post>

            通过 v-bind 动态赋值：
            <!-- 动态赋予一个变量的值 -->
            <blog-post v-bind:title="post.title"></blog-post>

            <!-- 动态赋予一个复杂表达式的值 `v-bind` 来告诉 Vue这是一个 JavaScript 表达式而不是一个字符串-->
            <blog-post
            v-bind:title="post.title + ' by ' + post.author.name"
            ></blog-post>
            
            所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，
            但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。
            每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。

            两种常见的试图改变一个 prop 的情形：
                这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，
                最好定义一个本地的 data 属性并将这个 prop 用作其初始值：
                props: ['initialCounter'],
                data: function () {
                    return {
                        counter: this.initialCounter
                    }
                }
                这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性：
                props: ['size'],
                computed: {
                    normalizedSize: function () {
                        return this.size.trim().toLowerCase()
                    }
                }

            <JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。>
            
            验证Props
            <script>
                Vue.component('my-component', {
                    props: {
                        // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
                        propA: Number,
                        // 多个可能的类型
                        propB: [String, Number],
                        // 必填的字符串
                        propC: {
                            type: String,
                            required: true
                        },
                        // 带有默认值的数字
                        propD: {
                            type: Number,
                            default: 100
                        },
                        // 带有默认值的对象
                        propE: {
                            type: Object,
                            // 对象或数组默认值必须从一个工厂函数获取
                            default: function () {
                                return { message: 'hello' }
                            }
                        },
                        // 自定义验证函数
                        propF: {
                            validator: function (value) {
                                // 这个值必须匹配下列字符串中的一个
                                return ['success', 'warning', 'danger'].indexOf(value) !== -1
                            }
                        }
                    }
                })
            </script>
            
            <script>
                // communication.vue
                <communication-sub v-bind="dataProps"></communication-sub>
                // v-bind="dataProps" 等同于 :title="title", 适用于多个参数一起传递
                ...
                data() {
                    return {
                        dataProps: {
                            title: '父组件的值',
                        }
                    }
                }

                // communication-sub.vue
                <div class="communication-sub">
                    {{title}}
                </div>
                ...
                props: ['title']
                //推荐开启类型检查
                props: {
                    title: {
                        type: String,
                        required: true,
                        default: '' //允许默认值
                    } 
                }
            </script>

             Vue 推荐需要改动的时候，通过改变父组件的值从而触发 Props 的响应。或者,在接收非引用类型的值时，使用子组件自身的 data 做一次接收。

             // communication-sub.vue
             <div class="communication-sub">
                 {{text}}
             </div>
             ...
            <script>
                props: { // 类型检查模式，不用 props:['title']
                    title: {
                        type: String,
                        required: true,
                        default: '' //允许默认值
                    } 
                },
                data: function() {
                    return {
                        text: this.title
                    };
                }
            </script>

            javascript中，应用类型的赋值，是内存地址的传递，所以需要深拷贝
            
            <script>
                let obj = JSON.parse(JSON.stringify(obj)); // 函数、undefined、循环引用无法序列化
            </script>
            
            在组件上绑定的属性，如果没有在组件内部用 Props 声明，会默认绑定到子组件中的html根元素上去。inheritAttrs: false 可以取消继承关系

                // communication.vue
                <communication-sub v-bind="dataProps" class="one" type="div"></communication-sub>
            结果：
                // 页面中生成的子组件标签。 因为sub只有一个div，所以这里type="div"属性没有在sub中的 Props 里声明，其实是绑定在sub根元素上的
                <div data-v-449162b3 class="communication-sub one" type="div">父组件的值</div>  
                
            这是 Vue 默认处理的，class和style合并，其他属性会替换根元素上的属性值。并且 inheritAttrs不会影响 class和style 的绑定，下面关闭 inheritAttrs：

                // communication-sub.vue
                <div class="communication-sub">
                    {{text}}
                </div>
                ...
                <script>
                    inheritAttrs: false,
                    props: {
                        title: {
                            type: String,
                            required: true,
                            default: '' //允许默认值
                        } 
                    },
                    data: function() {
                        return {
                            text: this.title
                        };
                    }
                </script>

                // communication.vue
                <communication-sub v-bind="dataProps" class="one" type="div"></communication-sub>
            结果：
                // 页面中生成的子组件标签。由于显示关闭了inheritAttrs，而且 sub中的Props没有声明type，所以type="div"属性消失了，而class不受影响
                <div data-v-449162b3 class="communication-sub one">父组件的值</div>

            关闭 inheritAttrs， 但在子组件 Props 里声明 type：
                
                // communication-sub.vue
                <div class="communication-sub" :type="typ">
                    {{text}}
                </div>
                ...
                <script>
                        inheritAttrs: false,
                        props: {
                            title: {
                                type: String,
                                required: true,
                                default: '' //允许默认值
                            },
                            type: {
                                type: String,
                                required: true,
                                default: '' //允许默认值
                            }
                        },
                        data: function() {
                            return {
                                text: this.title,
                                typ: this.type  // 将从父组件拿到的 type值绑定到子组件 位置
                            };
                        }
                    </script>

                // communication.vue
                <communication-sub v-bind="dataProps" class="one" type="div"></communication-sub>
            结果：
                // 页面中生成的子组件标签。这次type="div"属性并不是绑在sub根元素上，而是我们具体指定的元素上（不过这里指定的div其实就是根元素 =。=，因为sub里就一个div）
                <div data-v-449162b3 type="div" class="communication-sub one">父组件的值</div>

        2. attrs、listeners
            
                在开启inheritAttrs后，如果要绑定属性到子组件 指定 元素上，就会很麻烦：
                在子组件 Props 中声明 然后data中再赋值到 指定 位置
                而$attrs可以解决

                // communication.vue
                <template>
                    <div class="communication">
                        <communication-sub v-bind="dataProps" class="input" type="text" placeholder="请输入内容">
                        </communication-sub>
                    </div>
                </template>
                <script>
                import communicationSub from './communication-sub.vue';
                export default{
                    name: 'communication',
                    data() {
                        return {
                            dataProps: {
                                title: '我是 communication 的值',
                            }
                        }
                    },
                    components: {
                        communicationSub
                    }
                }
                </script>

                // communication-sub.vue
                ···
                <div class="communication-sub">
                    <input v-bind="$attrs" v-model="title"></input> // $attrs等于dataProps，获取具体属性 $attrs.xxx (注意，title并不是Porps里的特性)； 这里v-model="title" == :title="title"
                </div>
                ···
                export default {
                    inheritAttrs: false
                }
            
            实际渲染出的结果：
                // 虽然子组件中关闭了 inheriAttrs，但Props声明 并data赋值，而type属性依旧成功绑定到 input 元素上，而没有绑到根元素div上， 
                <div class="communication-sub input">
                    <input type="text" placeholder="请输入内容" title="我是 communication 的值">
                </div>
                // class 和 style 属性不受 inheritAttrs 影响，所以依然可以绑在 div上
                // $attrs 则是将没有被组件内部 Props 声明的传值（也叫非 Props 特性）收集起来的一个对象，再通过 v-bind 将其绑定在指定元素上。
                // 这也是 Element 等组件库采用的策略。
                // 这里为 type placeholder title 指定的元素是 sub中 input ，所以最后绑在 input上
            
            $attrs 可以将非Props属性绑定到 指定 元素上，但是不会与该元素原有属性发生合并或替换，而以原有属性为准

            假如在上述communication-sub.vue中 input 里 添加 type="password"
                <input v-bind="$attrs" v-model="title" type="password"></input>
            则不会采用 $attrs 中的 type: 'text'，将以 password 为准，所以如果需要默认值的属性，建议不要用这种方式。

            $listeners同 $attrs 类似，可以看做是一个包含了组件上所有事件监听器（包括自定义事件、不包括.native修饰的事件）的对象。它也支持上述的写法，适用于将事件安放于组件内指定元素上。
             通过$listeners将聚焦事件绑定给input
                // communication.vue
                <communication-sub v-bind="dataProps" class="input" type="text" placeholder="请输入" @focus="onFocus"></communication-sub>
                <script>
                    ...
                    methods: {
                        onFocus() {
                            console.log('onFocus');
                        }
                    }
                </script>

                // communication-sub.vue
                <input v-bind="$attrs" v-model="title" v-on="$listeners"></input>
            
            其他应用：
                创建更高层次组件，如祖孙组件中传递数据，在孙子组件中触发事件后在祖辈中作相应更新

                // communication.vue
                <template>
                    <div class="communication">
                        ------------------------------------.------------------------------------
                        <p>me, commuication</p>
                        <input type="text" :placeholder="dataProps.title" v-model="dataProps.title">
                        <communication-sub 
                            v-bind="dataProps" 
                            @click="onCommunicationClick">
                        </communication-sub>
                        ------------------------------------.------------------------------------
                    </div>
                </template>
                <script>
                import communicationSub from './communication-sub.vue'
                export default {
                    name: "communication",
                    data() {
                        return {
                            dataProps: {
                                title: "value/communication"
                            }
                        }
                    },
                    components: {
                        communicationSub
                    },
                    methods: {
                        onCommunicationClick() {
                            this.dataProps.title='me, vaule after click'
                        }
                    }
                }
                </script>
                    
                // communication-sub.vue
                <template>
                    <div class="communication-sub">
                        ------------------------------------..------------------------------------
                        <p>me, commuication-sub</p>
                        <input v-bind:placeholder="$attrs.title" />
                        <communication-min-sub v-on="$listeners"></communication-min-sub>
                        ------------------------------------..------------------------------------
                    </div>    
                </template>
                
                <script>
                import CommunicationMinSub from './communication-min-sub'
                export default {
                    name: "communication-sub",
                    inheritAttrs: false,
                    components: {
                        CommunicationMinSub
                    }
                }
                </script>
                    
                    
                // communication-min-sub.vue
                <template>
                    <div class="commuication-min-sub">
                        ------------------------------------...------------------------------------
                        <p>me, commuication-min-sub</p>
                        <button v-on="$listeners">click</button>
                        <br>
                        ------------------------------------...------------------------------------
                    </div>
                </template>
                <script>
                export default {
                    name: "commuication-min-sub",
                    inheritAttrs: false
                }
                </script>
                    
                祖组件input的值和dataProps通过v-model绑定，dataProps并通过$attrs.title传递到父组件的input上，并且不需要 props和data()    
                孙子组件通过$listeners将click的事件绑定到父组件在祖组件中使用的标签上@click="onCommunicationClick"，并调用祖组件中定义的方法
                父组件也可以在自己的Vue里的input上设置v-on="$listeners"，绑定到自己的标签上的处理函数，然后在祖组件中定义该处理函数
                但父和孙的$listeners 调用会相互触发，(可能因为触发事件 @xx 都绑在祖组件中的父组件标签上)


            $attrs实质就是：
                        $attrs 就是将没有被组件内部 Props 声明的传值（也叫非 Props 特性）收集起来的一个对象
                        通过 $attrs将父组件vue里子孙标签 v-bind绑定的父组件数据dataProps 传到到 指定 的子孙组件上，标签上新增的属性也会传递，就属性以原值为准
                        从而达到父组件向 指定 子孙组件传值的效果
                        （形式就是在父组件data()中定义需要传给子孙组件的数据,同时在导入的子孙标签上绑定数据 v-bind="dataProps"。指定的子孙组件通过 v-bind="$attrs" 接受传来的值）

            $listeners实质就是：
                        $listeners就是包含了父组件上所有事件监听器（包括自定义事件、不包括.native修饰的事件）的对象。
                        通过 $listeners 将父组件的事件监听器安放到 指定 的子孙组件上，通过子孙组件的事件触发父组件中的处理函数，修改父组件流向子孙组件的数据，
                        从而达到 指定 子孙组件 ‘向父组件传信息并反馈自身’ 的效果
                        （形式就是在父组件导入的子孙标签上设置事件监听器 @click="onClick"，同时定义处理函数。指定的子孙组件中通过 v-on="$listeners" 接受传来的监听器）

        3. 依赖注入provide、inject
            可以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。--- Vue 文档
            Vue 本身并不推荐直接在业务中使用 provide、inject，一般在组件、插件库用到的比较多。

            // communication.vue
            <template>
                <div class="communication">
                    <p>me, commuication</p>
                    <input type="text" :placeholder="dataProps.title" v-model="dataProps.title">
                    <br><br>
                    <communication-sub 
                        v-bind="dataProps">
                    </communication-sub>
                    <br>
                </div>
            </template>
            <script>
            import communicationSub from './communication-sub.vue'
            export default {
                name: "communication",
                data() {
                    return {
                        dataProps: {
                            title: ""
                        }
                    }
                },
                components: {
                    communicationSub
                },
                // 在 provide 添加子代需要接收的方法 onCommunicationClick，
                // 也可以直接指定为 this，子代便能访问父代所有的数据和方法。
                provide: function () { 
                    return {
                        onCommunicationClick: this.onCommunicationClick
                    }
                },
                methods: {
                    onCommunicationClick() {
                        this.dataProps.title = 'me, vaule after click'
                    }
                }
            }
            </script>

            // communication-sub.vue
            <template>
                <div class="communication-sub">
                    <p>me, commuication-sub</p>
                    <input v-bind:placeholder="title"/>
                    <br>{{text}}<br>
                    <communication-min-sub></communication-min-sub>
                    <br>
                </div>    
            </template>
            
            <script>
            import CommunicationMinSub from './communication-min-sub'
            export default {
                name: "communication-sub",
                props: {
                    title: {
                        type: String,
                        required: true
                    }
                },
                data: function() {
                    return {
                        text: this.title
                    }
                },
                components: {
                    CommunicationMinSub
                }
            }
            </script>

            // communication-min-sub.vue
            <template>
                <div class="communication-min-sub">
                    <p>me, communication-min-sub</p>
                    <button @click="onCommunicationClick">click</button>
                    <br>
                </div>
            </template>
            <script>
            export default {
                name: "communication-min-sub",
                inject: ['onCommunicationClick'] // inject接受祖组件方法
            }
            </script>

        4. ref、parent、children
            父组件访问子组件
            · ref
                获取元素的DOM对象和子组件实例，DOM加载后使用
                普通DOM元素上，引用指向的就是DOM元素
                子组件上，引用指向组件实例
                <input type="text" v-model="dataProps.title" ref="input">
                ...
                mounted() {
                    this.$nextTick(_ => { // 确保 Dom 更新完成
                        this.$refs['input'].style.color = 'red';
                    });
                }
                // 这里只是举一个栗子，实际项目中的需求，最好通过 class 的方式，尽量减少 Dom 操作。

                父元素状态改变，需要子组件进行http请求更新，通常通过Props将状态传递给子组件
                子组件进行watch检测，如变更，进行操作。
                这种时候可以使用ref
                <child ref="child"></child>
                ...
                <script>
                    export default {
                        methods () {
                            onStateChange() { // 变更状态后直接调用子组件方法进行更新
                                this.$refs['child'].updateData();
                            }
                        }
                    }
                </script>

            · $children、$parent
                分别指向当前组件的父子组件
                <script>
                    export default {
                        methods () {
                            onStateChange() { // 子组件返回的是一个数组，多个子组件用 $options.name 区分。
                                this.$children[0].updateData();
                            }
                        }
                    }
                </script>
                ref、parent、children 它们几个的一个缺点就是无法处理跨级组件和兄弟组件

            ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：
            在上面的例子中，input的引用信息为input1 ，$refs 是所有注册过的ref的一个集合，

            console.log(this.$refs.input1)//<input type="text" id="input1">
            console.log(document.getElementById('input1'))//<input type="text" id="input1">

            这两种方法获得的都是Dom节点，而$refs相对document.getElementById的方法，会减少获取dom节点的消耗。

            利用ref在子组件上注册引用，该引用信息保存在父组件的 $refs 对象上，父组件通过 this.$refs['注册信息'].func() 可以调用子组件的方法
            
            Vue文档原话：
                尽管有Props和事件，但仍需要在js中直接访问 子组件，为此可以使用ref，为子组件指定一个引用ID
                当ref和v-for一起使用时，获取到的引用会是一个数组，包含和循环数据源对应的子组件
                $refs只在组件渲染完成后才填充，并且他是非响应式的，它仅仅是一个直接操作子组件的应急方案--应当避免在模板或计算属性中使用


        5. emit、on、off
            $emit 和 $on都是组件自身的方法，$on 可以监听 $emit 派发的事件，$off 则用来取消事件监听。
            // 父组件
            <template>
                <button-component @clickbutton="clickButton"></button-component>
                // 在父组件中的子组件上利用 v-on监听父组件定义的方法
            </template>
            <script>
                export default {
                    methods: {
                        clickButton () {...}
                    }
                }
            </script>

            // 子组件
            <template>
                <button @click="handleClick"></button>
            </template>
            <script>
                export default {
                    methods: {
                        handleClick() { // 点击子组件的button 触发子组件定义的事件handleClick，在handleClick中利用$emit调用监听的父组件的方法
                            this.$emit('clickButton'); // 触发emit，调用父组件中的方法
                        }
                    },
                    mounted() {
                        this.$on('clickButton',(...arr) => { // 也可以自己监听 $emit，虽然没什么用···
                            console.log(...arr);
                        })
                    }
                }
            </script>
        6. EventBus
            支持跨级和兄弟组件
            使用vue实例做全局的事件通信(中央事件总线)

            正常的bus会挂在到vue的prototype，方便全局调用
            //main.js
            Vue.prototype.$bus = new Vue()
            //组件中
            this.$bus.$emit()

            或者 将eventBus挂在vue data上
            //main.js
            new Vue({
                data: {
                    eventBus: new Vue()
                },
                router: router.routers,
                components: { App },
                render: rout => rout(App)
              }).$mount('#app');
            //组件中
            this.$root.eventBus.$emit()

            //communication.vue
            <template>
                <div class="communication">
                    <p>me, commuication</p>
                    <input type="text" :placeholder="dataProps.title" v-model="dataProps.title">
                    <br><br>
                    <communication-sub 
                        v-bind="dataProps">
                    </communication-sub>
                    <br>
                </div>
            </template>
            <script>
            import communicationSub from './communication-sub.vue'
            export default {
                name: "communication",
                created() { // 监听子组件触发的 Bus事件
                    this.$bus.$on('busClick',(data) => {
                        this.dataProps.title = data;
                    });
                },
                beforeDestroy() { // 实例销毁时卸载监听事件  对于单页面，卸载很重要
                    this.$bus.$off('busClick');
                },
                data() {
                    return {
                        dataProps: {
                            title: ""
                        }
                    }
                },
                components: {
                    communicationSub
                }
            }
            </script>

            //communication-min-sub.vue
            <template>
                <div class="communication-min-sub">
                    <p>me, communication-min-sub</p>
                    <button @click="busClick">click bus</button>
                    <br>
                </div>
            </template>
            <script>
            export default {
                name: "communication-min-sub",
                methods: {
                    busClick() {
                        this.$bus.$emit('busClick', 'bus触发了');
                    }
                }
            }
            </script>

            子组件通过this.$bus.$emit('func',value)向父组件监听'func'的this.$bus.$on('func')传value，并执行后续操作。

            需要在许多页面都做 $on 监听的操作。将这些操作整合到一起：
            // 新建一个 eventBus.js
            import Vue from 'vue';
            const bus = new Vue({
                data () {
                    return {
                        userInfo: {}
                    }
                },
                created () {
                    this.$on('getUserInfo', val => {
                        this.userInfo = val;
                    })
                }
            });
            export default bus;

            // main.js
            import bus from './eventBus';
            Vue.prototype.$bus = bus;

            // app.vue
            methods: {
                getUserInfo() {
                    ajax.post(***).then(data => {
                        this.$bus.$emit('getUserInfo', data); // 通知 EventBus 更新 userInfo
                    })
                }
            }
            其他页面用到 userInfo 的时候，只需要 this.$bus.userInfo 就可以了。注意刚刚其实没有用 off 卸载掉监听，
            因为其实 userInfo 这种全局信息，并没有一个准确的说要销毁的时机，浏览器关闭的时候，也用不着我们处理了。

        7. dispatch、broadcast
            1.0 
            2.0 废弃
            $dispatch 向上级组件派发事件
            $broadcast 向下级广播

        8. Vuex
            是Vue中为组件通信而进行的统一的状态管理。
            Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，
            并以相应的规则保证状态以一种可预测的方式发生变化。--- 官方文档

            Vuex 的核心是单向数据流，并以相应规则保证所有的状态管理都可追踪、可预测。
            如果你的项目比较小，状态管理比较简单，完全没有必要使用 Vuex

            store.js中 保存组件间通信的状态和操作状态的方法：
                import Vue from 'vue'
                import Vuex from 'vuex'

                Vue.use(Vuex) // 引用vuex

                export default new Vuex.Store({
                    state: {
                        count: 0 // 各组件要改变的状态
                    },
                    mutations: { // 组件改变上述状态的方法集
                        increase () {
                            this.state.count++
                        }
                    },
                    actions: {

                    }
                })

            组件页面通过 store.state.xx获取Vue中的值：
                <template>
                    <div class="about">
                        <h1>This is an about page</h1>
                        <p>{{msg}}</p>
                    </div>
                </template>

                <script>
                import store from '@/store'
                export default {
                    name: 'about',
                    store,
                    data () {
                        return {
                            msg: store.state.count // 获取Vuex中的状态
                        }
                    }
                }
                </script>

            组件中通过 stroe.commit()调用Vuex中的方法：
                <script>
                    import store from '@/store' // 引入store
                    export default {
                        name: 'Info', // 缩进两个空格！！！ string用单引号
                        store,
                        mounted () { // vue生命周期，组件挂载完执行该方法
                            window.vue = this
                        },
                        methods: {
                            add () {
                                console.log('add Event from Info!')
                                debugger // 暂停进入debug模式
                                store.commit('increase') // 各组件通过commit向 中央管理store（vuex） 提交申请，利用 increase方法改变 state里的状态
                            }
                        }
                    }
                </script>



        总结：
            子组件触达父组件的方式：Props、$parent、$attrs、$listeners、provide 和 inject、$dispatch
            父组件触达子组件的方式：$emit 和 $on、$children、$ref、broadcast
            全局通信：EventBus、Vuex
        


<Q&A 261> OSI七层模型 

    应用层：应用程序与接口（如qq和其他三方软件的对接——对应设备（计算机）
         协议：http dns  telnet   nfs ftp文件传输协议 tftp小型文件传输协议   smtp简单邮件传输协议（25）  snmp简单网络管理协议（161）      
    
    表示层：表示数据的格式、压缩、加密
    
    会话层：作用：建立、维护、管理应用程序之间的会话。
    
         功能：对话控制、同步
    
    传输层：作用：负责建立端到端的连接、保证报文在端到端之间的传输。——对应设备（防火墙）
    
         功能：服务点编址，分段与重组、连接控制、流量控制、差错控制。
    
        协议：TCP   UDP
    
    网络层：作用：负责将分组数据从源端传输到目的端——对应设备（路由器）
    
         网络层功能：为网络设备提供逻辑地址，进行路由选择、分组转发
    
         IP地址=网络位+主机位
    
         IP地址是三层地址
    
         协议：IP  ARP  RARP逆地址解析协议  ICMP（Internet控制报文协议） IGMP网路群组管理协议
    
    数据链路层：作用：在局域网内部实现主机与主机之间的通讯——对应设备（交换机）
    
            协议：PPP  FDDI
    
    
    物理层：作用：负责把逐个的比特从一跳（结点）移动到另一跳（结点）。——（网卡）
    
         功能：1）定义接口和媒体的物理特性
    
           2）定义比特的表示、数据传输速率、信号的传输模式（单工、半双工、全双工）
    
             3）定时网络物理拓扑（网状、星型、环形、总线型、等拓扑）

<Q&A 262> git 版本控制原理

        git属于分布式版本控制系统，DVCS
        
        客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。

        git和其他版本控制不同：git之关心文件数的整体是否变化，而其他系统关心文件内容的差异，git不保存这些更新的差异数据，而是把变化的文件快照后，保存在一个微型文件系统中
        
        git原理：git会浏览文件的指纹信息，并做快照，保存指向快照的索引。若没变化，则保存上次快照的链接

        Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。

                已提交表示该文件已经被安全地保存在本地数据库 中了；
                已修改表示修改了某个文件，但还没有提交保存；
                已暂存表示把已修改的文件放在下次提交时要保存的清单中。 

<Q&A 263> SSR 和 预渲染

    预渲染是在 项目打包是，告诉打包工具 哪些url下的页面或组件需要提前生成 HTML 结构，在客户端请求时，直接返回该HTML

    预渲染在构建时(build time)就简单地生成针对特定路由的静态 HTML 文件，因此当用户访问这些路由时，服务器端会返回已渲染好的HTML文件。
    prerender-spa-plugin原理
    <script>
        new PrerenderSPAlugin({
            staticDir: path.join(__dirname, 'dist'),
            routes: [ '/', 'about' ],

            renderer: new Renderer({
                headless: false,
                renderAfterDocumentEvent: 'render-event'
            })
        })
    </script>
    在构建阶段的最后，在本地先创建一个Server，它用来处理访问页面的请求，然后启动一个 Puppeteer 的服务，访问配置了预渲染的路由，Server返回对应的页面，
    然后 Puppeteer 抓取页面进行渲染，最后生成静态的HTML文件输出到路由对应目录中。

    SSR 服务端渲染是
                客户端 --- nodejs --- 服务端
                是将客户端浏览器要做的vue生命周期的前几步渲染工作放到nodejs上来做，nodejs生成简单HTML结构，同时将从服务端请求得到的数据一起返回给客户端浏览器
                浏览器不再需要进行 生命周期 中前几步 HTML的渲染工作，直接将nodejs渲染好的html放上去就可
                加快了 首屏呈现 速度，同时优化了 SEO 效果。
                SEO： 爬虫在爬取网页信息，建立索引时，主要时识别网页中的html结构，由于单页面在进行页面加载时，需要从头开始生成html，这样速度较慢，爬虫爬的时候页面的body还是空白，不利于SEO

<Q&A 264> 前端页面优化

        · 资源压缩合并，合并图片，css、js文件压缩
        · 利用浏览器缓存，分为强缓存和协商缓存

        1. 强缓存不用请求服务器，直接使用本地的缓存。强缓存是利用 http 响应头中的Expires（绝对时间）或Cache-Control（服务器返回的相对时间，每次都会更新）实现的。
        2. 协商缓存：浏览器发现本地有资源的副本，但是不太确定要不要使用，于是去问问服务器。当浏览器对某个资源的请求没有命中强缓存（也就是说超出时间了），
            就会发一个请求到服务器，验证协商缓存是否命中。有两对header分别为Last-Modified、If-Modified-Since和ETag、If-None-Match使用cdn，CDN服务，
            其实就是把页面静态内容或静态化的动态内容缓存到不同地区很多台专门的缓存服务器上（如图片缓存服务器，静态HTML缓存服务器、文件缓存服务器等）， 
            然后根据用户线路所在的地区通过CND服务商的智能DNS自动选择一个最近的缓存服务器让用户访问，如果静态缓存服务器中没有请求的内容，才向动态服务器发出请求，以此提高速度，
            这种方案对页面静态内容效果非常好，所以Web设计中页面静态化是很有必要的。
        
         
        · DNS预解析，通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以尽快地完成 DNS 解析。
        · 关键渲染路径优化，延迟加载JavaScript（设置defer或async）、确保将任何非必需的 CSS 都标记为非关键资源（例如打印和其他媒体查询media=”print”）、
          尽早在 HTML 文档内指定所有 CSS 资源，以便浏览器尽早发现<link>标记并尽早发出 CSS 请求、避免使用 CSS import

<Q&A 265> vue+nginx, 为什么还要node？

        在这里vue+Nginx 为什么还用 node 的原因并不只是什么历史原因。Nginx 作为反向服务器存在的情况是非常多的，而且大部分 Nginx 并不提供逻辑处理，
        只做譬如负载均衡、流量控制、数据验证、静态服务器等功能，虽然他也可以作为逻辑服务器使用 Lua 去拓展他的模块，但是这对于大部分人来说，并不会这么去做，
        大部分人的做法是 Nginx 挡在前面作为一个负载均衡服务器，后面的逻辑服务器使用自己擅长的语言去实现逻辑，譬如：php，python，go，甚至是 c++（fast cgi）

        Vue 配合 node 大部分的原因是因为
                1. 就目前而言，vue 对 node 的服务端渲染支持最好（反过来说就不准确了）。并不是说除了 node 以外就不能做服务端渲染了，只要你够强，
                   你可以使用 go 把 vue 的 js 逻辑跑一遍，只要能够渲染出字符串，那你理论上来说用什么语言都是无所谓的。但是 Node 天生 js，所以 Node 最方便。
                2. 某些 Vue 无法做到的事情，Node 可以做。没错，这部分不能做的事情就是服务器逻辑，包括，数据存储，数据缓存，用户登录鉴权等等等等..
                3. 前后统一语言，都是 JavaScript

        搞清概念：什么是 Vue + Nginx
                Vue 只是一个 UI 层的框架，因此他打包出来的就是一套 UI 的静态文件：html + js-bundle。对于静态文件，其实 Node 也是可以处理的，
                但是鉴于 node 一般用来作为逻辑服务器的存在，我们会把静态服务器放在 Nginx 这一层返回给用户，因为 Nginx 在静态文件处理上来说很专业，
                自带的一些功能也非常多，譬如 Gzip 配置一下就可以了。

                因此，这个层面来看，如果只是 Vue + Nginx 的话，你大概就能做出一个静态的页面，如果你想要动态的页面，可能需要一个逻辑服务器帮助你，
                那么这个逻辑服务器就是 Nodejs （当然也可以是其他任何语言，python 、C\c++、java、go）
        
        Node 开创了什么历史？
                1. 使得 JavaScript 变成了服务器语言
                2. 更方便的写异步回调（注意是更方便，不是开创）

<Q&A 266> 前端高并发性能优化

        1. 利用缓存，精简请求
        2. 合并压缩 （HTTP2.0 首部压缩、建立全双工异步通信、数据分成更小的二进制帧）
        3. 静态资源上传cdn
        4. 避免高频刷新页面获取数据 （小于5秒的都回304）
        5. 设置响应头cache-control和last-modified

<Q&A 267> iframe

　　用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。

    <iframe>的优点：
        引入缓慢的第三方内容，比如标志和广告
        安全沙箱
        并行下载脚本
    <iframe>的缺点：
        代价高昂，即使是空白的iframe
        阻塞页面加载
        非语义

<Q&A 268> 跨域分离组件

　　分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在www.example.org，
    而把静态组件分离到static1.example.org和static2.example.org。
    

<Q&A 269> 把组件放在不含cookie的域下

　　当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。所以它们只会造成没有意义的网络通信量，
    应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。

　　如果域名是www.example.org，可以把静态组件部署到static.example.org。然而，如果已经在顶级域example.org或者www.example.org设置了cookie，
    那么所有对static.example.org的请求都会含有这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是yimg.com，
    YouTube是ytimg.com，Amazon是images-amazon.com等等。

　　把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用example.org还是www.example.org作为主页，
    可以考虑一下cookie的影响。省略www的话，就只能把cookie写到*.example.org，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。

<Q&A 270> 雅虎前端优化的35条军规

    1.尽量减少HTTP请求数
    2.减少DNS查找
    3.避免重定向
    4.让Ajax可缓存
    5.延迟加载组件
    6.预加载组件
    7.减少DOM元素的数量
    8.跨域分离组件
    9.尽量少用iframe
    10.杜绝404
    11.避免使用CSS表达式
    12.选择<link>舍弃@import
    13.避免使用滤镜
    14.把样式表放在顶部
    15.去除重复脚本
    16.尽量减少DOM访问
    17.用智能的事件处理器
    18.把脚本放在底部
    19.把JavaScript和CSS放到外面
    20.压缩JavaScript和CSS
    21.优化图片
    22.优化CSS Sprite
    23.不要用HTML缩放图片
    24.用小的可缓存的favicon.ico（P.S. 收藏夹图标）
    25.给Cookie减肥
    26.把组件放在不含cookie的域下
    27.保证所有组件都小于25K
    28.把组件打包到一个复合文档里
    29.Gzip组件
    30.避免图片src属性为空
    31.配置ETags
    32.对Ajax用GET请求
    33.尽早清空缓冲区
    34.使用CDN（内容分发网络）
    35.添上Expires或者Cache-Control HTTP头

<Q&A 271> html,css,js加载顺序

    1.js放在head中会立即执行，阻塞后续的资源下载与执行。因为js有可能会修改dom，如果不阻塞后续的资源下载，dom的操作顺序不可控。

　　正常的网页加载流程是这样的。
        1. 浏览器一边下载HTML网页，一边开始解析
        2. 解析过程中，发现<script>标签
        3. 暂停解析，网页渲染的控制权转交给JavaScript引擎
        4. 如果<script>标签引用了外部脚本，就下载该脚本，否则就直接执行
        5. 执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页

　　如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。
    html需要等head中所有的js和css加载完成后才会开始绘制，但是html不需要等待放在body最后的js下载执行就会开始绘制,
    因此将js放在body的最后面，可以避免资源阻塞，同时使静态的html页面迅速显示。将脚本文件都放在网页尾部加载，还有一个好处。
    在DOM结构生成之前就调用DOM，JavaScript会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时DOM肯定已经生成了。

 

    2.js的执行依赖前面的样式。即只有前面的样式全部下载完成后才会执行js，但是此时外链css和外链js是并行下载的。

　　 css需要分块，首页的css独立，其余的css需要动态加载，因为html的绘制会被css阻塞，这样可以减少首次进入时的白屏时间。

 

    3.外链的js如果含有defer="true"属性，将会并行加载js，到页面全部加载完成后才会执行，会按顺序执行。

　　    defer属性的作用是，告诉浏览器，等到DOM加载完成后，再执行指定脚本。

        1. 浏览器开始解析HTML网页
        2. 解析过程中，发现带有defer属性的script标签
        3. 浏览器继续往下解析HTML网页，同时并行下载script标签中的外部脚本
        4. 浏览器完成解析HTML网页，此时再执行下载的脚本
　　
        对于内置而不是连接外部脚本的script标签，以及动态生成的script标签，defer属性不起作用。

    4.外链的js如果含有async="true"属性，将不会依赖于任何js和css的执行，此js下载完成后立刻执行，不保证按照书写的顺序执行。
        因为async="true"属性会告诉浏览器，js不会修改dom和样式，故不必依赖其它的js和css。　

　　    async属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。

        1. 浏览器开始解析HTML网页
        2. 解析过程中，发现带有async属性的script标签
        3. 浏览器继续往下解析HTML网页，同时并行下载script标签中的外部脚本
        4. 脚本下载完成，浏览器暂停解析HTML网页，开始执行下载的脚本
        5. 脚本执行完毕，浏览器恢复解析HTML网页

　　    async属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，
        就先执行那个脚本。另外，使用async属性的脚本文件中，不应该使用document.write方法。

　　 一般来说，如果脚本之间没有依赖关系，就使用async属性，如果脚本之间有依赖关系，就使用defer属性。如果同时使用async和defer属性，
    后者不起作用，浏览器行为由async属性决定。


<Q&A 272> css可替换元素

        典型的可替换元素有：
            <iframe>
            <video>
            <embed>
            <img>
        有些元素仅在特定情况下被作为可替换元素处理，例如：
            <option>
            <audio>
            <canvas>
            <object>
            <applet>
        HTML 规范也说了 <input> 元素可替换，因为 "image" 类型的 <input> 元素就像<img>一样被替换。但是其他形式的控制元素，包括其他类型的 <input> 元素，被明确地列为非可替换元素

<Q&A 273> css可继承元素

    一、无继承性的属性
            1、display：规定元素应该生成的框的类型
            2、文本属性：
            vertical-align：垂直文本对齐
            text-decoration：规定添加到文本的装饰
            text-shadow：文本阴影效果
            white-space：空白符的处理
            unicode-bidi：设置文本的方向
            3、盒子模型的属性：width、height、margin 、border、padding.
            4、背景属性：background
            5、定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index.
            6、生成内容属性：content、counter-reset、counter-increment
            7、轮廓样式属性：outline-style、outline-width、outline-color、outline
            8、页面样式属性：size、page-break-before、page-break-after
            9、声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during

    二、有继承性的属性
            1、字体系列属性
                font：组合字体
                font-family：规定元素的字体系列
                font-weight：设置字体的粗细
                font-size：设置字体的尺寸
                font-style：定义字体的风格
                font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。
                font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。
                font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。
            2、文本系列属性
                text-indent：文本缩进
                text-align：文本水平对齐
                line-height：行高
                word-spacing：增加或减少单词间的空白（即字间隔）
                letter-spacing：增加或减少字符间的空白（字符间距）
                text-transform：控制文本大小写
                direction：规定文本的书写方向
                color：文本颜色
            3、元素可见性：visibility
            4、表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout
            5、列表布局属性：list-style-type、list-style-image、list-style-position、list-style
            6、生成内容属性：quotes
            7、光标属性：cursor
            8、页面样式属性：page、page-break-inside、windows、orphans
            9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation
    
    三、所有元素可以继承的属性
            1、元素可见性：visibility
            2、光标属性：cursor
             
    四、内联元素可以继承的属性
            1、字体系列属性
            2、除text-indent、text-align之外的文本系列属性
             
    五、块级元素可以继承的属性
            1、text-indent、text-align

<Q&A 274> css层叠顺序

        什么选择器在层叠中胜出取决于三个因素（这些都是按重量级顺序排列的——前面的的一种会否决后一种）：
            重要性（Importance）
            专用性（Specificity）
            源代码次序（Source order）
            
        一个特别的语法可以让一条规则总是优先于其他规则：!important。

        CSS2.1 层叠顺序：层叠上下文background/border -- 负z-index -- block块状水平盒子 -- float浮动盒子 -- inline/inline-block水平盒子 -- z-index:auto或0 -- 正z-index

            · 位于最低水平的border/background指的是层叠上下文元素的边框和背景色。每一个层叠顺序规则适用于一个完整的层叠上下文元素。
            · inline-block和inline水平元素是同等level级别。
            · z-index:0实际上和z-index:auto单纯从层叠水平上看，是可以看成是一样的。实际上，两者在层叠上下文领域有着根本性的差异。
            · border/background一般为装饰属性，而浮动和块状元素一般用作布局，而内联元素都是内容。所以内联元素层级要高
            · 谁大谁上：当具有明显的层叠水平标示的时候，如识别的z-indx值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。
            · 后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。
        
        层叠上下文元素有如下特性：

            层叠上下文的层叠水平要比普通元素高；
            层叠上下文可以阻断元素的混合模式；
            层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。
            每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。
            每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。
        
        层级上下文创建：
            · 页面根元素天生具有层叠上下文，称之为“根层叠上下文”。

                    指的是页面根元素，也就是滚动条的默认的始作俑者<html>元素。这就是为什么，绝对定位元素在left/top等值定位的时候，如果没有其他定位元素限制，会相对浏览器窗口定位的原因。

            · z-index值为数值的定位元素的传统层叠上下文。

                    对于包含有position:relative/position:absolute的定位元素，以及FireFox/IE浏览器（不包括Chrome等webkit内核浏览器）（目前，也就是2016年初是这样）下含有position:fixed声明的定位元素，
                    当其z-index值不是auto的时候，会创建层叠上下文。

                    IE6/IE7浏览器有个bug，就是z-index:auto的定位元素也会创建层叠上下文。

                    在过去，position:fixed和relative/absolute在层叠上下文这一块是一路货色，都是需要z-index为数值才行。但是，不知道什么时候起，Chrome等webkit内核浏览器，position:fixed元素天然层叠上下文元素，无需z-index为数值。

            · 其他CSS3属性。

                    CSS3对层叠上下文的影响。

                        1. z-index值不为auto的flex项(父元素display:flex|inline-flex).

                            要满足两个条件才能形成层叠上下文：条件1是父级需要是display:flex或者display:inline-flex水平，条件2是子元素的z-index不是auto，必须是数值。
                            此时，这个子元素为层叠上下文元素，没错，注意了，是子元素，不是flex父级元素。

                            在CSS2.1时代，z-index属性必须和定位元素一起使用才有作用，但是，在CSS3的世界里，非定位元素也能和z-index愉快地搞基。

                        2. 元素的opacity值不是1.

                            opacity的值不是1的时候，是具有层叠上下文的，层叠顺序是z-index:auto级别，跟没有z-index值的absolute绝对定位元素是平起平坐的。

                        4. 元素的transform值不是none.
                        5. 元素mix-blend-mode值不是normal.
                        6. 元素的filter值不是none.

                            此处说的filter是CSS3中规范的滤镜，不是旧IE时代私有的那些，虽然目的类似。

                        7. 元素的isolation值是isolate.

                            isolation:isolate这个声明是mix-blend-mode应运而生的。默认情况下，mix-blend-mode会混合z轴所有层叠在下面的元素，
                            要是我们不希望某个层叠的元素参与混合怎么办呢？就是使用isolation:isolate。

                        8. will-change指定的属性值为上面任意一个。
                        9. 元素的-webkit-overflow-scrolling设为touch.

        层叠上下文与层叠顺序：

                一旦普通元素具有了层叠上下文，其层叠顺序就会变高。

                如果层叠上下文元素不依赖z-index数值，则其层叠顺序是z-index:auto可看成z:index:0级别；
                如果层叠上下文元素依赖z-index数值，则其层叠顺序由z-index值决定。

                层叠顺序：层叠上下文background/border -- 负z-index -- block块状水平盒子 -- float浮动盒子 -- inline/inline-block水平盒子 -- z-index:auto或看成z-index=0 不依赖z-index的层叠上下文 -- 正z-index

                定位元素会层叠在普通元素的上面？
                其根本原因就在于，元素一旦成为定位元素，其z-index就会自动生效，此时其z-index就是默认的auto，也就是0级别，根据上面的层叠顺序表，就会覆盖inline或block或float元素。

                z-index值与层叠顺序
                如果元素支持z-index值，则层叠顺序就要好理解些了，比较数值大小，本质上是应用的“谁大谁上”的准则。在以前，我们只需要关心定位元素的z-index就好，
                但是，在CSS3时代，flex子项也支持z-index，使得我们面对的情况比以前要负复杂。然而，好的是，规则都是一样的，对于z-index的使用和表现也是如此，套用上面的7阶层叠顺序表就可以了。

                多数常见，z-index根本就没有出现的必要。知道了内联元素的层叠水平比块状元素高，于是，某条线你想覆盖上去的时候，需要设置position:relative吗？不需要，inline-block化就可以。
                因为IE6/IE7 position:relative会创建层叠上下文，很烦的。

<Q&A 275> 盒子模型

    CSS盒模型描述了通过 文档树中的元素 以及相应的 视觉格式化模型(visual formatting model) 所生成的矩形盒子。
    CSS 的视觉格式化模型(visual formatting model) 是根据 基础盒模型(CSS basic box model) 将 文档(doucment) 中的元素转换一个个盒子的实际算法。

    content area：
        box-sizing=content-box
        内容区域的大小可明确地通过 width、min-width、max-width、height、min-height，和 max-height 控制。

    padding area：
        box-sizing=padding-box
        内边距的粗细可以由 padding-top、padding-right、padding-bottom、padding-left，和简写属性 padding 控制。

    border area：
        box-sizing=margin-box
        边框区域的大小可明确地通过 width、min-width, max-width、height、min-height，和 max-height 属性控制。
        假如框盒上设有背景（background-color 或 background-image），背景将会一直延伸至边框的外沿（默认为在边框下层延伸，边框会盖在背景上）此默认表现可通过 CSS 属性 background-clip 来改变。

    margin area：
         box-sizing=border-box
         外边距区域的大小由 margin-top、margin-right、margin-bottom、margin-left，和简写属性 margin 控制。
         在发生外边距合并的情况下，由于盒之间共享外边距，外边距不容易弄清楚。

    除可替换元素外，对于行内元素来说，尽管内容周围存在内边距与边框，但其占用空间（每一行文字的高度）则由 line-height 属性决定，即使边框和内边距仍会显示在内容周围。

    每个盒子的布局由以下因素决定：
        1.盒子的尺寸
        2.盒子的类型：行内盒子 (inline)、行内级盒子 (inline-level)、原子行内级盒子 (atomic inline-level)、块级盒子 (block-level)
        3.定位：正常流、浮动、绝对定位
        4.文档树中当前盒子的子元素 或 兄弟元素
        5.视口(viewport) 的尺寸 和位置
        6.盒子内部图片的尺寸
        7.其他某些外部因素

    块级元素
        · 当元素的display  为 block、list-item 或 table 时，它就是块级元素。

    块级盒子
        · 块级盒子用于描述它与父、兄弟元素之间的关系。
        · 每个块级盒子都会参与 块格式化上下文（block formatting context） 的创建。
        · 每个块级元素都会至少生成一个块级盒子，即主块级盒子（principal block-level box）
        · 主块级盒子包含由后代元素生成的盒子以及内容，同时它也会参与定位方案。
        · 一个同时是块容器盒子的块级盒子称为块盒子（block box）。

    匿名盒子
        · 某些情况下需要进行视觉格式化时，需要添加一些增补性的盒子，这些盒子不能被CSS 选择器选中，也就是所有可继承的 CSS 属性值都为 inherit ，
          而所有不可继承的 CSS 属性值都为 initial。因此称为匿名盒子(anonymous boxes)。

    行内盒子
        · 行内级元素会生成行内级盒子，该盒子同时会参与行内格式化上下文（inline formatting context）的创建。

    匿名行内盒子
        · 类似于块盒子，CSS引擎有时候也会自动创建一些行内盒子。这些行内盒子无法被选择符选中，因此是匿名的，它们从父元素那里继承那些可继承的属性，其他属性保持默认值 initial。

    行盒子
        · 行盒子由行内格式化上下文创建，用来显示一行文本。在块盒子内部，行盒子总是从块盒子的一边延伸到另一边（译注：即占据整个块盒子的宽度）。
          当有浮动元素时，行盒子会从向左浮动的元素的右边缘延伸到向右浮动的元素的左边缘。

    建立 BFC(Block formatting contexts) 的条件
          浮动、绝对定位元素、块容器（例如inline-blocks、table-cells、and table-captions）以及溢出而非可视的元素（除非该值已经传播到了视口）都是。

    简单来说，BFC就是一个独立不干扰外界也不受外界干扰的盒子啊(/ω＼)。

    正常流中的块级与非替换元素

    'margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right' = 包含块的宽度

    如果宽度不是 auto 或者 'border-left-width'+'padding-left'+'width'+'padding-right'+'border-right-width' 的结果大于包含块的宽度，对于以下规则，被视为零。
    如果只有一个值指定为'auto'，则其使用的值来自相等。
    如果宽度设置为 auto ，则任何其他 auto 值变为 0 ，并且宽度会跟着所以盒子的情况铺满。
    如果 'margin-left' 跟 'margin-right' 都为 auto ，则会使元素相对于包含块的边缘水平居中。

    浮动与非替换元素

    如果 'margin-left' 跟 'margin-right' 都为 auto ，则它们的具体值为 0 。
    如果宽度为 auto，则使用 shrink-to-fit 的宽度计算方式（CSS 2.2没有定义精确的算法）。
    然后 shrink-to-fit 大概的计算方式则是：min(max(preferred minimum width, available width), preferred width)。

    绝对定位与非替换元素

    'left' + 'margin-left' + 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width' + 'margin-right' + 'right' = 包含块的宽度

    如果 'left'，'width' 和 'right' 都是 'auto'，则首先将 'margin-left' 和 'margin-right' 的 'auto' 值设置为 0。
    如果 'left'，'width' 和 'right' 都不是 'auto'，则按照实际值来算。
    如果 'margin-left' 跟 'margin-right' 都为 0 ，则根据 'left' ，'width' 和 'right' 的值是否是 'auto' 来计算。 如果 一个方向值 ，'width' 的值是 'auto'，
    而 '另一个一个方向值' 不是，则宽度使用 shrink-to-fit 算法计算。如果一个值为**'auto'**而另外两个值不算，则该值使用 shrink-to-fit 来计算。

<Q&A 276> 怪异盒子

    在标准盒模型中：盒子占位宽度width = width + 2margin + 2padding + 2*border,高度与之一样。    
    
    盒子真正的宽度：width = width + 2padding + 2border。 margin不算！margin可以改变盒子占位的大小，但是盒子的宽高并没有改变，而是位置的改变！

    根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。
    不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。
    
    ie 盒子模型的 content 部分包含了 border 和 pading

    要让网页按标准盒模型去解析，则需要加上 doctype声明，否则不同的浏览器会按照自己的标准去解析。
	box-sizing
	box-sizing 属性允许你以某种方式定义某些元素，以适应指定区域。
    例如，假如您需要并排放置两个带边框的框，可通过将 box-sizing 设置为 "border-box"。这可令浏览器呈现出带有指定宽度和高度的框，并把边框和内边距放入框中

    box-sizing类似于ie盒模型，它会把内边距和边框包含在width内。在实际工作中，我们设置一个固定宽度的盒子，但当给它设置padding、border之后，它的真正宽度就会改变。
    这时box-sizing就派上用途了。它会自动调整内容的宽度，保证盒子的真正宽度还是我们设置的宽度。

<Q&A 277> Flex布局

    布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。

    2009年，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。

    Flex 是 Flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。

    任何一个容器都可以指定为 Flex 布局。
        .box{
        display: flex;
        }
    行内元素也可以使用 Flex 布局。
        .box{
        display: inline-flex;
        }
    Webkit 内核的浏览器，必须加上-webkit前缀。
        .box{
        display: -webkit-flex; /* Safari */
        display: flex;
        }

    设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。

    采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。

    容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。
    项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。

    flex容器属性：
        flex-direction 
            决定主轴的方向（即项目的排列方向）。
            row（默认值）：主轴为水平方向，起点在左端。
            row-reverse：主轴为水平方向，起点在右端。
            column：主轴为垂直方向，起点在上沿。
            column-reverse：主轴为垂直方向，起点在下沿。
        flex-wrap
            定义，如果一条轴线排不下，如何换行。
            nowrap（默认）：不换行。
            wrap：换行，第一行在上方。
            wrap-reverse：换行，第一行在下方。
        flex-flow
            属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。
        justify-content
            定义了项目在主轴上的对齐方式。
            flex-start（默认值）：左对齐
            flex-end：右对齐
            center： 居中
            space-between：两端对齐，项目之间的间隔都相等。
            space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。
        align-items
            定义项目在交叉轴上如何对齐。
            flex-start：交叉轴的起点对齐。
            flex-end：交叉轴的终点对齐。
            center：交叉轴的中点对齐。
            baseline: 项目的第一行文字的基线对齐。
            stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
        align-content
            定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
            flex-start：与交叉轴的起点对齐。
            flex-end：与交叉轴的终点对齐。
            center：与交叉轴的中点对齐。
            space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
            space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
            stretch（默认值）：轴线占满整个交叉轴。

        项目属性
            order
                定义项目的排列顺序。数值越小，排列越靠前，默认为0。
            flex-grow
                定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
                如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
            flex-shrink
                定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
                如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
                负值对该属性无效。
            flex-basis
                定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
                它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。
            flex
                flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
                该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。
            align-self
                允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
                该属性可能取6个值，除了auto，其他都与align-items属性完全一致。

            水平垂直居中
                justify-content: center; //主轴上居中 水平
                align-items: center;  //交叉轴上居中 垂直 
                // 如果有多行，即多个主轴 垂直居中如下
                align-content: center;

<Q&A 278> Grid布局

        网格布局（Grid）是最强大的 CSS 布局方案。

        它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。

        Flex 布局是轴线布局，只能指定"项目"针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成"行"和"列"，产生单元格，然后指定"项目所在"的单元格，可以看作是二维布局。
        Grid 布局远比 Flex 布局强大。

    容器：网格布局区域。
    项目：容器内部采用网格定位的子元素，只能是容器的顶层元素，不包含项目的子元素。
    
        Grid布局只对项目生效。

        容器里面的水平区域称为"行"（row），垂直区域称为"列"（column）。
        行和列的交叉区域，称为"单元格"（cell）。

    Grid 布局的属性分成两类：
        
        一类定义在容器上面，称为容器属性；
                display: grid指定一个容器采用网格布局。
                    默认情况下，容器元素都是块级元素，但也可以设成行内元素。
                        div {
                            display: inline-grid;
                        }
                    设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。
                
                grid-template-columns: 100px 100px 100px; 定义每一列的列宽，
                grid-template-rows: 33.33% 33.33% 33.33%; 定义每一行的行高。
                grid-template-columns: repeat(3, 33.33%);  重复后面值3次。
                grid-template-columns: repeat(2, 100px 20px 80px);  重复后面三个值的模式。
                grid-template-columns: repeat(auto-fill, 100px);  每列宽度100px，然后自动填充，直到容器不能放置更多的列。
                grid-template-columns: 1fr 1fr;  后者是前者的两倍。
                grid-template-columns: 150px 1fr 2fr;  第一列的宽度为150像素，第二列的宽度是第三列的一半。
                grid-template-columns: 1fr 1fr minmax(100px, 1fr);  列宽不小于100px，不大于1fr。
                grid-template-columns: 100px auto 100px;  浏览器自己决定长度，基本上等于该列单元格的最大宽度。
                grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];  指定每一根网格线的名字。网格布局允许同一根线有多个名字，比如[fifth-line row-5]。
                grid-template-columns: 70% 30%;  两栏式布局只需要一行代码。
                grid-template-columns: repeat(12, 1fr);  传统的十二网格布局。

                row-gap: 20px; 设置行与行的间隔（行间距），
                column-gap: 20px; 设置列与列的间隔（列间距）。
                gap: <row-gap> <column-gap>;  省略了第二个值，浏览器认为第二个值等于第一个值。

                grid-template-areas: 'a b c'   定义区域
                                     'd e f'
                                     'g h i';
                grid-template-areas: 'a a a'  多个单元格合并成一个区域, 如果某些区域不需要利用，则使用"点"（.）表示。
                                     'b b b'
                                     'c . c';
                grid-template-areas: "header header header"  顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。
                                     "main main sidebar"
                                     "footer footer footer";

                区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。
                
                grid-auto-flow:row  子元素排列顺序，即"先行后列"。
                还可以设成row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。

                justify-items: start | end | center | stretch;  设置单元格内容的水平位置（左中右）
                align-items: start | end | center | stretch;  设置单元格内容的垂直位置（上中下）。
                    start：对齐单元格的起始边缘。
                    end：对齐单元格的结束边缘。
                    center：单元格内部居中。
                    stretch：拉伸，占满单元格的整个宽度（默认值）。
                place-items: <align-items> <justify-items>;  合并简写形式。
                
                justify-content: start | end | center | stretch | space-around | space-between | space-evenly;  是整个内容区域在容器里面的水平位置（左中右）
                align-content: start | end | center | stretch | space-around | space-between | space-evenly;  是整个内容区域的垂直位置（上中下）。
                    start - 对齐容器的起始边框。
                    end - 对齐容器的结束边框。
                    center - 容器内部居中。
                    stretch - 项目大小没有指定时，拉伸占据整个网格容器。
                    space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。
                    space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。
                    space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。
                place-content: <align-content> <justify-content>;  合并简写形式。

                grid-auto-columns: 设置浏览器自动创建的多余网格的列宽
                grid-auto-rows: 设置浏览器自动创建的多余网格的行高

                grid-template: 是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。
                grid: 是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。

        一类定义在项目上面，称为项目属性。
                
        grid-column-start属性：2; 左边框所在的垂直网格线.
        grid-column-end属性：4; 右边框所在的垂直网格线.
        grid-row-start属性：header-start; 上边框所在的水平网格线.
        grid-row-end属性：header-end; 下边框所在的水平网格线.
        grid-column-start: span 2;  边框跨越2个网格.

        grid-column属性是grid-column-start和grid-column-end的合并简写形式.
        grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。

        grid-area属性指定项目放在哪一个区域。
        grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式

        justify-self: 设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。
        align-self: 设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。
        place-self属性是align-self属性和justify-self属性的合并简写形式。

<Q&A 279> CSS 流体特性和BFC特性下多栏自适应布局 .

    流体特性：
            块状水平元素，如div元素（下同），在默认情况下（非浮动、绝对定位等），水平方向会自动填满外部的容器；
            如果有margin-left/margin-right, padding-left/padding-right, border-left-width/border-right-width等，实际内容区域会响应变窄。

    BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。所以，避免margin穿透啊，清除浮动什么的也好理解了。

        什么时候会触发BFC呢？常见的如下：

                    · float的值不为none。
                    · overflow的值为auto,scroll或hidden。
                    · display的值为table-cell, table-caption, inline-block，Flex中的任何一个。
                    · position的值不为relative和static。

            BFC特性很多，而我们这里，只关心一个，和float元素做相邻兄弟时候的表现。
            左边浮动元素，右边 overflow: hidden 实现BFC
            普通流体元素BFC(overflow: hidden)后，为了和左边浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文。
            这样BFC保留了流体特性，反映在布局上就是自动填满除去浮动内容以外的剩余空间。

            这时BFC要想和左边浮动元素拉开距离，margin要设置的够大，大于左边浮动元素宽度。但完全没有必要对BFC元素设置margin, 因为又回到了流体布局。
            可以使用左边浮动元素的margin-right或者padding-right轻松实现间距效果。
            这样与左边浮动元素的宽度是多少没有任何关系。不仅如此，我们还可以使用BFC元素的padding-left撑开间距

        自适应布局：
            .l { float: left; }
            .ovh { overflow: hidden; }
            的自适应固定搭配。再配合zxx.lib.cssCSS样式库的margin和padding家族，快速布局可谓所向披靡。

        BFC自适应布局优势：

                · 自适应内容由于封闭，更健壮，容错性强。比方说，内部clear:both不会与兄弟float产生矛盾。
                    而纯流体布局，clear:both会让后面内容无法和float元素在一个水平上，产生布局问题。

                · 自适应内容自动填满浮动以为区域，无需关心浮动元素宽度，可以整站大规模应用。
                    而纯流体布局，需要大小不确定的margin/padding等值撑开合适间距，无法CSS组件化。

                · CSS代码就是非常简单的：

                            .float-left {
                                float: left; margin-right: 20px; 
                            }
                            .bfc-content {
                                overflow: hidden; background-color: #beceeb;
                            }
        由于绝大多数的触发BFC的属性自身有一些古怪的特性，所以，实际操作的时候，能兼顾流体特性和BFC特性来实现无敌自适应布局的属性并不多。
                
                · float:left 浮动元素本身BFC化，然而浮动元素有破坏性和包裹性，失去了元素本身的流体自适应性，因此，无法用来实现自动填满容器的自适应布局。
                  不过，其因兼容性还算良好，与堆积木这种现实认知匹配，上手简单，因此在旧时代被大肆使用，也就是常说的“浮动布局”，也算阴差阳错开创了自己的一套布局。

                · position:absolute 这个脱离文档流有些严重
                
                · overflow:hidden  不像浮动和绝对定位。也就是溢出剪裁什么的，本身还是个很普通的元素。因此，块状元素的流体特性保存相当完好，附上BFC的独立区域特性，
                    就跟清除浮动：.clearfix { overflow: hidden; _zoom: 1; }一样。由于很多场景我们是不能overflow:hidden的，
                    因此，无法作为一个通用CSS类整站大规模使用。因此，float + overflow 的自适应布局，我们可以在局部（你确定不会有什么被剪裁的情况下）很happy地使用。

                · display:inline-block会让元素尺寸包裹收缩，完全就不是我们想要的block水平的流动特性。
                  IE6/IE7浏览器下，block水平的元素设置display:inline-block元素还是block水平，也就是还是会自适应容器的可用宽度显示。
                  即BFC特性加身，又流体特性保留。
                        .float-left {
                            float: left;
                        }
                        .bfc-content {
                            display: inline-block;
                        }
                    当然，*zoom: 1也是类似效果，不过只适用于低级的IE浏览器，如IE7~

                · display:table-cell 让元素表现得像单元格一样，IE8+以上浏览器才支持。跟display:inline-block一样，会跟随内部元素的宽度显示，  
                  但是，单元格有个非常神奇的特性，就是你宽度值设置地再大，大到西伯利亚，实际宽度也不会超过表格容器的宽度。
                  如果我们把display:table-cell这个BFC元素宽度设置很大，比方说3000像素。那其实就跟block水平元素自动适应容器空间效果一模一样了。
                  但是，还是有两点制约，一是IE8+以上浏览器兼容，有些苦逼的团队还要管IE6；二是应付连续英文字符换行有些吃力（可以嵌套table-layout:fixed解决）。
                  适用的场景要比overflow:hidden广

        BFC声明家族大致过了一遍，能担任自适应布局重任的也就是：

                    overflow:auto/hidden IE7+
                    display:inline-block IE6/IE7
                    display:table-cell IE8+

                    由于overflow有剪裁和出现滚动条等隐患，不适合作为整站通用类，于是，最后，类似清除浮动的通用类语句：

                        .clearfix {
                            *zoom: 1;
                        }
                        .clearfix:after {
                            content: ''; display: table; clear: both;
                        }
                    两栏或多栏自适应布局的通用类语句是（block水平标签，需配合浮动）：

                        .cell {
                            display: table-cell; width: 9999px;
                            *display: inline-block; *width: auto;
                        }
                    这就是zxx.lib.cssCSS样式库中.cell的由来！

                    当然，由于和浮动元素合作，清除浮动还是要的，于是，就有了.fix + .l/.r + .cell的无敌组合，可以多栏，也可以无限嵌套。

                    如果是局部，且确认安全；或有连续英文字符换行的隐患，你也可以使用.fix + .l/.r + .ovh的无敌组合，可以多栏，也可以无限嵌套。

<Q&A 280> css 实现居中

    1、水平居中

        水平居中可分为行内元素水平居中和块级元素水平居中

        1.1 行内元素水平居中
            这里行内元素是指文本text、图像img、按钮超链接等，只需给父元素设置text-align:center即可实现。

            .center{
                    text-align:center;
            }
            <div class="center">水平居中</div>

        1.2 块级元素水平居中
            · 定宽块级元素水平居中
                只需给需要居中的块级元素加margin:0 auto即可，但这里需要注意的是，这里块状元素的宽度width值一定要有

                .center{
                    width:200px;
                    margin:0 auto;
                    border:1px solid red;
                }
                <div class="center">水平居中</div>

            · 不定宽块级元素水平居中
                不定宽，即块级元素宽度不固定

                方法1：设置table

                    通过给要居中显示的元素，设置display:table，然后设置margin:0 auto来实现

                    .center{
                        display:table;
                        margin:0 auto;
                        border:1px solid red;
                    }
                    <div class="center">水平居中</div>

                方法2：设置inline-block 多个块状元素

                    子元素设置inline-block，同时父元素设置text-align:center

                    .center{
                        text-align:center;
                    }
                    .inlineblock-div{
                        display:inline-block;
                    }
                    <div class="center">
                        <div class="inlineblock-div">1</div>
                        <div class="inlineblock-div">2</div>
                    </div>

                方法3：设置flex布局

                    只需把要处理的块状元素的父元素设置display:flex,justify-content:center;

                    .center{
                        display:flex;
                        justify-content:center;
                    }
                    <div class="center">
                        <div class="flex-div">1</div>
                        <div class="flex-div">2</div>
                    </div>

                方法4：position + 负margin；
                方法5：position + margin：auto；
                方法6：position + transform；

                注：这里方法4、5、6同下面垂直居中一样的道理，只不过需要把top/bottom改为left/right，在垂直居中部分会详细讲述。

    2、垂直居中

        2.1 单行文本垂直居中

            设置paddingtop=paddingbottom；或
            设置line-height=height；

        2.2 多行文本垂直居中

            通过设置父元素table，子元素table-cell和vertical-align
            vertical-align:middle的意思是把元素放在父元素的中部
                    <!DOCTYPE html>
                    <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <style type="text/css">
                        .center{
                            width: 200px;
                            height: 300px;
                            display: table;
                            border: 2px solid blue;
                        }
                        .table-div{
                            didplay: table-cell;
                            vertical-align: middle;
                            border: 1px solid red;
                        }
                        </style>
                    </head>
                    <body>
                        <div class='center'>
                            <div class="table-div">多行文本垂直居中</div>
                        </div>
                    </body>
                    </html>

        2.3 块级元素垂直居中
        
            方法1：flex布局

                在需要垂直居中的父元素上，设置display:flex和align-items：center
                要求：父元素必须显示设置height值
                .center{
                    width: 200px;
                    height: 300px;

                    display: flex;
                    align-items: center;

                    border: 2px solid blue;
                }
                <div class='center'>
                    <div class="table-div">垂直居中</div>
                </div>

            方法2：利用position和top和负margin（需知宽高）

                1、设置元素为absolute/relative/fixed
                2、margin=负一半

                    <!DOCTYPE html>
                    <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <style type="text/css">
                        .parent{
                            position: relative;
                            width: 200px;
                            height: 200px;

                            border: 2px solid blue;
                        }
                        .child{
                            position: absolute;
                            width: 150px;
                            height: 200px;
                            top: 50%;
                            margin-top: -50px;
                            line-height: 100px;
                        }
                        </style>
                    </head>
                    <body>
                        <div class='parent'>
                            <div class="child">已知高度垂直居中</div>
                        </div>
                    </body>
                    </html>

            方法3：利用position和top/bottom和margin:auto（注意不是margin:0 auto）

                1、position：absolute/relative/fixed
                2、top/bottom：0
                3、margin：auto

                    <!DOCTYPE html>
                    <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <style type="text/css">
                        .parent{
                            position: relative;
                            width: 200px;
                            height: 200px;

                            border: 2px solid blue;
                        }
                        .child{
                            position: absolute;
                            width: 150px;
                            height: 200px;
                            top: 0;
                            bottom: 0;
                            margin: auto;
                            line-height: 100px;
                        }
                        </style>
                    </head>
                    <body>
                        <div class='parent'>
                            <div class="child">已知高度垂直居中</div>
                        </div>
                    </body>
                    </html>

            方法4：利用position和top和transform

                transform中translate偏移的百分比就是相对于元素自身的尺寸而言的。

                    <!DOCTYPE html>
                    <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <style type="text/css">
                        .parent{
                            position: relative;
                            width: 200px;
                            height: 200px;

                            border: 2px solid blue;
                        }
                        .child{
                            position: absolute;
                            width: 150px;
                            height: 200px;
                            top: 50%;
                            transform: translate(0, -50%);
                            line-height: 100px;
                        }
                        </style>
                    </head>
                    <body>
                        <div class='parent'>
                            <div class="child">已知高度垂直居中</div>
                        </div>
                    </body>
                    </html>

        注：
            · 上述的块级垂直居中方法，稍加改动，即可成为块级水平居中方法，如top/bottom换成left/right
            · transform方法，可用于未知元素大小的居中

    3、水平垂直居中
            方法1：绝对定位+margin:auto

                div{
                    width: 200px;
                    height: 200px;
                    background: green;
                    
                    position:absolute;
                    left:0;
                    top: 0;
                    bottom: 0;
                    right: 0;
                    margin: auto;
                }
            方法2：绝对定位+负margin

                div{
                    width:200px;
                    height: 200px;
                    background:green;
                    
                    position: absolute;
                    left:50%;
                    top:50%;
                    margin-left:-100px;
                    margin-top:-100px;
                }
            方法3：绝对定位+transform

                div{
                    width: 200px;
                    height: 200px;
                    background: green;
                    
                    position:absolute;
                    left:50%;    /* 定位父级的50% */
                    top:50%;
                    transform: translate(-50%,-50%); /*自己的50% */
                }
            方法4：flex布局

            .box{
                    height:600px;  
                    
                    display:flex;
                    justify-content:center;  //子元素水平居中
                    align-items:center;      //子元素垂直居中
                    /* aa只要三句话就可以实现不定宽高水平垂直居中。 */
                }
                .box>div{
                    background: green;
                    width: 200px;
                    height: 200px;
                }
            方法5：table-cell实现居中

            设置
            display:table-cell;
            text-align:center;
            vertical-align: middle;


<Q&A 281> css3 transform translate translation  .

    通过改变坐标空间，CSS transforms 可以在不影响正常文档流的情况下改变作用内容的位置。通过改变坐标空间，CSS transforms 可以在不影响正常文档流的情况下改变作用内容的位置。

    transforms两个主要的属性

        transform-origin
            指定原点的位置。默认值为元素的中心，可以被移动。很多变形需要用到这个属性，比如旋转，缩放和倾斜，他们都需要一个指定的点作为参数。
            transform-origin: center;
            transform-origin: top left;
        transform
            指定作用在元素上的变形。取值为空格分隔的一系列变形的列表，他们会像被组合操作请求一样被分别执行。
            transform: translate(120px, 50%);
            transform: scale(2, 0.5);
            transform: scale(0.5) translate(-100%, -100%); 

        CSS transform属性允许你旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。

        只能转换由盒子模型定位的元素。根据经验，如果元素具有display: block，则由盒模型定位元素。

        transform属性可以指定为关键字值none 或一个或多个<transform-function>值。

    · transform提升元素的垂直地位

        我们可能都知道这样一个规则，当遭遇元素margin负值重叠的时候，如果没有static以外的position属性值的话，后面的元素是会覆盖前面的元素的。
        元素应用了transform属性之后，就会变得应用了position:relative一个尿性，原本应该被覆盖的元素会雄起，变成覆盖其他元素，
        只要是支持transform元素的浏览器，包括IE9(-ms-), 都会提高普通元素的垂直地位，使其覆盖其他元素而不是被覆盖。

    · transform 限制 position:fixed 的跟随效果

        position:fixed可以让元素不跟随浏览器的滚动条滚动，而且这种跟随效果连它的兄弟们position:relative/absolute都限制不了。
        但是，真是一物降一物，position:fixed固定效果却被小小的transform给干掉了，直接降级变成position:absolute的蛋疼表现。
        注意，这个特性表现，目前只在Chrome浏览器/FireFox浏览器下有，IE浏览器，包括IE11, fixed还是fixed的表现。

    · transform改变overflow对absolute元素的限制

        在以前，overflow与absolute之间的限制规范内容大致是这样的：

        absolute绝对定位元素，如果含有overflow不为visible的父级元素，同时，该父级元素以及到该绝对定位元素之间任何嵌套元素都没有position为非static属性的声明，则overflow对该absolute元素不起作用。

        “无论是overflow容器还是嵌套子元素，只要有transform属性，就会hidden溢出的absolute元素。”

    · transform限制absolute的100%宽度大小

        以前，我们设置absolute元素宽度100%, 则都会参照第一个非static值的position祖先元素计算，没有就window. 现在，诸位，需要把transform也考虑在内了。

        结果，无论是IE9+，还是Chrome还是FireFox浏览器，所有绝对定位图片100%宽度，都是相对设置了transform的容器计算了

    · 补充

        在mac safari浏览器下，使用transform: translate3d(0,0,0) 可以避免文字在其他元素transition或animation时候，粗细渲染跟着变化的问题。

        transform属性还会创建层叠上下文，影响元素发生重叠时候的表现

    · CSS 属性 translate 允许你单独指定 transforms 中的平移，并独立于 transform 属性。这可以更好地反映到典型的用户界面用法，并节省了在指定transform 值时必须记住的转换函数的确切顺序。
            
            /* Keyword values 表示平移效果没有被应用。*/
            translate: none;

            /* Single values 一个长度值或百分比表示X轴和Y轴使用一样的值进行二维上的平移。等同于translate() （2D 平移）函数指定单个值。*/
            translate: 100px;
            translate: 50%;

            /* Two values 两个长度值或百分比表示在二维上分别按照指定X轴和Y轴的值进行的平移。等同于translate() （2D 平移）函数指定两个值。*/
            translate: 100px 200px;
            translate: 50% 105px;

            /* Three values 三个长度值或百分比表示在三维上分别按照指定X轴、Y轴、Z轴的值进行的平移。等同于translate3d() （3D 平移）函数。*/
            translate: 50% 105px 5rem;

    · translate和position：relative的区别： 

            相同点：
                两者都是相对于本身移动位置 
            区别： 
                1、当元素原来已经有position:absolute的时候，这时候你想相对于本身移动，可以使用translate 
                2、做动画的时候translate更适合，不会引起页面的重排和重绘 
                3、关于transform类的，可以使用GPU加速，提高浏览器的性能？ 
            总之：transform更适用于动画

    · position: absolute 与 transform 的区别

            (1) 绝对定位元素的定位基准点是其有定位元素的祖先元素;
            (2) translate要做偏移，是相对于自身的中心点而言，如果用百分比做单位，参考值就是本身元素的宽度。

                负margin水平垂直居中
                    .center {
                            position:absolute;
                            top:50%;
                            left:50%;
                            width:200px;
                            height:200px;
                            margin-top:-200/2px;
                            margin-left:-200/2px;
                    }

                transform 水平垂直居中
                    .center {
                            position:relative;
                                top:50%;
                                left:50%;
                                width:200px;
                                height:200px;
                                background:red;
                                transform:translate(-50%,-50%);
                                transform-origin:50% 50%;
                    }

<Q&A 282> css  animation

        CSS animation 属性是 

            animation-name，
            animation-duration, 
            animation-timing-function，
            animation-delay，
            animation-iteration-count，
            animation-direction，
            animation-fill-mode 和 
            animation-play-state 属性的一个简写属性形式。

            animation 属性用来指定一组或多组动画，每组之间用逗号相隔。

        每组动画规定的属性如下：

        以下属性出现0次或1次：
        <single-transition-timing-function>
            
            
        <single-animation-iteration-count>
            动画播放的次数。该值必须是animation-iteration-count可用的值之一。
        <single-animation-direction>
            动画播放的方向。该值必须是animation-direction可用的值之一。
        <single-animation-fill-mode>
            确定动画在执行之前和之后这两个阶段应用的样式。该值必须是animation-fill-mode可用的值之一。
        <single-animation-play-state>
            确定动画是否正在播放。该值必须是animation-play-state中可用的值之一。
            
        animation 的 name 值可能是：none，<custom-ident>， <string>
        <time> 可能会出现0、1 或 2 次
        每个动画定义中的属性值的顺序很重要：可以被解析为 <time> 的第一个值被分配给animation-duration， 第二个分配给 animation-delay。

<Q&A 283> css overflow

            /* 默认值。内容不会被修剪，会呈现在元素框之外 */
            overflow: visible;

            /* 内容会被修剪，并且其余内容不可见 */
            overflow: hidden;

            /* 内容会被修剪，浏览器会显示滚动条以便查看其余内容 */
            overflow: scroll;

            /* 由浏览器定夺，如果内容被修剪，就会显示滚动条 */
            overflow: auto;

            /* 规定从父元素继承overflow属性的值 */
            overflow: inherit;

<Q&A 284> css 硬件加速

    以下情况会产生新的层叠上下文：

        · 根元素（HTML）
        · 绝对或相对定位且 z-index 值不为 auto
        · 一个伸缩项目 Flex Item，且 z-index 值不为 auto，即父元素 display: flex|inline-flex
        · 元素的 opacity 属性值小于 1
        · 元素的 transform 属性值不为 none
        · 元素的 mix-blend-mode 属性值不为 normal
        · 元素的 filter 属性值不为 normal
        · 元素的 isolation 属性值为 isolate
        · position: fixed
        · will-change 中指定了上述任意属性，即便你没有直接定义这些属性
        · 元素的 -webkit-overflow-scrolling 属性值为 touch

        按照常理来说，改变元素位置会产生重排，为什么上面图中显示的全是重绘呢？原因是绝对定位会建立一个新的图层，而此图层上只有当前一个元素，多以只会重绘，而不会重排。
        在同一层中，元素数量少的情况下，重排性能对更好，速度会更快。

        为什么 transform 没有触发 repaint 呢？简而言之，transform 动画由GPU控制，支持硬件加速，并不需要软件方面的渲染。

    硬件加速原理

　　    浏览器接收到页面文档后，会将文档中的标记语言解析为DOM树。DOM树和CSS结合后形成浏览器构建页面的渲染树。
        渲染树中包含了大量的渲染元素，每一个渲染元素会被分到一个图层中，每个图层又会被加载到GPU形成渲染纹理，
        而图层在GPU中transform 是不会触发 repaint 的，最终这些使用 transform 的图层都会由独立的合成器进程进行处理。

    浏览器什么时候会创建一个独立的复合图层：

            3D 或者 CSS transform
            <video> 和 <canvas> 标签
            CSS filters
            元素覆盖时，比如使用了 z-index 属性

    3D 和 2D transform 的区别就在于：
        
            浏览器在页面渲染前为3D动画创建独立的复合图层，而在运行期间为2D动画创建。
            动画开始时，生成新的复合图层并加载为GPU的纹理用于初始化 repaint。
            然后由GPU的复合器操纵整个动画的执行。最后当动画结束时，再次执行 repaint 操作删除复合图层。

    强制GPU渲染
                
            并不是所有的CSS属性都能触发GPU的硬件加速（图层在GPU中属性改变不会触发 repaint ），实际上只有少数属性可以

                · transform
                · opacity
                · filter
        　  为了避免 2D transform 动画在开始和结束时发生的 repaint 操作，我们可以硬编码一些样式来解决这个问题：

                .example1 {
                transform: translateZ(0);
                }

                .example2 {
                transform: rotateZ(360deg);
                }
            这段代码的作用就是让浏览器执行 3D transform。浏览器通过该样式创建了一个独立图层，图层中的动画则有GPU进行预处理并且触发了硬件加速。
            
    使用硬件加速的问题
                
            · 内存。如果GPU加载了大量的纹理，那么很容易就会发生内容问题，这一点在移动端浏览器上尤为明显，
              所以，一定要牢记不要让页面的每个元素都使用硬件加速。

            · 使用GPU渲染会影响字体的抗锯齿效果。这是因为GPU和CPU具有不同的渲染机制。
              即使最终硬件加速停止了，文本还是会在动画期间显示得很模糊。
            
<Q&A 285> 

        XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，所以AJAX是不允许跨域的。不过 像<script>,<link>,<img>,<iframe>这些标签是允许跨域的，
        但你并不能修 改这些资源，比如iframe里的内容。

<Q&A 286> MVVM(Model-View-ViewModel)

    源自于经典的 Model–View–Controller（MVC）模式。MVVM 的出现促进了 GUI 前端开发与后端业务逻辑的分离，极大地提高了前端开发效率。
    MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，
    该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。View 层展现的不是 Model 层的数据，
    而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的最重要一环。

<Q&A 287> jquery axios fetch

        jquery缺点：
            1.本身是针对MVC的编程,不符合现在前端MVVM的浪潮
            2.基于原生的XHR开发，XHR本身的架构不清晰。
            3.JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）
            4.不符合关注分离（Separation of Concerns）的原则
            5.配置和调用方式非常混乱，而且基于事件的异步模型不友好。

            · 不符合关注分离（Separation of Concerns）的原则
            · 配置和调用方式非常混乱
            · 使用事件机制来跟踪状态变化
            · 基于事件的异步模型没有现代的 Promise，generator/yield，async/await 友好
        
        axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端
        axios是通过promise实现对ajax技术的一种封装，就像jQuery实现ajax封装一样。
        axios既提供了并发的封装，也没有fetch的各种问题，而且体积也较小

        axios特征：
            1.从浏览器中创建 XMLHttpRequest
            2.支持 Promise API
            3.客户端支持防止CSRF
            4.提供了一些并发请求的接口（重要，方便了很多的操作）
            5.从 node.js 创建 http 请求
            6.拦截请求和响应
            7.转换请求和响应数据
            8.取消请求
            9.自动转换JSON数据

            axios和ajax请求本地json区别：
                · 浏览器端发起XMLHttpRequests请求
                · node端发起http请求
                · 支持Promise API
                · 监听请求和返回
                · 转化请求和返回
                · 取消请求
                · 自动转换json数据
                · 客户端支持预防XSRF

        fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。
        Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。
            <script>
                    try {
                        let response = await fetch(url);
                        let data = response.json();
                        console.log(data);
                    } catch(e) {
                        console.log("Oops, error", e);
                    }
            </script>
        
        fetch的优点：
            1.符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里
            2.更好更方便的写法
            3.语法简洁，更加语义化
            4.基于标准 Promise 实现，支持 async/await
            5.同构方便，使用 [isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch)
            6.更加底层，提供的API丰富（request, response）
            7.脱离了XHR，是ES规范里新的实现方式.

        fetch的缺点:
            1）fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。
            2）fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})
            3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
            4）fetch没有办法原生监测请求的进度，而XHR可以
        
        fetch原生支持率并不高，幸运的是，引入下面这些 polyfill 后可以完美支持 IE8+：

            · 由于 IE8 是 ES3，需要引入 ES5 的 polyfill: es5-shim, es5-sham
            · 引入 Promise 的 polyfill: es6-promise
            · 引入 fetch 探测库：fetch-detector
            · 引入 fetch 的 polyfill: fetch-ie8
            · 可选：如果你还使用了 jsonp，引入 fetch-jsonp
            · 可选：开启 Babel 的 runtime 模式，现在就使用 async/await

            <script>

                //fetch API
                fetch('/api').then(function(response) {
                    return response.json()
                }).then(function(data) {
                    console.log(data)
                }).catch(function(error) {
                    console.log('Oops, error: ', error)
                }); 

                //es6 箭头函数
                fetch('/api').then(response => response.json())
                    .then(data => console.log(data))
                    .catch(error => console.log('Oops, error: ', error))

                // async/await
                async function() {
                    try {
                        let response = await fetch(url);
                        let data = response.json();
                        console.log(data);
                    } catch (error) {
                        console.log('Oops, error: ', error)
                    }
                }
                //使用 await 后，写代码就更跟同步代码一样。await 后面可以跟 Promise 对象，表示等待 Promise resolve() 才会继续向下执行，
                //如果 Promise 被 reject() 或抛出异常则会被外面的 try...catch 捕获。

                //基于 XMLHttpRequest 的 AJAX 用 Fetch 改写：

                var options = {
                    method: 'POST',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username: 'admin', password: 'root' }),
                    credentials: 'include' // 携带cookie
                };

                fetch('/api', options).then(response => response.json())
                    .then(data => console.log(data))
                    .catch(error => console.log('Oops, error: ', error))
            </script>

<Q&A 288> 服务端渲染(Server Side Rendering)、预渲染(Prerending)

    服务端渲染是先向后端服务器请求数据，然后生成完整首屏html返回给浏览器；
    而客户端渲染是等js代码下载、加载、解析完成后再请求数据渲染，等待的过程页面是什么都没有的，
    就是用户看到的白屏。就是服务端渲染不需要等待js代码下载完成并请求数据，就可以返回一个已有完整数据的首屏页面。

<Q&A 289> ECMAScript 6 数组的扩展

    Array.from()
        Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。
        常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。
            // NodeList对象
            let ps = document.querySelectorAll('p');
            Array.from(ps).forEach(function (p) {
            console.log(p);
            });

            // arguments对象
            function foo() {
            var args = Array.from(arguments);
            // ...
            }
        只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。

        值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。

            // arguments对象
            function foo() {
            var args = [...arguments];
            }

            // NodeList对象
            [...document.querySelectorAll('div')]
        
    Array.of()
        Array.of方法用于将一组值，转换为数组。
        Array.of(3, 11, 8) // [3,11,8]
        Array.of(3) // [3]
        Array.of(3).length // 1

    数组实例的copyWithin()
        数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。
        Array.prototype.copyWithin(target, start = 0, end = this.length)

            target（必需）：从该位置开始替换数据。
            start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。
            end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。
            这三个参数都应该是数值，如果不是，会自动转为数值。

        [1, 2, 3, 4, 5].copyWithin(0, 3)
        // [4, 5, 3, 4, 5]

    数组实例的fill()
        fill方法使用给定值，填充一个数组。

        ['a', 'b', 'c'].fill(7)
        // [7, 7, 7]

        new Array(3).fill(7)
        // [7, 7, 7]

<Q&A 290> es6

        解构赋值
        let [foo] = 1;
        let [foo] = false;
        let [foo] = NaN;
        let [foo] = undefined;
        let [foo] = null;
        let [foo] = {};
        都会报错，因为右边都不具备Iterator接口（转换成对象后 前五个，或本身不具备 {} ）

        对象解构
        内部机制是先找到同名属性，再赋值给对应的变量
        let {foo: baz} = {foo: 'aaa', bar:'bbb'}
        baz // 'aaa'

        var {message: msg = 'defaultValue'} = {}
        msg // defaultValue

        解构时，右边不是对象，先转对象，undefined和null转不了对象
        let {toString：s} = 123
        s === Number.prototype.toString

        function move({x,y} = {x:0,y:0}) { // 要move的参数和 x，y的值都为 undefined 才触发默认
            return [x,y]
        }
        move({}) // [undefined, undefined]
        move() // [0, 0]

        解构的用途：
            交换变量值
            从函数返回多个值
            函数参数定义
            提取JSON数据
            函数参数的默认值
            遍历Map解构

<Q&A 291> es6 知识点

        0 '' false 为假值
        null undefined 为空值
        null == undefined
        null != false

        NaN != NaN
        typeof NaN // number

        typeof null // undefined
        typeof undefined // undefined

        有了let后，不能先使用后声明变量，typeof也会报ReferenceError错，之前不会

        顶层对象属性和全局对象：
            es5中 顶层对象属性 == 全局变量
            es6中 浏览器中顶层对象 window ； Node环境中，global对象
            js中顶层对象和全局对象相关，导致
                无法再编译时就提示变量未声明，全局变量可能是顶层对象属性动态创造的
                很容易创建全局对象
                顶层对象的属性到处都可以读，不利于模块化
                window有实体含义，浏览器窗口

        es5中
            浏览器顶层对象 window，Node和web worker没有window
            浏览器和web worker中self都指向顶层对象，Node没有self
            Node中顶层对象 global，其他不支持global

            现在似乎优化过了，chrome中通过globalThis可以拿到顶层对象 globalThis === self === window

<Q&A 292> cssRules/rules

    cssRules/rules （内联 + 链接 + 特点：可读可写）

    cssRules/rules 是 CSSStyleSheet 对象的属性

    获取样式的节点对象

        document.getElementsByTagName('link')[0];   //HTMLLinkElement
        document.getElementsByTagName('style')[0];    //HTMLStyleElement

    · 得到sheet对象 （IE使用link.sheet）
        var link = document.getElementsByTagName('link')[0];
        var sheet = link.sheet || link.styleSheet;  //的到CSSStyleSheet对象

    · 对象的属性和方法
        1. 通过 `CSSRules` 属性(非 IE)和 `rules` 属性(IE),我们可以获得样式表的规则集合列表
    
            var sheet = document.styleSheets[0];   //获取CSSStyleSheet对象
            var rules = sheet.cssRules || sheet.rules;

        2. sheet.deleteRule(index)                //删除是定位置的CSS

        3. sheet.insertRules(rule,index)           //在指定位置添加CSS样式

            sheet.insertRules("body { background-color: red }",10);

<Q&A 293> webpack、gulp、grunt

        如果把工具按类型分可以分为这三类：

            基于任务运行的工具：
            Grunt、Gulp
            它们会自动执行指定的任务，就像流水线，把资源放上去然后通过不同插件进行加工，它们包含活跃的社区，丰富的插件，能方便的打造各种工作流。

            基于模块化打包的工具：
            Browserify、Webpack、rollup.js
            有过 Node.js 开发经历的应该对模块很熟悉，需要引用组件直接一个 require 就 OK，这类工具就是这个模式，还可以实现按需加载、异步加载模块。

            整合型工具：
            Yeoman、FIS、jdf、Athena、cooking、weflow
            使用了多种技术栈实现的脚手架工具，好处是即开即用，缺点就是它们约束了技术选型，并且学习成本相对较高。

        特点与不足

            Grunt
                Grunt 是老牌的构建工具，特点是配置驱动，你需要做的就是了解各种插件的功能，然后把配置整合到 Gruntfile.js 中

                Grunt 缺点也是配置驱动，当任务非常多的情况下，试图用配置完成所有事简直就是个灾难；再就是它的 I/O 操作也是个弊病，
                它的每一次任务都需要从磁盘中读取文件，处理完后再写入到磁盘，例如：我想对多个 less 进行预编译、压缩操作，那么 Grunt 的操作就是：

                读取 less 文件 -> 编译成 css -> 存储到磁盘 -> 读取 css -> 压缩处理 -> 存储到磁盘

                这样一来当资源文件较多，任务较复杂的时候性能就是个问题了。

            Gulp
                Gulp 特点是代码驱动，写任务就和写普通的 Node.js 代码一样

                再一个对文件读取是流式操作（Stream），也就是说一次 I/O 可以处理多个任务，还是 less 的例子，Gulp 的流程就是：

                读取 less 文件 -> 编译成 css -> 压缩处理 -> 存储到磁盘

                Gulp 作为任务类型的工具没有明显的缺点，唯一的问题可能就是完成相同的任务它需要写的代码更多一些，
                所以除非是项目有历史包袱（原有项目就是基于 Grunt 构建）在 Grunt 与 Gulp 对比看来还是比较推荐 Gulp！

                适用场景：
                    通过上面的介绍可以看出它们侧重对整个过程的控制管理，实现简单、对架构无要求、不改变开发模式，所以非常适合前端、小型、需要快速启动的项目。

            Webpack 的特点：

                把一切都视为模块：不管是 CSS、JS、Image 还是 HTML 都可以互相引用，通过定义 entry.js，对所有依赖的文件进行跟踪，将各个模块通过 loader 和 plugins 处理，然后打包在一起。
                按需加载：打包过程中 Webpack 通过 Code Splitting 功能将文件分为多个 chunks，还可以将重复的部分单独提取出来作为 commonChunk，从而实现按需加载。
                Webpack 也是通过配置来实现管理，与 Grunt 不同的时，它包含的许多自动化的黑盒操作所以配置起来会简单很多（但遇到问题调试起来就很麻烦），一个典型的配置如下：

                module.exports = {
                    //插件项
                    plugins: [commonsPlugin],
                    //页面入口文件配置
                    entry: {
                        index : './src/js/page/index.js'
                    },
                    //入口文件输出配置
                    output: {
                        path: 'dist/js/page',
                        filename: '[name].js'
                    },
                    module: {
                        //加载器配置
                        loaders: [
                            { test: /\.css$/, loader: 'style-loader!css-loader' },
                            { test: /\.js$/, loader: 'jsx-loader?harmony' },
                            { test: /\.scss$/, loader: 'style!css!sass?sourceMap'},
                            { test: /\.(png|jpg)$/, loader: 'url-loader?limit=8192'}
                        ]
                    },
                    //其它解决方案配置
                    resolve: {
                        root: '/Users/Bell/github/flux-example/src', //绝对路径
                        extensions: ['', '.js', '.json', '.scss'],
                        alias: {
                            AppStore : 'js/stores/AppStores.js',
                            ActionType : 'js/actions/ActionType.js',
                            AppAction : 'js/actions/AppAction.js'
                        }
                    }
                };

                不足：

                上手比较难：官方文档混乱、配置复杂、难以调试（Webpack2 已经好了很多）对于新手而言需要经历踩坑的过程；
                对于 Server 端渲染的多页应用有点力不从心：Webpack 的最初设计就是针对 SPA，所以在处理 Server 端渲染的多页应用时，
                不管你如何 chunk，总不能真正达到按需加载的地步，往往要去考虑如何提取公共文件才能达到最优状态。

                模块化与组件化
                    提到 Webpack 就不得不说它的模块化加载方式，先来看下传统的模块化方式：

                    ├── scripts/
                    │    ├── dropdown.js
                    │    ├── lazyload.js
                    │    ├── modal.js
                    │    └── slider.js
                    ├── styles/
                    │    ├── button.less
                    │    ├── list.less
                    │    ├── modal.less
                    │    └── slider.less
                    传统的模块化基于单种编程语言，目的是为了解耦和重用，而因为前端本身的特点（需要三种编程语言配合）以及能力限制，所以不能实现跨资源加载也就难以实现组件化。

                    而 Webpack 打破的这种思维局限，它的 Require anything 的理念在实现模块化的同时也能够很方便实现组件化，借助 Webpack 就可以很轻松的实现这种代码组织结构：

                    ├──components/
                    │    ├── button/
                    │    │    ├── button.js
                    │    │    ├── button.less
                    │    │    ├── dropdwon.js
                    │    │    └── icon.png
                     <input
                type="text"
                v-model="something">
        <!--等价于-->
        <input
                type="text"
                v-bind:value="something"
                v-on:input="something = $event.target.value">
                    │    ├── modal/
                    │    ├── slider/
                
                一旦实现组件化，那么我们的项目开发方式和分工合作方式就可以升级，可以实现分组件并行开发，也可以方便的引用其它项目使用的组件

                适用场景：
                    综上所述，Webpack 特别适合配合 React.js、Vue.js 构建单页面应用以及需要多人合作的大型项目，在规范流程都已约定好的情况下往往能极大的提升开发效率与开发体验。

<Q&A 294> v-model

        v-model 是一种语法糖
         <input type="text" v-model="something">
         <!--等价于-->
         <input type="text" v-bind:value="something" v-on:input="something = $event.target.value">

         v-model在 普通input上
            一定要明确在给 <input /> 元素添加 v-model 属性时，默认会把 value 作为元素的属性，然后把 'input' 事件作为实时传递 value 的触发事件（具体参考语法糖的解释）

        v-model用在组件上
            给组件添加 v-model 属性时，默认会把 value 作为组件的属性，然后把 'input' 值作为给组件绑定事件时的事件名

        html:
            <div id="demo">
                <currency-input v-model="price"></currentcy-input>
                <span>{{price}}</span>
            </div>

        js:
            Vue.component('currency-input', {
                template: `
                <span>
                <input
                    ref="input"
                    :value="value"
                    <!--为什么这里把 'input' 作为触发事件的事件名？`input` 在哪定义的？-->
                    @input="$emit('input', $event.target.value)"
                >
                </span>
                `,
                props: ['value'],// 为什么这里要用 value 属性，value在哪里定义的？貌似没找到啊？
            })

            var demo = new Vue({
                el: '#demo',
                data: {
                    price: 100,
                }
            })

        子组件中的v-model相当于<currency-input :value="price" @input="price = arguments[0]"></currency-input>
        js中@input="$emit('input', $event.target.value)" 子组件在监听input事件发生的时候（即@input）,向父组件传递了input($emit中的input)事件，并且传递了当前子组件的price值。
        而在父组件中，监听了自定义事件input，当自定义事件input触发后，将当前父组件自身的price值改为子组件中$emit上来的值（$event.target.value 是作为$emit传递的参数，所以是arguments[0]）

        v-model存在的问题
            对于复选框或者单选框的常见组件时，由于v-model默认传的是value，不是checked，触发事件也不是oninput而是onchange

            对于单纯的input type='checkbox'
            <input type="checkbox" :checked="status" @change="status = $event.target.checked" />

            当用到组件上时：

            <my-checkbox v-model="foo"></my-checkbox>

            Vue.component('my-checkbox', {
                tempalte: `<input 
                        type="checkbox"
                        @change="$emit('input', $event.target.checked)"
                        :checked="value"
                    />`
                props: ['value'],
            })

            这个时候需要Vue的model选项
            model选项可以指定当前的事件类型和传入的props

            <my-checkbox v-model="foo"></my-checkbox>

            Vue.component('my-checkbox', {
                tempalte: `<input 
                        type="checkbox"
                        <!--这里就不用 input 了，而是 balabala-->
                        @change="$emit('balabala', $event.target.checked)"
                        :checked="value"
                    />`
                props: ['checked'], //这里就不用 value 了，而是 checked
                model: { // model选项来指定
                    prop: 'checked',
                    event: 'balabala'
                },
            })


<Q&A 295>
<Q&A 296>
<Q&A 297>
<Q&A 298>
<Q&A 299>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>
<Q&A 125>